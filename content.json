{"meta":{"title":"Clover Days","subtitle":"Clover Days Blog","description":"软件工程","author":"Clover Days","url":"http://www.luckyzmj.cn","root":"/"},"pages":[{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2022-07-01T03:13:50.360Z","comments":true,"path":"List/index.html","permalink":"http://www.luckyzmj.cn/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"","date":"2022-07-01T03:14:06.212Z","updated":"2022-07-01T03:13:50.534Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"http://www.luckyzmj.cn/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2022-07-01T03:14:06.227Z","updated":"2022-07-01T03:13:50.540Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"http://www.luckyzmj.cn/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2022-07-01T03:13:50.329Z","comments":true,"path":"404.html","permalink":"http://www.luckyzmj.cn/404.html","excerpt":"","text":""},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2022-07-01T03:13:50.531Z","comments":true,"path":"about/index.html","permalink":"http://www.luckyzmj.cn/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2022-07-01T03:13:50.533Z","comments":true,"path":"archives/index.html","permalink":"http://www.luckyzmj.cn/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2022-07-01T03:13:50.535Z","comments":true,"path":"categories/index.html","permalink":"http://www.luckyzmj.cn/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2022-07-01T03:13:50.538Z","comments":true,"path":"contact/index.html","permalink":"http://www.luckyzmj.cn/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 Luckeyの友链信息 博客名称: Luckeyの博客 博客网址: http://www.luckyzmj.cn 博客头像: https://s1.ax1x.com/2020/05/17/YRWsYT.png 博客介绍: The harder you work, the luckier you will be"},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2022-07-01T03:13:50.537Z","comments":true,"path":"census/index.html","permalink":"http://www.luckyzmj.cn/census/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2022-07-01T03:13:50.539Z","comments":true,"path":"friends/index.html","permalink":"http://www.luckyzmj.cn/friends/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2022-07-01T03:13:50.541Z","comments":true,"path":"resource/index.html","permalink":"http://www.luckyzmj.cn/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2022-07-01T03:13:50.544Z","comments":true,"path":"tags/index.html","permalink":"http://www.luckyzmj.cn/tags/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-07-01T03:13:50.364Z","comments":true,"path":"List/tools/index.html","permalink":"http://www.luckyzmj.cn/List/tools/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-07-01T03:14:06.369Z","updated":"2022-07-01T03:13:50.343Z","comments":true,"path":"List/galleries/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2022-07-01T03:13:50.361Z","comments":true,"path":"List/movies/index.html","permalink":"http://www.luckyzmj.cn/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2022-07-01T03:13:50.363Z","comments":true,"path":"List/music/index.html","permalink":"http://www.luckyzmj.cn/List/music/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2022-07-01T03:14:06.379Z","updated":"2022-07-01T03:13:50.344Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2022-07-01T03:14:06.389Z","updated":"2022-07-01T03:13:50.345Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2022-07-01T03:14:06.399Z","updated":"2022-07-01T03:13:50.346Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2022-07-01T03:14:06.409Z","updated":"2022-07-01T03:13:50.348Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2022-07-01T03:14:06.447Z","updated":"2022-07-01T03:13:50.354Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2022-07-01T03:14:06.428Z","updated":"2022-07-01T03:13:50.351Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2022-07-01T03:14:06.419Z","updated":"2022-07-01T03:13:50.349Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2022-07-01T03:14:06.475Z","updated":"2022-07-01T03:13:50.358Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2022-07-01T03:14:06.466Z","updated":"2022-07-01T03:13:50.356Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2022-07-01T03:14:06.485Z","updated":"2022-07-01T03:13:50.359Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2022-07-01T03:14:06.438Z","updated":"2022-07-01T03:13:50.352Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2022-07-01T03:14:06.456Z","updated":"2022-07-01T03:13:50.355Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"http://www.luckyzmj.cn/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""}],"posts":[{"title":"程序员必备小工具","slug":"程序员必备小工具","date":"2022-06-30T02:31:28.000Z","updated":"2022-07-01T04:18:52.390Z","comments":true,"path":"posts/df7e4c26.html","link":"","permalink":"http://www.luckyzmj.cn/posts/df7e4c26.html","excerpt":"","text":"程序员必备小工具Markdown（Typora）：插入代码： 左上角数字旁边` *3;后选择语言 ` `` package demo; public class Demo{ public static void main(String[] args){ System.out.println(\"这是插入的一段代码\"); } } git/SVN（版本管理工具）： 常用API 释义 PlasticSCM（游戏版本管理工具）：Maven（项目管理工具）Emmet 前端便捷开发语法：（完成）后代：&gt;缩写为： table&gt;tr&gt;th&gt;td*2 展开输出： &lt;table&gt; &lt;tr&gt; &lt;th&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;/td&gt; &lt;/th&gt; &lt;/tr&gt; &lt;/table&gt; 兄弟：+缩写为： div+p+table+tr+td 展开式为； &lt;div&gt;&lt;/div&gt; &lt;p&gt;&lt;/p&gt; &lt;table&gt;&lt;/table&gt; &lt;tr&gt;&lt;/tr&gt; &lt;td&gt;&lt;/td&gt; 上级：^缩写为： div+div&gt;p&gt;span+em^bq 展开式为： &lt;div&gt;&lt;/div&gt; &lt;div&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt; &lt;blockquote&gt;&lt;/blockquote&gt; &lt;/div&gt; 缩写为 div+div&gt;p&gt;span+em^^bq 展开式： &lt;div&gt;&lt;/div&gt; &lt;div&gt; &lt;p&gt;&lt;span&gt;&lt;/span&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt; &lt;/div&gt; &lt;blockquote&gt;&lt;/blockquote&gt; 分组：() 缩写： div&gt;(header&gt;ul&gt;li*2&gt;a)+footer&gt;p 展开式为： &lt;div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;li&gt; &lt;/ul&gt; &lt;/header&gt; &lt;/footer&gt; &lt;p&gt;&lt;/p&gt; &lt;/footer&gt; &lt;/div&gt; 2.缩写为： (div&gt;dl&gt;(dt+dd)*3)+footer&gt;p 展开式为： &lt;div&gt; &lt;dl&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;dt&gt;&lt;/dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; &lt;footer&gt; &lt;p&gt;&lt;/p&gt; &lt;/footer&gt; 乘法：*缩写为： ul&gt;li*5 展开式： &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;ul&gt; 自增符号：$ 缩写为： ul&gt;li.item$*5 展开式为： &lt;ul&gt; &lt;li class=\"item1\"&gt;&lt;/li&gt; &lt;li class=\"item2\"&gt;&lt;/li&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt; &lt;li class=\"item4\"&gt;&lt;/li&gt; &lt;li class=\"item5\"&gt;&lt;/li&gt; &lt;ul&gt; 缩写为： h$[title=item$]{Header $}*3 展开式为： &lt;h1 title=\"item1\"&gt;Header 1&lt;/h1&gt; &lt;h2 title=\"item2\"&gt;Header 2&lt;/h2&gt; &lt;h3 title=\"item3\"&gt;Header 3&lt;/h3&gt; 缩写式为： ul&gt;li.item$$$*5 展开式输出： &lt;ul&gt; &lt;li class=\"item001\"&gt;&lt;/li&gt; &lt;li class=\"item002\"&gt;&lt;/li&gt; &lt;li class=\"item003\"&gt;&lt;/li&gt; &lt;li class=\"item004\"&gt;&lt;/li&gt; &lt;li class=\"item005\"&gt;&lt;/li&gt; &lt;/ul&gt; 缩写： ul&gt;li.item$@-*5 展开式： &lt;ul&gt; &lt;li class=\"item5\"&gt;&lt;/li&gt; &lt;li class=\"item4\"&gt;&lt;/li&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt; &lt;li class=\"item2\"&gt;&lt;/li&gt; &lt;li class=\"item1\"&gt;&lt;/li&gt; &lt;/ul&gt; 缩写： ul&gt;li.item$@3*5 展开式： &lt;ul&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt; &lt;li class=\"item4\"&gt;&lt;/li&gt; &lt;li class=\"item5\"&gt;&lt;/li&gt; &lt;li class=\"item6\"&gt;&lt;/li&gt; &lt;li class=\"item7\"&gt;&lt;/li&gt; &lt;/ul&gt; ID和类属性 缩写： #header 展开式： &lt;div id =\"header\"&gt;&lt;/div&gt; 缩写： .title 展开式： &lt;div class=\"title\"&gt;&lt;/div&gt; 缩写： form#search.wide 展开式： &lt;form id=\"search\" class=\"wide\"&gt;&lt;/form&gt; 缩写： p.class1.class2.class3 展开输出： &lt;p class=\"class1 class2 class3\"&gt;&lt;/p&gt; 自定义属性 缩写： p[title=\"Hello world\"] 展开式： &lt;p title=\"Hello world\"&gt;&lt;/p&gt; 缩写： td[rowspan=2 colspan=3 title] 展开式： &lt;td rowspan=\"2\" colspan=\"3\" title=\"\"&gt;&lt;/td&gt; 缩写： [a='value1' b=\"value2\"] 展开式： &lt;div a=\"value1\" b=\"value2\"&gt;&lt;/div&gt; 文本：{} 缩写： a{Click me} 展开式： &lt;a href=\"\"&gt;Click me&lt;/a&gt; 隐式标签 缩写 .class 展开式： &lt;div class=\"class\"&gt;&lt;/div&gt; 缩写： em&gt;.class 展开式： &lt;em&gt;&lt;span class=\"class\"&gt;&lt;/span&gt;&lt;/em&gt; 缩写 ul&gt;.class 展开式： &lt;ul&gt; &lt;li class=\"class\"&gt;&lt;/li&gt; &lt;/ul&gt; 缩写： table&gt;.row&gt;.col 展开式： &lt;table&gt; &lt;tr class=\"row\"&gt; &lt;td class=\"col\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; HTML标签语法所有未知的缩写标签 hangge 展开式： &lt;hangge&gt;&lt;/hangge&gt; 基本HTML标签： ! 展开式 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; (2)缩写↓ Copy a 展开输出↓ (3)缩写↓ Copy a:link 展开输出↓","categories":[],"tags":[]},{"title":"C#多线程与网络编程（建设中）","slug":"后端编程语言/C-多线程与网络编程","date":"2022-06-29T07:57:54.000Z","updated":"2022-07-01T04:18:52.405Z","comments":true,"path":"posts/e4db942a.html","link":"","permalink":"http://www.luckyzmj.cn/posts/e4db942a.html","excerpt":"","text":"C# 网络编程与多线程多线程：Thread类：构造函数： Thread(); 常用API： 属性或方法 说明 Name 属性，获取或设置线程的名称 Priority 属性，获取或设置线程的优先级 ThreadState 属性，获取线程当前的状态 IsAlive 属性，获取当前线程是否处于启动状态 IsBackground 属性，获取或设置值，表示该线程是否为后台线程 CurrentThreadCurrentContext 属性，获取当前正在运行的线程属性，获取正在其中执行的当前上下文 Start() 方法，启动线程 Sleep(int millisecondsTimout) 方法，将当前线程暂停指定的毫秒数 Suspend() 方法，挂起当前线程（已经被弃用） Join() 方法，阻塞调用线程，直到某个线程终止为止 Interrupt() 方法，中断当前线程 Resume() 方法，继续已经挂起的线程（已经被弃用） Abort() 方法，终止线程 代码示例： 创建线程： class Programe{ public static void CallToChildThread{ Console.WriteLine(\"子线程开始\"); } static void main(String[] args){ ThreadStart child = new ThreadStart(CallToChildThread); //调用子线程中的方法 Console.WriteLine(\"主线程开始\"); Thread childThread = new Thread(child); //创建子线程 childThread.Start(); Console.ReadKey(); } } 销毁线程： 网络编程：using System.Net POP3协议构造方法： 常用API: 命令 描述 USER 此命令与下面的pass命令若都发送成功，将使状态转换 PASS 用户名所对应的密码 APOP MD5消息摘要 STAT 请求服务器发回关于邮箱统计资料（邮件总数和总字节数） UIDL 回送邮件唯一标识符 LIST 回送邮件数量和每个邮件的大小 RETR 回送由参数标识的邮件的全部文本 DELE 服务器将由参数标识的邮件标记为删除，由QUIT命令执行 RSET 服务器将重置所有标记为删除的邮件，用于撤消DELE命令 TOP 服务器将回送由参数标识的邮件前n行内容，n是正整数 NOOP 服务器返回一个肯定的响应，不做任何操作 QUIT 退出 注意：SMTP服务器使用的端口号一般为25，POP服务器使用的端口号一般为110。 Dns类：静态类（无法创建实例），用于从 Internet 域名系统 (DNS) 检索有关特定主机的信息。DNS查询中的主机信息在类的IPHostEntry实例中返回。如果指定的主机在DNS数据库中有多个条目，IPHost则包含多个IP地址和别名。 常用API: BeginGetHostAddresses(String, AsyncCallback, Object) 异步返回指定主机的 Internet 协议 (IP) 地址。 BeginGetHostByName(String, AsyncCallback, Object) 已过时。开始异步请求关于指定 DNS 主机名的 IPHostEntry 信息。 BeginGetHostEntry(IPAddress, AsyncCallback, Object) 将 IP 地址异步解析为 IPHostEntry 实例。 BeginGetHostEntry(String, AsyncCallback, Object) 将主机名或 IP 地址异步解析为 IPHostEntry 实例。 BeginResolve(String, AsyncCallback, Object) 已过时。开始异步请求将 DNS 主机名或 IP 地址解析为 IPAddress 实例。 EndGetHostAddresses(IAsyncResult) 结束对 DNS 信息的异步请求。 EndGetHostByName(IAsyncResult) 已过时。结束对 DNS 信息的异步请求。 EndGetHostEntry(IAsyncResult) 结束对 DNS 信息的异步请求。 EndResolve(IAsyncResult) 已过时。结束对 DNS 信息的异步请求。 GetHostAddresses(String) 返回指定主机的 Internet 协议 (IP) 地址。 GetHostAddresses(String, AddressFamily) 返回指定主机的 Internet 协议 (IP) 地址。 GetHostAddressesAsync(String) 返回指定主机的 Internet 协议 (IP) 地址以作为异步操作。 GetHostAddressesAsync(String, AddressFamily, CancellationToken) 返回指定主机的 Internet 协议 (IP) 地址以作为异步操作。 GetHostAddressesAsync(String, CancellationToken) 返回指定主机的 Internet 协议 (IP) 地址以作为异步操作。 GetHostByAddress(IPAddress) 已过时。根据指定的 IPAddress 创建 IPHostEntry 实例。 GetHostByAddress(String) 已过时。根据 IP 地址创建 IPHostEntry 实例。 GetHostByName(String) 已过时。获取指定 DNS 主机名的 DNS 信息。 GetHostEntry(IPAddress) 将 IP 地址解析为 IPHostEntry 实例。 GetHostEntry(String) 将主机名或 IP 地址解析为 IPHostEntry 实例。 GetHostEntry(String, AddressFamily) 将主机名或 IP 地址解析为 IPHostEntry 实例。 GetHostEntryAsync(IPAddress) 将 IP 地址解析为 IPHostEntry 实例以作为异步操作。 GetHostEntryAsync(String) 将主机名或 IP 地址解析为 IPHostEntry 实例以作为异步操作。 GetHostEntryAsync(String, AddressFamily, CancellationToken) 将主机名或 IP 地址解析为 IPHostEntry 实例以作为异步操作。 GetHostEntryAsync(String, CancellationToken) 将主机名或 IP 地址解析为 IPHostEntry 实例以作为异步操作。 GetHostName() 获取本地计算机的主机名。 Resolve(String) 已过时。将 DNS 主机名或 IP 地址解析为 IPHostEntry 实例。 代码示例： IDAddress类IPAddress类包含计算机在IP网络上的地址，它主要用来提供网际协议（IP）地址。 IPAddress类的常用字段、属性、方法及说明 字段、属性及方法 说明 Any字段 提供一个IP地址，指示服务器应侦听所有网络接口上的客户端活动。此字段为只读 Broadcast字段 提供IP广播地址。此字段为只读 Loopoback字段 提供IP环回地址。此字段为只读 None字段 提供指示不应使用任何网络接口的IP地址。此字段为只读 Address属性 网际协议（IP）地址 AddressFamily属性 获取IP地址的地址族 IsIPv6LinkLocal属性 获取地址是否为IPv6链接本地地址 IsIPv6Multicast属性 获取地址是否为IPv6多路广播全局地址 IsIPv6SiteLocal属性 获取地址是否为IPv6站点本地地址 ScopeId属性 获取或设置IPv6地址范围标识符 GetAddressBytes方法 以字节数组形式提供IPAddress的副本 IsLoopback方法 指示指定的IP地址是否是环回地址 Parse方法 将IP地址字符串转换为IPAddress实例 TryParse方法 确定字符串是否为有效的IP地址 代码示例： IPEndPoint类IPEndPoint类包含应用程序连接到主机上的服务所需的主机和本地或远程端口信息。通过组合服务的主机IP地址和端口号，IPEndPoint类形成到服务的连接点，它主要用来将网络端点表示为IP地址和端口号。 构造方法： IPEndPont(Int64,Int32); IPEndPonint(long address,int port); //代码示例 常用方法： 字段及属性 说明 MaxPort字段 指定可以分配给Port属性的最大值。MaxPort值设置为0x0000FFFF。此字段为只读 MinPort字段 指定可以分配给Port属性的最小值。此字段为只读 Address属性 获取或设置终结点的IP地址 AddressFamily属性 获取网际协议（IP）地址族 Port属性 获取或设置终结点的端口号 代码示例： WebClient类WebClient类提供向URI标识的任何本地、Intranet或Internet资源发送数据以及从这些资源接收数据的公共方法。 表4 WebClient类的常用属性、方法及说明 属性及方法 说明 BaseAddress属性 获取或设置WebClient发出请求的基URI Encoding属性 获取和设置用于上载和下载字符串的Encoding Headers属性 获取或设置与请求关联的标头名称/值对集合 QueryString属性 获取或设置与请求关联的查询名称/值对集合 ResponseHeaders属性 获取与响应关联的标头名称/值对集合 DownloadData方法 以Byte数组形式通过指定的URI下载 DownloadFile方法 将具有指定URI的资源下载到本地文件 DownloadString方法 以String或URI形式下载指定的资源 OpenRead方法 为从具有指定URI的资源下载的数据打开一个可读的流 OpenWrite方法 打开一个流以将数据写入具有指定URI的资源 UploadData方法 将数据缓冲区上载到具有指定URI的资源 UploadFile方法 将本地文件上载到具有指定URI的资源 UploadString方法 将指定的字符串上载到指定的资源 UploadValues方法 将名称/值集合上载到具有指定URI的资源 代码示例： WebRequest/WebResponse类 WebRequest类是.NET Framework的请求/响应模型的抽象基类，用于访问Internet数据。使用该请求/响应模型的应用程序可以用协议不可知的方式从Internet请求数据，在这种方式下，应用程序处理WebRequest类的实例，而协议特定的子类则执行请求的具体细节。 WebResponse类也是抽象基类，应用程序可以使用WebResponse类的实例以协议不可知的方式参与请求和响应事务，而从WebResponse类派生的协议类携带请求的详细信息。另外，需要注意的是，客户端应用程序不直接创建WebResponse对象，而是通过对WebRequest实例调用GetResponse方法来进行创建。 WebRequest类的常用属性、方法及说明 属性及方法 说明 ConnectionGroupName属性 当在子类中重写时，获取或设置请求的连接组的名称 ContentLength属性 当在子类中被重写时，获取或设置所发送的请求数据的内容长度 ContentType属性 当在子类中被重写时，获取或设置所发送的请求数据的内容类型 Headers属性 当在子类中被重写时，获取或设置与请求关联的标头名称/值对的集合 Method属性 当在子类中被重写时，获取或设置要在此请求中使用的协议方法 RequestUri属性 当在子类中被重写时，获取与请求关联的Internet资源的URI Timeout属性 获取或设置请求超时前的时间长度 Abort方法 中止请求 BeginGetResponse方法 当在子类中被重写时，开始对Internet资源的异步请求 Create方法 初始化新的WebRequest EndGetResponse方法 当在子类中重写时，返回WebResponse GetRequestStream方法 当在子类中重写时，返回用于将数据写入Internet资源的Stream GetResponse方法 当在子类中被重写时，返回对Internet请求的响应 RegisterPrefix方法 为指定的URI注册WebRequest子代 WebResponse类中的常用属性、方法及说明如表6所示。 表6 WebResponse类的常用属性、方法及说明 属性及方法 说明 ContentLength属性 当在子类中重写时，获取或设置接收的数据的内容长度 ContentType属性 当在派生类中重写时，获取或设置接收的数据的内容类型 Headers属性 当在派生类中重写时，获取与此请求关联的标头名称/值对的集合 ResponseUri属性 当在派生类中重写时，获取实际响应此请求的Internet资源的URI Close方法 当由子类重写时，将关闭响应流 GetResponseStream方法 当在子类中重写时，从Internet资源返回数据流 代码示例： Socket类using System.Socket 构造函数： 常用属性： 属性 说明 AddressFamily 获取Socket的地址族 Available 获取已经从网络接收且可供读取的数据量 Connected 获取一个值，该值指示Socket是在上次Send还是Receive操作时连接到远程主机 Handle 获取Socket的操作系统句柄 LocalEndPoint 获取本地终结点 ProtocolType 获取Socket的协议类型 RemoteEndPoint 获取远程终结点 SendTimeout 获取或设置一个值，该值指定之后同步Send调用将超时的时间长度 常用方法：表8 Socket类的常用方法及说明 方法 说明 Accept 为新建连接创建新的Socket BeginAccept 开始一个异步操作来接受一个传入的连接尝试 BeginConnect 开始一个对远程主机连接的异步请求 BeginDisconnect 开始异步请求从远程终结点断开连接 BeginReceive 开始从连接的Socket中异步接收数据 BeginSend 将数据异步发送到连接的Socket BeginSendFile 将文件异步发送到连接的Socket对象 BeginSendTo 向特定远程主机异步发送数据 Close 关闭Socket连接并释放所有关联的资源 Connect 建立与远程主机的连接 Disconnect 关闭套接字连接并允许重用套接字 EndAccept 异步接受传入的连接尝试 EndConnect 结束挂起的异步连接请求 EndDisconnect 结束挂起的异步断开连接请求 EndReceive 结束挂起的异步读取 EndSend 结束挂起的异步发送 EndSendFile 结束文件的挂起异步发送 EndSendTo 结束挂起的、向指定位置进行的异步发送 Listen 将Socket置于侦听状态 Receive 接收来自绑定的Socket的数据 Send 将数据发送到连接的Socket SendFile 将文件和可选数据异步发送到连接的Socket SendTo 将数据发送到特定终结点 Shutdown 禁用某Socket上的发送和接收 TcpClient/TcpListener TcpClient类用于在同步阻止模式下通过网络来连接、发送和接收流数据。为使TcpClient连接并交换数据，使用TCP ProtocolType类创建的TcpListener实例或Socket实例必须侦听是否有传入的连接请求。可以使用下面两种方法之一连接到该侦听器。 创建一个TcpClient，并调用3个可用的Connect方法之一。 使用远程主机的主机名和端口号创建TcpClient，此构造函数将自动尝试一个连接。 TcpListener类用于在阻止同步模式下侦听和接受传入的连接请求。可使用TcpClient类或Socket类来连接TcpListener，并且可以使用IPEndPoint、本地IP地址及端口号或者仅使用端口号来创建TcpListener实例对象。 表9 TcpClient类的常用属性、方法及说明 属性及方法 说明 Available属性 获取已经从网络接收且可供读取的数据量 Client属性 获取或设置基础Socket Connected属性 获取一个值，该值指示TcpClient的基础Socket是否已连接到远程主机 ReceiveBufferSize属性 获取或设置接收缓冲区的大小 ReceiveTimeout属性 获取或设置在初始化一个读取操作以后TcpClient等待接收数据的时间量 SendBufferSize属性 获取或设置发送缓冲区的大小 SendTimeout属性 获取或设置TcpClient等待发送操作成功完成的时间量 BeginConnect方法 开始一个对远程主机连接的异步请求 Close方法 释放此TcpClient实例，而不关闭基础连接 Connect方法 使用指定的主机名和端口号将客户端连接到TCP主机 EndConnect方法 异步接受传入的连接尝试 GetStream方法 返回用于发送和接收数据的NetworkStream TcpListener类的常用属性、方法及说明如表10所示。 表10 TcpListener类的常用属性、方法及说明 属性及方法 说明 LocalEndpoint属性 获取当前TcpListener的基础EndPoint Server属性 获取基础网络Socket AcceptSocket/AcceptTcpClient方法 接受挂起的连接请求 BeginAcceptSocket/BeginAcceptTcpClient方法 开始一个异步操作来接受一个传入的连接尝试 EndAcceptSocket方法 异步接受传入的连接尝试，并创建新的Socket来处理远程主机通信 EndAcceptTcpClient方法 异步接受传入的连接尝试，并创建新的TcpClient来处理远程主机通信 Start方法 开始侦听传入的连接请求 Stop方法 关闭侦听器 代码示例： UdpClient类UdpClient类用于在阻止同步模式下发送和接收无连接UDP数据报。因为UDP是无连接传输协议，所以不需要在发送和接收数据前建立远程主机连接，但可以选择使用下面两种方法之一来建立默认远程主机。 使用远程主机名和端口号作为参数创建UdpClient类的实例。 创建UdpClient类的实例，然后调用Connect方法。 UdpClient类的常用属性、方法及说明 属性及方法 说明 Available属性 获取从网络接收的可读取的数据量 Client属性 获取或设置基础网络Socket BeginReceive方法 从远程主机异步接收数据报 BeginSend方法 将数据报异步发送到远程主机 Close方法 关闭UDP连接 Connect方法 建立默认远程主机 EndReceive方法 结束挂起的异步接收 EndSend方法 结束挂起的异步发送 Receive方法 返回已由远程主机发送的UDP数据报 Send方法 将UDP数据报发送到远程主机 代码示例： MailMessage类using System.Net.Mail AttachmentSmtmpClient","categories":[{"name":"后端编程语言","slug":"后端编程语言","permalink":"http://www.luckyzmj.cn/categories/%E5%90%8E%E7%AB%AF%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://www.luckyzmj.cn/tags/C/"},{"name":"网络编程","slug":"网络编程","permalink":"http://www.luckyzmj.cn/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"多线程","slug":"多线程","permalink":"http://www.luckyzmj.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"JavaScript知识体系","slug":"前端编程语言/JavaScript知识体系","date":"2022-06-28T12:25:12.000Z","updated":"2022-07-01T04:18:52.401Z","comments":true,"path":"posts/89207bf2.html","link":"","permalink":"http://www.luckyzmj.cn/posts/89207bf2.html","excerpt":"","text":"javaScript介绍： JS 是当前最流行、应用最广泛的客户端脚本语言，在 Web 开发领域有着举足轻重的地位，是成为一名优秀前端工程师的必备技能之一。 相比于其它编程语言，学习 JS 有以下几个优势： JavaScript 是最流行的客户端脚本语言，有着简单易学的特点。学有所成后，您可以使用一些基于 JavaScript 的框架（例如 JQuery、Node.js）来开发前端或后端应用程序； JavaScript 可以在 Web 浏览器中运行，因此学习 JavaScript，您不需要配置任何特殊的运行环境； JavaScript 的应用非常广泛，例如移动应用开发、桌面应用开发、Web 游戏开发等都会用到 JavaScript，为 JavaScript 程序员提供了更多的就业机会； JavaScript 有着大量的优质框架和库，借助这些框架和库可以大大减少您的开发时间。 JavaScript的应用范围： Web前端网页开发： 移动应用开发： Web游戏开发： 后端Web应用开发： JavaScript整理：导读： 引入JavaScript文件 &lt;link rel =\"preload\" href=\"\" as \"script&gt;&lt;/link&gt;\" 面向过程/面向对象：选择分支：（完成）if、if-else：if-else if(条件表达式){ // 当表达式成立时要执行的代码 }else{ // 当表达式不成立时要执行的代码 } //N个else if语句 if (条件表达式 1) { // 条件表达式 1 为真时执行的代码 } else if (条件表达式 2) { // 条件表达式 2 为真时执行的代码 } ... else if (条件表达式N) { // 条件表达式 N 为真时执行的代码 } else { // 所有条件表达式都为假时要执行的代码 } 提示：if else if else 语句在执行过程中，当遇到成立的条件表达式时，会立即执行其后{ }中的代码，然后退出整个 if else if else 语句，若后续代码中还有成立的条件表达式，则不会执行。 注意事项：使用嵌套 if else 时，如果只有一行语句，也应该使用大括号包裹起来，避免条件歧义。 代码示例： &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;if-elesDemo网页测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"application/javascript\"&gt; var now = new Date(); var dayOfWeek = now.getDay(); if(dayOfWeek&gt;0&amp;&amp;dayOfWeek&lt;6){ alert(\"这是一段测试文字\"); }else{ alert(\"未执行的测试文字\"); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Switch：（完成）语法规范： switch (表达式){ case value1: statements1 // 当表达式的结果等于 value1 时，则执行该代码 break; case value2: statements2 // 当表达式的结果等于 value2 时，则执行该代码 break; ...... case valueN: statementsN // 当表达式的结果等于 valueN 时，则执行该代码 break; default : statements // 如果没有与表达式相同的值，则执行该代码 } switch 语句根据表达式的值，依次与 case 子句中的值进行比较： 如果两者相等，则执行其后的语句段，当遇到 break 关键字时则跳出整个 switch 语句。 如果不相等，则继续匹配下一个 case。 switch 语句包含一个可选的 default 关键字，如果在前面的 case 中没有找到相等的条件，则执行 default 后面的语句段。 **break关键字 ** switch 语句是逐行执行的，当 switch 语句找到一个与之匹配的 case 子句时，不仅会执行该子句对应的代码，还会继续向后执行，直至 switch 语句结束。为了防止这种情况产生，需要在每个 case 子句的末尾使用 break 来跳出 switch 语句。 break 除了可以用来跳出 switch 语句外，还可以用来跳出循环语句（for、for in、while、do while 等） 代码示例： &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;if-elesDemo网页测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=\"application/javascript\"&gt; var now = new Date(); var dayOfWeek = now.getDay(); /* if(dayOfWeek&gt;0&amp;&amp;dayOfWeek&lt;6){ alert(\"这是一段测试文字\"); }else{ alert(\"未执行的测试文字\"); }*/ switch(dayOfWeek){ case 1:alert(\"今天是星期一\");break; case 2:alert(\"今天是星期二\");break case 3:alert(\"今天是星期三\");break; case 4:alert(\"今天是星期四\");break case 5:alert(\"今天是星期五\");break case 6:alert(\"今天是星期六\");break case 7:alert(\"今天是星期日\");break default: alert(\"输出值溢出\");break } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 循环分支：（完成）for / foreach/for of：构造方法： for /* 参数列表： initialization：为一个表达式或者变量声明，我们通常将该步骤称为“初始化计数器变量”，在循环过程中只会执行一次； condition：为一个条件表达式，与 while 循环中的条件表达式功能相同，通常用来与计数器的值进行比较，以确定是否进行循环，通过该表达式可以设置循环的次数； increment：为一个表达式，用来在每次循环结束后更新（递增或递减）计数器的值。 */ for(initialization; condition; increment) { // 要执行的代码 } for-each： for(variable in object){ //要执行的代码 } for-of 代码示例： //for var person = {\"name\": \"Clark\", \"surname\": \"Kent\", \"age\": \"36\"}; for(int i=0;i&lt;person.length;i++){ docunment.write(person[i] + \"\"); } // for-each var person = {\"name\": \"Clark\", \"surname\": \"Kent\", \"age\": \"36\"}; // 遍历对象中的所有属性 for(var prop in person) { document.write(\"&lt;p&gt;\" + prop + \" = \" + person[prop] + \"&lt;/p&gt;\"); } do while/while：语法规范： while(条件表达式){ } do { // 需要执行的代码 } while (条件表达式); while与do while循环区别： while当不满足循环条件便直接退出，do while 循环即使不满足循环条件也执行一次循环体 do while 循环与 while 循环还有一点不同，那就是 do while 循环的末尾需要使用分号;进行结尾，而 while 循环则不需要。 代码示例： &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;功能测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; var i=1; var sum =0; while(i&lt;=100){ sum +=i; i++; } document.write(\"100数之和为\" + sum); /* var i=1; var sum=0; do { sum += i; i++; } while (i &lt;= 100); document.write(\"1 + 2 + 3 + ... + 98 + 99 + 100 = \" + sum) */ &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; JavaScript对象：RegExp类：Number类：与其他编程语言不同，JavaScript中的数字并不区分整数与浮点数，统一使用 IEEE754 标准（二进制浮点数算术标准）的 64 位浮点格式表示数字，能表示的最大值（Number.MAX_VALUE）为 ±1.7976931348623157e+308，最小值（Number.MIN_VALUE）为 ±5e-324。 构造函数 var Num = new NUmber(value) 常用属性： 属性 描述 Number.MAX_VALUE JavaScript 中所能表示的最大值 Number.MIN_VALUE JavaScript 中所能表示的最小值 Number.NaN 非数字 Number.NEGATIVE_INFINITY 负无穷，在溢出时返回 Number.POSITIVE_INFINITY 正无穷，在溢出时返回 Number.EPSILON 表示 1 与 Number 所能表示的大于 1 的最小浮点数之间的差 Number.MIN_SAFE_INTEGER 最小安全整数，即 -9007199254740991 Number.MAX_SAFE_INTEGER 最大安全整数，即 9007199254740991 常用API： 方法 描述 Number.parseFloat() 将字符串转换成浮点数，和全局方法 parseFloat() 作用相同 Number.parseInt() 将字符串转换成整型数字，和全局方法 parseInt() 作用相同 Number.isFinite() 判断 Number 对象是否为有穷数 Number.isInteger() 判断 Number 对象是否为整数 Number.isNaN() 判断 Number 对象是否为 NaN 类型 Number.isSafeInteger() 判断 Number 对象是否为安全整数，即范围为 -(2⁵³ - 1)到 2⁵³ - 1 之间的整数 Number.toString() 把 Number 对象转换为字符串，使用指定的基数 Number.toLocaleString() 把 Number 对象转换为字符串，使用本地数字格式顺序 Number.toFixed() 把 Number 对象转换为字符串，结果的小数点后有指定位数的数字 Number.toExponential() 把 Number 对象的值转换为指数计数法 Number.toPrecision() 把 Number 对象格式化为指定的长度 Number.valueOf() 返回一个 Number 对象的基本数字值 ±Infinity（无穷 ∞）Infinity 是一个特殊的值，表示无穷大。当一个表达式的运算结果超过了 JavaScript 所能表示的数字上限或下限时，JavaScript 就会使用 Infinity 或 -Infinity 表示这个结果，其中 Infinity 表示正无穷大，-Infinity 表示负无穷大。示例代码如下： 代码示例： var a =5/0; var b = -5/0; NaN（非数字）以下几种操作会返回NaN 使用函数无法将参数转换为数字时会返回 NaN，例如 parseInt(“abc”)、new Number(“abc”)； 结果不是实数的数学运算，例如 Math.sqrt(-1)； 任何操作数中包含 NaN 的表达式，例如 5 * NaN； 涉及字符串的非加法运算，且字符串无法自动转换为数字，例如 “foo” / 5。 代码示例： Date类：构造方法： /* 参数列表： milliseconds（毫秒）：若提供一个数值作为参数，则会将这个参数视为一个以毫秒为单位的时间值，并返回自 1970-01-01 00:00:00 起，经过指定毫秒数的时间，例如 new Date(5000) 会返回一个 1970-01-01 00:00:00 经过 5000 毫秒之后的时间； datestring（日期字符串）：若提供一个字符串形式的日期作为参数，则会将其转换为具体的时间，日期的字符串形式有两种，如下所示： YYYY/MM/dd HH:mm:ss（推荐）：若省略时间部分，则返回的 Date 对象的时间为 00:00:00； YYYY-MM-dd HH:mm:ss：若省略时间部分，则返回的 Date 对象的时间为 08:00:00（加上本地时区），若不省略，在 IE 浏览器中会转换失败。 将具体的年月日、时分秒转换为 Date 对象，其中： year：表示年，为了避免错误的产生，推荐使用四位的数字来表示年份； month：表示月，0 代表 1 月，1 代表 2 月，以此类推； date：表示月份中的某一天，1 代表 1 号，2 代表 2 号，以此类推； hour：表示时，以 24 小时制表示，取值范围为 0 ~ 23； minute：表示分，取值范围为 0 ~ 59； second：表示秒，取值范围为 0 ~ 59； millisecond：表示毫秒，取值范围为 0 ~ 999。 */ var time = new Date(); var time = new Date(milliseconds); var time = new Date(datestring); var time = new Date(year, month, date[, hour, minute, second, millisecond]); 常用API： 常用API 释义 getTime()getTimezoneOffset()getUTCDate()getUTCDay()getUTCMonth()getUTCFullYear()getUTCHours()getUTCMinutes()getUTCSeconds()getUTCMilliseconds() 返回 1970 年 1 月 1 日至今的毫秒数返回本地时间与格林威治标准时间 (GMT) 的分钟差根据通用时间从 Date 对象返回月中的一天 (1 ~ 31)根据通用时间从 Date 对象返回周中的一天 (0 ~ 6)根据通用时间从 Date 对象返回月份 (0 ~ 11)根据通用时间从 Date 对象返回四位数的年份根据通用时间返回 Date 对象的小时 (0 ~ 23)根据通用时间返回 Date 对象的分钟 (0 ~ 59)根据通用时间返回 Date 对象的秒钟 (0 ~ 59)根据通用时间返回 Date 对象的毫秒(0 ~ 999) 代码示例： &lt;!DOCTYPE html&gt; Math类：（完成）主要属性： 属性 描述 E 返回算术常量 e，即自然对数的底数（约等于 2.718） LN2 返回 2 的自然对数（约等于 0.693） LN10 返回 10 的自然对数（约等于 2.302） LOG2E 返回以 2 为底的 e 的对数（约等于 1.443） LOG10E 返回以 10 为底的 e 的对数（约等于 0.434） PI 返回圆周率 π（约等于 3.14159） SQRT1_2 返回返回 2 的平方根的倒数（约等于 0.707） SQRT2 返回 2 的平方根（约等于 1.414） 常用API： 常用API 释义 abs(x);acos(x);acosh(x);asin(x);asinh(x);atan(x);atan2h(x);atan2(y,x); cbrt(x); ceil(x); cos(x);cosh(x); exp(x)expm1(x) floor(x);fround(x) hypot([x,[y….]]); imul(x,y) log1p(x);log(x)log10(x); max(x,[y,[…….]]);min(x,[y,[……..]]); pow(x,y); random(x); round(x); sign(x);sin(x);sqrt(x); tan(x);tanh(x); toSource(); trunc(x); valueOf(x); 代码示例： &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Math类功能测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script type =\"application/javascript\"&gt; document.write(Math.E + \"&lt;br&gt;\"); // 输出：2.718281828459045 document.write(Math.LN2 + \"&lt;br&gt;\"); // 输出：0.6931471805599453 document.write(Math.LN10 + \"&lt;br&gt;\"); // 输出：2.302585092994046 document.write(Math.LOG2E + \"&lt;br&gt;\"); // 输出：1.4426950408889634 document.write(Math.LOG10E + \"&lt;br&gt;\"); // 输出：0.4342944819032518 document.write(Math.PI + \"&lt;br&gt;\"); // 输出：3.141592653589793 document.write(Math.SQRT1_2 + \"&lt;br&gt;\"); // 输出：0.7071067811865476 document.write(Math.SQRT2 + \"&lt;br&gt;\"); // 输出：1.4142135623730951 document.write(Math.abs(-3.1415) + \"&lt;br&gt;\"); // 输出：3.1415 document.write(Math.acos(0.5) + \"&lt;br&gt;\"); // 输出：1.0471975511965979 document.write(Math.ceil(1.45) + \"&lt;br&gt;\"); // 输出：2 document.write(Math.exp(1) + \"&lt;br&gt;\"); // 输出：2.718281828459045 document.write(Math.floor(5.99) + \"&lt;br&gt;\"); // 输出：5 document.write(Math.log(6) + \"&lt;br&gt;\"); // 输出：1.791759469228055 document.write(Math.max(4, 8, 1, 9) + \"&lt;br&gt;\"); // 输出：9 document.write(Math.min(4, 8, 1, 9) + \"&lt;br&gt;\"); // 输出：1 document.write(Math.random() + \"&lt;br&gt;\"); // 输出：0.9172594288928195 document.write(Math.pow(2, 3) + \"&lt;br&gt;\"); // 输出：8 document.write(Math.sign(-123) + \"&lt;br&gt;\"); // 输出：-1 document.write(Math.sqrt(125) + \"&lt;br&gt;\"); // 输出：11.180339887498949 &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Array类：（完成）常用属性： 属性 描述 constructor 返回创建数组对象的原型函数 length 设置或返回数组中元素的个数 prototype 通过该属性您可以向对象中添加属性和方法 常用API： 方法 描述 concat() 拼接两个或更多的数组，并返回结果 copyWithin() 从数组的指定位置拷贝元素到数组的另一个指定位置中 entries() 返回数组的可迭代对象 every() 检测数值元素的每个元素是否都符合条件 fill() 使用一个固定值来填充数组 filter() 检测数值元素，并返回符合条件所有元素的数组 find() 返回符合传入函数条件的数组元素 findIndex() 返回符合传入函数条件的数组元素索引 forEach() 数组每个元素都执行一次回调函数 from() 通过给定的对象中创建一个数组 includes() 判断一个数组是否包含一个指定的值 indexOf() 搜索数组中的元素，并返回它所在的位置 isArray() 判断对象是否为数组 join() 把数组的所有元素放入一个字符串 keys() 返回数组的可迭代对象，包含原始数组的键（key） lastIndexOf() 搜索数组中的元素，并返回它最后出现的位置 map() 通过指定函数处理数组的每个元素，并返回处理后的数组 pop() 删除数组的最后一个元素并返回删除的元素 push() 向数组的末尾添加一个或更多元素，并返回数组的长度 reduce() 累加（从左到右）数组中的所有元素，并返回结果 reduceRight() 累加（从右到左）数组中的所有元素，并返回结果 reverse() 反转数组中元素的顺序 shift() 删除并返回数组的第一个元素 slice() 截取数组的一部分，并返回这个新的数组 some() 检测数组元素中是否有元素符合指定条件 sort() 对数组的元素进行排序 splice() 从数组中添加或删除元素 toString() 把数组转换为字符串，并返回结果 unshift() 向数组的开头添加一个或多个元素，并返回新数组的长度 valueOf() 返回数组对象的原始值 代码示例： &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;无标题文档&lt;/title&gt; &lt;body&gt; &lt;script type =\"application/javascript\"&gt; var variation = new Array(\"测试元素1\",\"测试元素2\"); Array.prototype.name =null; variation.name =\"变量名\"; document.write(variation.constructor + \"&lt;br&gt;\"); // 输出：function Array() { [native code] document.write(variation.length + \"&lt;br&gt;\"); //输出：2 document.write(variation.name + \"&lt;br&gt;\"); //输出：变量名 var fruits = [\"Orange\", \"Banana\", \"Apple\", \"Papaya\", \"Mango\"]; document.write(fruits.entries() + \"&lt;br&gt;\"); // 返回：[object Array Iterator] document.write(fruits.includes(\"Apple\") + \"&lt;br&gt;\"); // 返回：true document.write(fruits.fill(\"grape\") + \"&lt;br&gt;\"); // 返回：grape,grape,grape,grape,grape var fruits = [\"Orange\", \"Banana\", \"Apple\", \"Papaya\", \"Mango\"]; document.write(fruits.indexOf(\"Mango\") + \"&lt;br&gt;\"); // 返回：4 document.write(Array.isArray(fruits) + \"&lt;br&gt;\"); // 返回：true document.write(fruits.join(\"-\") + \"&lt;br&gt;\"); // 返回：Orange-Banana-Apple-Papaya-Mango document.write(fruits.lastIndexOf(\"Banana\") + \"&lt;br&gt;\"); // 返回：1 document.write(fruits.pop() + \"&lt;br&gt;\"); // 返回：Mango document.write(fruits.push(\"Watermelon\") + \"&lt;br&gt;\"); // 返回：5 document.write(fruits.unshift(\"Lemon\",\"Pineapple\") + \"&lt;br&gt;\"); // 返回：7 document.write(fruits.slice(1, 5) + \"&lt;br&gt;\"); // 返回：Pineapple,Orange,Banana,Apple document.write(fruits.sort() + \"&lt;br&gt;\"); // 返回：Apple,Banana,Lemon,Orange,Papaya,Pineapple,Watermelon document.write(fruits.valueOf() + \"&lt;br&gt;\"); // 返回：Apple,Banana,Lemon,Orange,Papaya,Pineapple,Watermelon &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Browser对象：Windows对象：（完成）常用属性： 属性 描述 closed 返回窗口是否已被关闭 defaultStatus 设置或返回窗口状态栏中的默认文本 document 对 Document 对象的只读引用 frames 返回窗口中所有已经命名的框架集合，集合由 Window 对象组成，每个 Window 对象在窗口中含有一个 或 标签 history 对 History 对象的只读引用，该对象中包含了用户在浏览器中访问过的 URL innerHeight 返回浏览器窗口的高度，不包含工具栏与滚动条 innerWidth 返回浏览器窗口的宽度，不包含工具栏与滚动条 localStorage 在浏览器中以键值对的形式保存某些数据，保存的数据没有过期时间，会永久保存在浏览器中，直至手动删除 length 返回当前窗口中 框架的数量 location 引用窗口或框架的 Location 对象，该对象中包含当前 URL 的有关信息 name 设置或返回窗口的名称 navigator 对 Navigator 对象的只读引用，该对象中包含当前浏览器的有关信息 opener 返回对创建此窗口的 window 对象的引用 outerHeight 返回浏览器窗口的完整高度，包含工具栏与滚动条 outerWidth 返回浏览器窗口的完整宽度，包含工具栏与滚动条 pageXOffset 设置或返回当前页面相对于浏览器窗口左上角沿水平方向滚动的距离 pageYOffset 设置或返回当前页面相对于浏览器窗口左上角沿垂直方向滚动的距离 parent 返回父窗口 screen 对 Screen 对象的只读引用，该对象中包含计算机屏幕的相关信息 screenLeft 返回浏览器窗口相对于计算机屏幕的 X 坐标 screenTop 返回浏览器窗口相对于计算机屏幕的 Y 坐标 screenX 返回浏览器窗口相对于计算机屏幕的 X 坐标 sessionStorage 在浏览器中以键值对的形式存储一些数据，数据会在关闭浏览器窗口或标签页之后删除 screenY 返回浏览器窗口相对于计算机屏幕的 Y 坐标 self 返回对 window 对象的引用 status 设置窗口状态栏的文本 top 返回最顶层的父窗口 代码示例： &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>JavaScript&lt;/title> &lt;/head> &lt;body> &lt;script type=\"text/javascript\"> window.defaultStatus = \"JavaScript\" document.write(window.defaultStatus + \"&lt;br>\"); // 输出：JavaScript document.write(window.innerHeight + \"&lt;br>\"); // 输出：314 document.write(window.innerWidth + \"&lt;br>\"); // 输出：539 document.write(window.length + \"&lt;br>\"); // 输出：0 document.write(window.location + \"&lt;br>\"); // 输出：file:///F:/code/index.html document.write(window.opener + \"&lt;br>\"); // 输出：null document.write(window.outerHeight + \"&lt;br>\"); // 输出：558 document.write(window.outerWidth + \"&lt;br>\"); // 输出：555 document.write(window.parent + \"&lt;br>\"); // 输出：[object Window] document.write(window.screenLeft + \"&lt;br>\"); // 输出：2263 document.write(window.screenTop + \"&lt;br>\"); // 输出：401 document.write(window.screenX + \"&lt;br>\"); // 输出：2263 document.write(window.screenY + \"&lt;br>\"); // 输出：401 &lt;/script> &lt;/body> &lt;/html> 常用方法： 方法 描述 alert() 在浏览器窗口中弹出一个提示框，提示框中有一个确认按钮 atob() 解码一个 base-64 编码的字符串 btoa() 创建一个 base-64 编码的字符串 blur() 把键盘焦点从顶层窗口移开 clearInterval() 取消由 setInterval() 方法设置的定时器 clearTimeout() 取消由 setTimeout() 方法设置的定时器 close() 关闭某个浏览器窗口 confirm() 在浏览器中弹出一个对话框，对话框带有一个确认按钮和一个取消按钮 createPopup() 创建一个弹出窗口，注意：只有 IE 浏览器支持该方法 focus() 使一个窗口获得焦点 getSelection() 返回一个 Selection 对象，对象中包含用户选中的文本或光标当前的位置 getComputedStyle() 获取指定元素的 CSS 样式 matchMedia() 返回一个 MediaQueryList 对象，表示指定的媒体查询解析后的结果 moveBy() 将浏览器窗口移动指定的像素 moveTo() 将浏览器窗口移动到一个指定的坐标 open() 打开一个新的浏览器窗口或查找一个已命名的窗口 print() 打印当前窗口的内容 prompt() 显示一个可供用户输入的对话框 resizeBy() 按照指定的像素调整窗口的大小，即将窗口的尺寸增加或减少指定的像素 resizeTo() 将窗口的大小调整到指定的宽度和高度 scroll() 已废弃。您可以使用 scrollTo() 方法来替代 scrollBy() 将窗口的内容滚动指定的像素 scrollTo() 将窗口的内容滚动到指定的坐标 setInterval() 创建一个定时器，按照指定的时长（以毫秒计）来不断调用指定的函数或表达式 setTimeout() 创建一个定时器，在经过指定的时长（以毫秒计）后调用指定函数或表达式，只执行一次 stop() 停止页面载入 postMessage() 安全地实现跨源通信 &lt;!DOCTYPE html> &lt;html lang=\"en\"> &lt;head> &lt;meta charset=\"UTF-8\"> &lt;title>JavaScript&lt;/title> &lt;/head> &lt;body> &lt;p id=\"show_tag\">此处显示点击按钮的效果&lt;/p> &lt;button onclick=\"myBtoa()\">btoa()&lt;/button> &lt;button onclick=\"myAtob()\">atob()&lt;/button> &lt;button onclick=\"myAlert()\">alert()&lt;/button> &lt;button onclick=\"myConfirm()\">confirm()&lt;/button> &lt;button onclick=\"myOpen()\">open()&lt;/button> &lt;button onclick=\"myMoveBy()\">moveBy()&lt;/button> &lt;button onclick=\"myMoveTo()\">moveTo()&lt;/button> &lt;button onclick=\"myPrint()\">print()&lt;/button> &lt;button onclick=\"myPrompt()\">prompt()&lt;/button> &lt;button onclick=\"myResizeBy()\">resizeBy()&lt;/button> &lt;button onclick=\"myClose()\">close()&lt;/button> &lt;script type=\"text/javascript\"> var ptag = document.getElementById('show_tag'); var str; function myBtoa()&#123; str = btoa(\"JavaScript\"); ptag.innerHTML = str; &#125; function myAtob()&#123; ptag.innerHTML = typeof str; if(str == undefined)&#123; ptag.innerHTML = \"请先点击 btoa() 按钮\"; return; &#125; ptag.innerHTML = atob(str); &#125; function myAlert()&#123; alert(\"这是一个提示框！\"); &#125; function myConfirm()&#123; var x; var r = confirm(\"按下按钮!\"); if (r == true)&#123; x = \"你按下了\\\"确定\\\"按钮!\"; &#125; else&#123; x = \"你按下了\\\"取消\\\"按钮!\"; &#125; ptag.innerHTML = x; &#125; var myWin; function myOpen()&#123; if(myWin == undefined || (myWin != undefined &amp;&amp; myWin.closed == true))&#123; myWin = window.open('', '', 'width=200,height=100'); &#125;else&#123; return; &#125; &#125; function myMoveBy()&#123; if(myWin == undefined || myWin.closed == true) myOpen(); myWin.moveBy(200, 200); &#125; function myMoveTo()&#123; if(myWin == undefined || myWin.closed == true) myOpen(); myWin.moveTo(0, 0); &#125; function myPrint()&#123; print(); &#125; function myPrompt()&#123; var name = prompt(\"请输入你的名字。\") if (name != null &amp;&amp; name != \"\")&#123; ptag.innerHTML = \"你好 \" + name + \"! 今天感觉如何?\"; &#125; else &#123; ptag.innerHTML = \"你没有输入任何内容\"; &#125; &#125; function myResizeBy()&#123; if(myWin == undefined || myWin.closed == true) myOpen(); myWin.resizeBy(100, 100); &#125; function myClose()&#123; if(myWin == undefined) return; if(myWin != undefined &amp;&amp; myWin.closed == false) myWin.close(); &#125; &lt;/script> &lt;/body> &lt;/html> Navigator对象：（完成）主要用途： Navigator对象中存储与浏览器相关的信息，例如名称、版本。我们可以通过Navigator属性来获取浏览器的基本信息 window对象时一个全局对象，因此可以省略前缀window。例如window.navigator.appName可以简写为navigator.appName。 主要属性： 属性 描述 appCodeName 返回当前浏览器的内部名称（开发代号） appName 返回浏览器的官方名称 appVersion 返回浏览器的平台和版本信息 cookieEnabled 返回浏览器是否启用 cookie，启用返回 true，禁用返回 false onLine 返回浏览器是否联网，联网则返回 true，断网则返回 false platform 返回浏览器运行的操作系统平台 userAgent 返回浏览器的厂商和版本信息，即浏览器运行的操作系统、浏览器的版本、名称 常用API： 方法 描述 javaEnabled() 返回浏览器是否支持运行 Java Applet 小程序，支持则返回 true，不支持则返回 false sendBeacon() 向浏览器异步传输少量数据 代码示例： Screen对象：（完成）主要用途： screen 对象中包含了有关计算机屏幕的信息，例如分辨率、宽度、高度等，我们可以通过 window 对象的 screen 属性来获取它。 由于window对象时全局属性，可以省略。例如windows.screen.height可以简写为screen.height 主要属性： 属性 说明 availTop 返回屏幕上方边界的第一个像素点（大多数情况下返回 0） availLeft 返回屏幕左边边界的第一个像素点（大多数情况下返回 0） availHeight 返回屏幕的高度（不包括 Windows 任务栏） availWidth 返回屏幕的宽度（不包括 Windows 任务栏） colorDepth 返回屏幕的颜色深度（color depth），根据 CSSOM（CSS 对象模型）视图，为兼容起见，该值总为 24。 height 返回屏幕的完整高度 pixelDepth 返回屏幕的位深度/色彩深度（bit depth），根据 CSSOM（CSS 对象模型）视图，为兼容起见，该值总为 24 width 返回屏幕的完整宽度 orientation 返回当前屏幕的方向 代码示例： History对象：（完成）常用属性： 属性 说明 length 返回浏览历史的数目，包含当前已经加载的页面。 scrollRestoration 利用浏览器特性，使我们在返回上一页或者下一页时，将页面滚动到之前浏览的位置，该属性有两个值，分别是 auto（表示滚动）与 manual（表示不滚动）。 state 返回浏览器在当前 URL 下的状态信息，如果没有调用过 pushState() 或 replaceState() 方法，则返回默认值 null。 常用方法： 方法 说明 back() 参照当前页面，返回历史记录中的上一条记录（即返回上一页），您也可以通过点击浏览器工具栏中的←按钮来实现同样的效果。 forward() 参照当前页面，前往历史记录中的下一条记录（即前进到下一页），您也可以通过点击浏览器工具栏中的→按钮来实现同样的效果。 go() 参照当前页面，根据给定参数，打开指定的历史记录，例如 -1 表示返回上一页，1 表示返回下一页。 pushState() 向浏览器的历史记录中插入一条新的历史记录。 replaceState() 使用指定的数据、名称和 URL 来替换当前历史记录。 代码示例： &lt;!doctype html> &lt;html> &lt;head> &lt;meta charset=\"utf-8\"> &lt;title>无标题文档&lt;/title> &lt;/head> &lt;body> &lt;button onclick=\"myBack()\">Back方法测试&lt;/button> &lt;button onclick=\"myForward()\">forward方法测试&lt;/button> &lt;button onclick=\"myGo()\">go方法测试&lt;/button> &lt;button onclick=\"myPushState()\">pushState方法测试&lt;/button> &lt;button onclick=\"myReplaceState()\">replaceState方法测试&lt;/button> &lt;script type=\"application/javascript\"> function myBack()&#123; history.back(); &#125; function myForward()&#123; history.forward(); &#125; function myGo()&#123; var num = prompt('请输入一个整数', '1'); history.go(num); &#125; function myPushState()&#123; var state = &#123; 'page_id': 1, 'user_id': 5 &#125; var title = 'JavaScript' var url = 'index.html' history.pushState(state, title, url) console.log(history.state); &#125; function myReplaceState()&#123; var state = &#123; 'page_id': 3, 'user_id': 5 &#125; var title = 'history' var url = 'index.html' history.replaceState(state, title, url) console.log(history.state); &#125; &lt;/script> &lt;/body> &lt;/html> Location对象：（完成）常用属性： 属性 描述 hash 返回一个 URL 中锚的部分，例如：http://c.biancheng.net#js 中的 #js。 host 返回一个 URL 的主机名和端口号，例如 http://c.biancheng.net:8080。 hostname 返回一个 URL 的主机名，例如 http://c.biancheng.net。 href 返回一个完整的 URL，例如 http://c.biancheng.net/javascript/location-object.html。 pathname 返回一个 URL 中的路径部分，开头有个/。 port 返回一个 URL 中的端口号，如果 URL 中不包含明确的端口号，则返回一个空字符串&#39; &#39;。 protocol 返回一个 URL 协议，即 URL 中冒号:及其之前的部分，例如 http: 和 https:。 search 返回一个 URL 中的查询部分，即 URL 中?及其之后的一系列查询参数。 常用API： 方法 说明 assign() 加载指定的 URL，即载入指定的文档。 reload() 重新加载当前 URL。 replace() 用指定 URL 替换当前的文档，与 assign() 方法不同的是，使用 replace() 替换的新页面不会保存在浏览历史中，用户不能使用后退来返回该页面。 toString() 与 href 属性的效果相同，以字符串的形式返回当前完整的 URL。 代码示例： DOM对象：HTML DOM documentHTML DOM 元素对象HTML DOM 属性对象HTML DOM 事件对象HTML DOM对象：GUI辅助动作功能：OnClick：","categories":[{"name":"前端编程语言","slug":"前端编程语言","permalink":"http://www.luckyzmj.cn/categories/%E5%89%8D%E7%AB%AF%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"前端三件套","slug":"前端三件套","permalink":"http://www.luckyzmj.cn/tags/%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.luckyzmj.cn/tags/JavaScript/"}]},{"title":"C# WinForm图形化界面","slug":"后端编程语言/C# WinForm图形化界面","date":"2022-06-25T10:38:51.000Z","updated":"2022-07-01T04:18:52.396Z","comments":true,"path":"posts/5deb9601.html","link":"","permalink":"http://www.luckyzmj.cn/posts/5deb9601.html","excerpt":"","text":"C# GUI图形化编程 GUI自动生成功能： App.config 应用配置 Form1.cs 源码文件(窗口) Form1.Designer.cs 源码文件(界面设计)业务逻辑 Form.resx 资源文件 Program.cs 源码文件(Main方法)由系统自动生成 类的拆分： Form1：Form1.cs业务代码+Form.Designer.cs界面代码，自动生成（一般不需要手工修改） 自定义窗口： 删除默认创建的整个form1.cs选中项目-右击-添加【类】选中【Visual C#-类 】，并进行命名（删除默认创建的整个form1.cs选中项目-右击-添加【类】选中【Visual C#-类 】，并进行命名修改Form1.cs与Program.cs中的代码这里MyForm命名） using System.Windows.Forms; namespace Form_1 { /*新建一个自定义窗口——MyForm*/ class MyForm: Form//MyForm继承Form，使用Alt+Enter将“using System.Windows.Forms;”填充到上方 { public MyForm()//构造MyForm方法 { this.Text = \"我的小窗口\";//设置窗口标题 } } } 2. Program.cs namespace Form_1 { static class Program { static void Main() { MyForm form = new MyForm(); Application.Run(form);//启动消息循环 }//或者也可以写成： MyForm form; Application.Run(new MyForm()); } } 手动添加控件和事件处理机制： public Form(){ InitializeComponent(); Button button = new Button(); button.Click += new EventHandler(this.Ontext); //在Form中添加回调方法 public void Ontext(object sender,EventArgs e){ MessageBox.Show(\"按钮被点击了\"); } } 语言特性： 微软于2000年推出C#语言，继承java、C++语言特性优点的同时，在微软推动下进入最受欢迎的编程语言前五名。 在桌面软件开发市场上独居一角，Visual Studio便捷的图形化编程工具和集成常用控件使得C#在桌面软件开发市场脱颖而出。 控件：(Component)公共类控件：(public Component)文本类控件：(Text)Label/LinkedLabel（标签）/（超链接标签）：（完成）构造方法： Label(); 主要属性 属性名 作用 void Name 标签对象的名称，区别不同标签唯一标志 void Text 标签对象上显示的文本 void Font 标签中显示文本的样式 void ForeColor 标签中显示文本的颜色 void BackColor 标签的背景颜色 void Image 标签中显示的图片 void AutoSize 标签的大小是否根据内容自动调整，True 为自动调整，False 为用户自定义大小 void Size 指定标签控件的大小 void Visible 标签是否可见，True 为可见，False 为不可见 继承属性：Visible\\ ForeColor\\ Font 1. Text：设置或返回标签控件中显示文本信息 2. AutoSize： 3. 4. BorderStyle：设置或返回边框 BorderStyle.None 无边框（默认） BorderStyle.FixedSingle 固定单边框 BorderStyle.Fixed3D 3维边框 5. TabIndex：设置或返回对象Tab键顺序 代码实例 Label label = new Label(); label.Text = \"这是一段显示文字\"; 实战练习： using System; using System.Windows.Forms; namespace demo{ public partial class Form1:Form{ public Form1(){ InitialComponent(); } } } ToolTip（文本提示信息）代码示例： toolTip1.IsBalloon =true; toolTip1.SetToolTip(this.button1,\"这是一则提示信息\"); TextBox（文本框）：常用API 属性名 作用 void Text 文本框对象中显示的文本 void MaxLength 在文本框中最多输入的文本的字符个数 bool WordWrap 文本框中的文本是否自动换行，如果是 True，则自动换行，如果是 False，则不能自动换行 void PasswordChar 将文本框中出现的字符使用指定的字符替换，通常会使用“*”字符 void Multiline 指定文本框是否为多行文本框，如果为 True，则为多行文本框，如果 为 False，则为单行文本框 void ReadOnly 指定文本框中的文本是否可以更改，如果为 True，则不能更改，即只读文本框，如果为 False，则允许更改文本框中的文本 void Lines 指定文本框中文本的行数 void ScrollBars 指定文本框中是否有滚动条，如果为 True，则有滚动条,如果为 False， 则没有滚动条 代码示例：（用户登录） public partial class TextBoxTest : Form { public TextBoxTest() { InitializeComponent(); } //文本框文本改变事件 private void textBox1_TextChanged(object sender, EventArgs e) { //将文本框中的文本值显示在标签中 label2.Text = textBox1.Text; } } //========================LoginPanel======================== public partial class LoginForm : Form { public LoginForm() { InitializeComponent(); } //判断是否登录成功 private void linkLabel1_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e) { //获取用户名 string username = textBox1.Text; //获取密码 string password = textBox2.Text; //判断用户名密码是否正确 if (\"xiaoming\".Equals(username) &amp;&amp; \"123456\".Equals(password)) { MessageBox.Show(\"登录成功！\"); } else { MessageBox.Show(\"登录失败！\"); } } } RichTextBox（格式文本）：构造函数： 常用API： 常用API 释义 ProgressBar（进度条）：构造方法： 主要属性 常用API 释义 Minmum 指定ProgressBar操作范围的下界 Maxmum 指定ProgressBar操作范围的上界 Value 获取在最大值和最小值属性 Step 指定在调用PerformStep方法事件控件的当前值的地递增量 代码示例： 按钮类控件：(Button)Button（按钮）：构造方法： 主要属性 常用API 释义 void Name //按钮对象的识别名称 void Text //按钮显示文字 void TextAlign //按钮表面文字显示位置 void FlatStyle //按钮外观 void Visible //按钮显示还是隐藏 void Image //按钮表面显示图标 void ImageAlign //按钮表面显示图标的位置 主要事件 Button button = new Button(); button.Click+= new EventHandler(this.DemoMethod);（Click为备选事件名） public void DemoMethod_Click(object sender,EventArgs e){ MessageBox.Show(\"弹出按钮显示文字框\"); } 1. Click事件：左键单击单击按钮控件触发 2. MouseDown事件：在按钮控件上按下鼠标按钮触发 3. MouseUp事件：释放鼠标按钮时触发 代码示例： using System; using System.Windows.Forms; namespace demo{ public partial class Register:Form{ public Register(){ InitializeComponent(); } //“确定”按钮的单击事件，用于判断注册信息并跳转到新窗口显示注册信息 private void button1_Click(object sender, EventArgs e) { string name = textBox1.Text; string pwd = textBox2.Text; string repwd = textBox3.Text; if (string.IsNullOrEmpty(name)) { MessageBox.Show(\"用户名不能为空！\"); return; } else if (string.IsNullOrEmpty(textBox2.Text)) { MessageBox.Show(\"密码不能为空！\"); return; } else if (!textBox2.Text.Equals(textBox3.Text)) { MessageBox.Show(\"两次输入的密码不一致！\"); return; } //将用户名和密码传递到主窗体中 MainForm mainForm = new MainForm(name, pwd); mainForm.Show(); } //“取消”按钮的事件，用于关闭窗体 private void button2_Click(object sender, EventArgs e) { //关闭窗体 this.Close(); } } //==========================MainForm============================= using System; using System.Windows.Forms; namespace demo{ public partial class MainForm:Form{ public MainForm(string name,string pwd){ InitializeComponent(); label.Text =\"用户名\" + name; label2.Text =\"密码\" + pwd; } } } RadioButton（单选按钮）构造方法 主要属性 常用API 释义 bool Checked 判断控件是否被选中 Appearance 获取或设置一个值，该值用于确定 RadioButton 的外观。如果 Appearance 值设置为 Normal，则在绘制 RadioButton 控件时使用圆形复选框。 若该值设置为 Button，则将 RadioButton 绘制成一个可切换为向上或向下状态的控件。 每种类型都可显示文本或图像，或同时显示两者。 TabStop 获取或设置一个值，该值指示用户能否使用 Tab 键将焦点放到该控件上。 Tag 获取或设置包含有关控件的数据的对象。 常用事件： 常用事件 释义 Click 当单击单选按钮，将把单选按钮的Checked属性值设置为true，同时发生Click事件。 代码示例： using System; using System.Windows.Forms; namespace demo{ public partial class RadioButtonDemo:Form{ public RadioButtonDemo(){ InitializeComponent(); } private void Form_Load(object sender,EventArgs e){ //设置两个单选按钮的的Checked属性为false radioButton1.Checked = false; radioButton2.Checked = false; } private void radioButton2_Click(object sender, EventArgs e){ //控件的Click事件中通过if语句判断控件的Checked属性的返回值是否为True if (radioButton2.Checked == true) { MessageBox.Show(\"RadioButton2控件被选中\"); } } private void radioButton1_Click(object sender, EventArgs e){ //控件的Click事件中通过if语句判断控件的Checked属性的返回值是否为True if (radioButton1.Checked == true) { MessageBox.Show(\"RadioButton1控件被选中\"); } } GroupButton（按钮组）DropDownButton（构造方法： 常用API： 常用API 释义 Display 指示是否显示图像和文本 bool DoubleClickEnabled 指示是否出现双击事件 void DropDownItems 指示当单击对象时显示的ToolStripItems 选择类控件：(Choice)ComboBox（下拉组合框）：（完成）ComboBox(); 常用API： 属性名 作用 void DropDownStyle 获取或设置组合框的外观，如果值为 Simple，同时显示文本框和列表框，并且文本框可以编辑；如果值为 DropDown，则只显示文本框，通过鼠标或键盘的单击事件展开文本框，并且文本框可以编辑；如果值为 DropDownList，显示效果与 DropDown 值一样，但文本框不可编辑。默认情况下为 DropDown Items 获取或设置组合框中的值 void Text 获取或设置组合框中显示的文本 void MaxDropDownltems 获取或设置组合框中最多显示的项数 bool Sorted 指定是否对组合框列表中的项进行排序，如果值为 True，则排序， 如果值为 False，则不排序。默认情况下为 False 代码示例： using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Threading.Tasks; using System.Windows.Forms; namespace Form1Demo { public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void comboBox1_SelectedIndexChanged(object sender, EventArgs e) { MessageBox.Show(\"您选择的专业是：\" + comboBox1.Text, \"提示\"); } private void Form1_Load(object sender, EventArgs e) { comboBox1.Items.Add(\"计算机应用\"); comboBox1.Items.Add(\"英语\"); comboBox1.Items.Add(\"会计\"); comboBox1.Items.Add(\"软件工程\"); comboBox1.Items.Add(\"网络工程\"); } private void button2_Click(object sender, EventArgs e) { //判断文本框是否为空 if (textBox1.Text != \"\") { //判断组合框中是否存在文本框中输入的值 if (comboBox1.Items.Contains(textBox1.Text)) { comboBox1.Items.Remove(textBox1.Text); } else { MessageBox.Show(\"您输入的专业不存在\", \"提示\"); } } else { MessageBox.Show(\"请输入要删除的专业\", \"提示\"); } } private void button1_Click(object sender, EventArgs e) { //判断文本框中是否为空，不为空则将其添加到组合框中 if (textBox1.Text != \"\") { //判断文本框中的值是否与组合框中的的值重复 if (comboBox1.Items.Contains(textBox1.Text)) { MessageBox.Show(\"该专业已存在！\"); } else { comboBox1.Items.Add(textBox1.Text); } } else { MessageBox.Show(\"请输入专业！\", \"提示\"); } } } } CheckBox/CheckedListBox（复选框）：构造方法： 主要属性 常用API 释义 void Name 设置组件名称 void Text 设置组件显示文字 bool Checked 表示组件是否被选中 代码示例： public partial class CheckBoxForm : Form { public CheckBoxForm() { InitializeComponent(); } private void button1_Click(object sender,EventArgs e){ string context=\"\"; } } 常用事件 与RadioButton一致 列表类控件 ListBox（列表框）：（完成）构造方法： 常用API： 属性名 作用 string MultiColumn 获取或设置列表框是否支持多列，如果设置为 True，则表示支持多列； 如果设置为 False，则表示不支持多列，默认为 False string Items 获取或设置列表框控件中的值 string SelectedItems 获取列表框中所有选中项的集合 string SelectedItem 获取列表框中当前选中的项 string SelectedIndex 获取列表框中当前选中项的索引，索引从 0 开始 string SelectionMode 获取或设置列表框中选择的模式，当值为 One 时，代表只能选中一项， 当值为 MultiSimple 时，代表能选择多项，当值为 None 时，代表不能选 择，当值为 MultiExtended 时，代表能选择多项，但要在按下 Shift 键后 再选择列表框中的项 代码示例： public partial class ListBoxForm : Form { public ListBoxForm() { InitializeComponent(); } private void button_Click(object sender,EventArgs e){ string msg =\"\"; for(int i=0;i&lt;listBox1.SelectedItems.Count;i++){ msg = msg + \" \" + listBox1.SelectedItems[i].ToString(); } if (msg != \"\") { MessageBox.Show(\"您选择的爱好是：\" + msg, \"提示\"); } else { MessageBox.Show(\"您没有选择爱好\", \"提示\"); } } //将列表框中的选中项删除 private void button2_Click(object sender, EventArgs e) { //由于列表框控件中允许多选所以需要循环删除所有已选项 int count = listBox1.SelectedItems.Count; List&lt;string&gt; itemValues = new List&lt;string&gt;(); if (count != 0) { for(int i = 0; i &lt; count; i++) { itemValues.Add(listBox1.SelectedItems[i].ToString()); } foreach(string item in itemValues) { listBox1.Items.Remove(item); } } else { MessageBox.Show(\"请选择需要删除的爱好！\"); } } //将文本框中的值添加到列表框中 private void button3_Click(object sender, EventArgs e) { //当文本框中的值不为空时将其添加到列表框中 if (textBox1.Text != \"\") { listBox1.Items.Add(textBox1.Text); } else { MessageBox.Show(\"请添加爱好！\"); } } } } } ListView（列表视图）（完成）构造函数： 常用API： 常用API与属性 释义 FullRowSelect 设置是否行选择模式（默认为false），只有在Details视图该属性才有意义 GridLines 设置行与列之间是否显示网格线（默认为false），只有在Details视图下该属性才有意义 AllowColumnRecorder 设置是否可拖动列表头来改变列的顺序（默认为false）提示：只有在Detail视图下该属性才有意义。 View //获取或设置项在控件中的显示方式，包括Details、LargeIcon、List、SmallIcon、Tile（默认为 LargeIcon） MultiSelect 设置是否可以选择多个项（默认为false） LabelEdit //设置用户是否可以编辑控件中项的标签 CheckBoxes //设置控件中各项的旁边是否显示复选框（默认为false） LargeImageListSmallImageListStateImageList //大图标集//小图标集//图像蒙版，可用作LargeImageList和SmallImageList的覆盖图，这些图像可用于指示项的应用程序定义的状态。 SelectedItemsCheckedItesms //获取在控件中选定的项//获取控件中当前复选框选中的项 Sorting：可选值:* Ascending：递增顺序排序* Descending：递减顺序排序 对列表视图的项进行排序（默认为None） HoverSelectionHideSelection 设置但鼠标指针悬停于项上时是否自动选择项设置选定项时在控件没焦点时是否扔突出显示 HotTracking 设置当前鼠标指针经过项文本时，其外观是否变为超链接形式 Groups 设置分组的对象集合 BeginUpdateEndUpdate 避免在调用EndUpdate方法之前描述控件，当插入大量数据时，可以有效地避免控件闪烁，大大提高速度 EnsureVisible 列表视图滚动定位到指定索引项的选项行 FindItemWithText //查找以给定文本值开头的第一个ListViewItem FindNearestItem 按照指定的搜索方向，从给定节点开始查找下一个项。只有在LargeIcon或SmallIcon视图下才能使用该方法 常用事件： 常用事件 释义 AfterLabelEdit 当用户编辑玩项的标签时发生，需要LabelEdit属性为true BeforeLabelEdit 当用户开始编辑项的标签时发生 ColumnClick 当用户在列表视图控件中单击列表头时发生， 列表五种视图： LargeIcon：每个项都显示为一个最大化图标，在它的下面有一个标签。（效果见下图） SmallIcon：每个项都显示为一个小图标，在它的右边带一个标签。（效果见下图） List：每个项都显示为一个小图标，在它的右边带一个标签。各项排列在列中，没有列标头。（效果见下图） Details：可以显示任意的列，但只有第一列可以包含一个小图标和标签，其它的列项只能显示文字信息，有列表头。（效果见下图） Tile：每个项都显示为一个完整大小的图标，在它的右边带项标签和子项信息。（只有Windows XP 和 Windows Server 2003 系列支持） 代码示例： 状态栏控件：(Strip)ContextMenuStrip（快捷菜单）（完成）最常见的用途： 作为托盘图标右键提示的菜单，显示可执行的内容 作为文本框右键菜单选项 构造函数： ContextMenuStrip(); //代码示例 ContextMenuStrip strip = new ContextMenuStrip(); 主要属性： 属性 释义 SourceControl 设置该右键菜单的控件 Item 子菜单集合，子菜单项也可多层次 代码示例 using System; using System.WinForm namespace ContextMenuStripDemo:Form{ public partial class ContextMenuStripDemo:Form{ public ContextMenuStripDemo(){ InitializeComponent(); } #region 隐藏任务栏图标、显示托盘图标 private void Form1_SizeChanged(object sender,EventArgs e) { if(WindowState == FormWindowState.Minimized) { notifyIcon1.Icon = Icon; this.ShowInTaskbar = false; notifyIcon1.Visible = true; } } #endregion #region 还原窗体 private void notifyIcon1_DoubleClick(object sender,EventArgs e) { if (WindowState == FormWindowState.Normal) { WindowState = FormWindowState.Normal; this.Activate(); this.ShowInTaskbar = true; notifyIcon1.Visible = true; } } } } MenuStrip（菜单栏）：（完成）主要属性 主要属性 释义 MidWindowListItem 用于获取或设置显示MDI子窗体列表中的ToolStripMenuItem ShowItemToolStrip 用于或设置一个值，该值指示MenuStrip是否支持溢出功能 ShortcutKeys 获取或设置与ToolStripMenuItem关联的快捷键 ShowShortcutKeys 获取或设置一个值，指示ToolStripMenuItem关联的快捷键是否显示在ToolStripMenuItem旁边 DefaultItem 用来获取设置一个值，指示菜单项是否为默认菜单项。 常用事件 Click事件：用户单击菜单项时发生 代码示例： ScrollBar（拖动条）：（完成）构造方法： ScrollBars属性的属性值及说明 属性值 说明 Both 只有当文本超过控件的宽度或长度时，才显示水平滚动条或垂直滚动条，或两个滚动条都显示 None 从不显示任何类型的滚动条 Horizontal 只有当文本超过控件的宽度时，才显示水平滚动条。必须将WordWrap属性设置为false，才会出现这种情况 Vertical 只有当文本超过控件的高度时，才显示垂直滚动条 ForcedHorizontal 当WordWrap属性设置为false时，显示水平滚动条。在文本未超过控件的宽度时，该滚动条显示为浅灰色 ForcedVertical 始终显示垂直滚动条。在文本未超过控件的长度时，该滚动条显示为浅灰色 ForcedBoth 始终显示垂直滚动条。当WordWrap属性设置为false时，显示水平滚动条。在文本未超过控件的宽度或长度时，两个滚动条均显示为灰色 代码示例： using System; using System.Windows.Froms; namespace ScrollBarDemo{ public partial class ScrollBarDemo:Form{ public ScrollBarDemo(){ InitializeComponent(); } } } StatusStrip（状态栏）：（完成）用于在界面中给用户一些提示，例如登录到一个系统后，在状态栏上显示登录人的用户名、系统时间等信息，软件底部显示一些信息。 构造方法： 常用属性 常用属性 释义 Name 获取或设置控件的名称 TextDirection 获取或设置在ToolStrip上绘制文本的方向 Item 枚举型含有多个方法如下文所示 Item：枚举型 属性 释义 ToolStripStatusLabel* Name* Text* BorderSlides 表示StatusStrip控件中的一个面板* 获取或设置项的名称* 获取或设置要显示在项上的文字* 获取设置一个值，指示ToolStripStatusLabel的哪些边显示边框 ToolStripDropDownButton 表示单击时显示关联的 ToolStripDropDown 的控件，用户可从该下拉控件中选择一项。 ToolStripSplitButton 表示左侧标准按钮和右侧下拉按钮的组合，如果 RightToLeft 的值为 Yes，则这两个按钮位置互换。 ToolStripProgressBar 表示 StatusStrip 中包含的 Windows 进度栏控件。 代码示例： using System; using System.WinForms.Forms; namespace ToolStripDemo:Form{ public partial class ToolStripDemo:Form{ public ToolStripDemo(){ InitializeComponent(); } private void Form1_Load(object sender,EventArgs e){ DateTime dt = DateTime.Now; string str = \"启动时间：\" + dt.Date.ToString(\"yyyy/mm/dd\") + \" \" + dt.Hour.ToString() + \":\" + dt.Minute.ToString() + \":\" + dt.Second.ToString(); toolStripStatusLabel1.Text = str; } } } ToolStrip（工具栏）：（完成）构造方法： 主要属性： 属性 说明 ImageScalingSize 工具栏中的项显示的图像的大小 Items 在工具栏上显示的项的集合 工具栏项的主要属性和事件 属性 说明 DisplayStyle 说明图像和文本的显示方式 Image 按钮标签上显示的图片 ImageScaling 是否调整按钮标签上显示的图片大小 Text 按钮/标题上显示的文本 TextImageRelation 按钮/标题上图像与文本的相对位置 工具栏控件8个样式： 控件名称 命名规范 释义 Button tsbtn //工具栏中按钮 Label tslbl //工具栏中标题 SplitButton tssb //工具栏中分割按钮 DropDownButton tsddb //工具栏中下拉按钮 Separator tss //工具栏中分割线 ComboBox tscbo //下拉框 TestBox tsbtxt //文本框 ProgressBar tspb //工具栏中进度条 通过DisplayStyle修改控件显示属性： 控件 释义 None 不显示 Text 显示文本 Image 显示图片 ImageAndText 显示文本和图片 事件：Click：单击按钮标题时，触发该事件。 代码示例： TreeView（树组件）：（完成）构造方法： 常用API： 常用API 释义 string Index //获取树节点在树节点集合中的位置 string Nodes //获取分配给树视图控件的树节点集合 string Parent //获取或设置控件的父容器 string SelectedNode //获取当前树视图控件中选定的树节点 void ExpandAll 展开所有树节点 bool Checked 指示树节点是否处于选中状态 void Text 获取或设置树节点标签显示的文本 void Clear 清空树 void Remove //从树视图组件中移除当前树节点 代码示例： using System; using System.IO; using System.Text; using System.Windows.Forms; namespace Form1 { public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void button1_Click(object sender, EventArgs e) { TreeNode treeNode = new TreeNode(textBox1.Text, 2, 2); treeView1.Nodes.Add(treeNode); treeView1.Select(); } private void treeView1_AfterSelect(object sender, TreeViewEventArgs e) { } private void button2_Click(object sender, EventArgs e) { TreeNode selectdnode = treeView1.SelectedNode; if (selectdnode != null) { TreeNode chnode = new TreeNode(textBox2.Text, 2, 2); selectdnode.Nodes.Add(chnode); selectdnode.Expand(); treeView1.Select(); } else { MessageBox.Show(\"请选择需要添加子节点\"); } } private void button3_Click(object sender, EventArgs e) { TreeNode selectnode = treeView1.SelectedNode; TreeNode parentnode = selectnode.Parent; if (parentnode == null) { treeView1.Nodes.Remove(selectnode); } else { parentnode.Nodes.Remove(selectnode); } treeView1.Select(); } private void button4_Click(object sender, EventArgs e) { treeView1.Nodes.Clear(); } private void button5_Click(object sender, EventArgs e) { this.textBox1.Clear(); this.textBox2.Clear(); } } Timer（计时器）（完成）主要作用是按一定时间间隔周期性触发一个名为Tick的事件，因此在该事件的代码中可以放置一些需要每隔一段时间重复执行的程序段。在程序运行时，定时器控件是不可见的。 构造方法： 常用API 常用API/属性 释义 Enabled 用来设置定时器是否正在运行。值为 true 时，定时器正在运行，值为 false 时，定时器不在运行。 Interval 用来设置定时器两次Tick事件发生的时间间隔，以毫秒为单位。如它的值设置为500，则将每隔0.5秒发生一个Tick事件。 Start();Stop 用来启动的定时器/用来停止计时器 Tick：每隔Interval时间后将触发一次该事件。 代码示例： 绘图控件：(Graphics)Graphics（图像绘制）SolidBrush（实心笔刷）HatchBrush（阴影笔刷）LineGradientBrush（渐变笔刷）C#特有控件：（private Component）数值选择：NumericUpDown（待证明）主要属性 常用API 释义 DecimalPlaces //获取或设置控件中显示的小数位数 Haxadecimal //获取或设置一个值，该值指示该控件是否以十六进制格式显示所包含的值 Increment //获取或设置单击向上或向下按钮时，该控件递增或递减的值 MaximumMinimum //获取或设置该控件最大值、最小值 Value //获取或设置控件当前值 代码示例： 图片选择：PictureBox（完成）常用属性 属性名 作用 Image 获取或设置图片控件中显示的图片 ImageLocation 获取或设置图片控件中显示图片的路径 SizeMode 枚举值，表示图片大小的显示模式 SizeMode枚举值型 释义 Normal 表示图像被置于空间左上角，如果图片比图片控件大，则图像将被剪切； AutoSize 自动调整图片框大小，使其等于所包含的图像大小； CenterImage 表示如果图片框比图片大，则剧中显示，如果图片比图片框大则剪切边沿； StretchIamge 表示将图片框中的图像拉伸或收缩，以适合图片框的大小； zoom 表示图像大小按其原有的大小比例缩放。 代码示例 public partial class PictureBoxFormDemo:Form{ public PictureBoxFormBoxDemo(){ InitialComponent(); } private void PictureBoxFormDemo_Load(object sender,EventArgs e){ } private void button1_Click(object sender,EventArgs e){ } } 滑块控件：TrackBar（完成）构造方法： 常用API： 常用API 释义 MaximumMinimum //用来获取或设置TrackBar控件可表示的范围上限，最大值（最小值 Orientation //用来获取或设置一个值，指示跟踪条是水平方向还是垂直方向 LargeChangeSmallChange //获取或设置一个值，指示当滑块长距离移动时应为Value属性中加上或减去的值。 Value TickFrequency TickStyle //用来获取或设置一个值，该值指示如何显示跟踪条上的刻度线。该属性的取值及含义如表9-12 所示。 常用事件： ValueChanged：该事件在TrackBar控件的Value属性值改变时发生。 浏览器控件：WebBroswer（完成） 常用API： 常用API 释义 GoBackGoForwardGoHomeGoSearch //使你在当前历史列表中后退一项//使你在当前历史列表中前进一项//相当于主页按钮，连接用户默认主页//相当于搜索按钮，连接用户默认的搜索页面 Navigate 连接到指定的URL RefreshRefresh2 刷新当前页面可以指定刷新级别，枚举值下方展开具体叙述 Refresh2枚举值 释义 REFRESH_NORMAL 执行简单的刷新，不将**HTTP pragma: no-cache头发送给服务器 REFRESH_IFEXPIRED 只有在网页过期后才进行简单的刷新 REFRESH_CONTINUE 仅作内部使用。在**MSDN里写着DO NOT USE! 请勿使用 REFRESH_COMPLETELY 将包含**pragma: no-cache头的请求发送到服务器 Stop 相当于**IE的“停止”按钮，停止当前页面及其内容的载入 常用属性： 属性值 释义 Application 该对象有效，则返回掌管**WebBrowser控件的应用程序实现的自动化对象(IDispatch)。如果在宿主对象中自动化对象无效，这个程序将返回WebBrowser控件的自动化对象 Parent 返回**WebBrowser控件的父自动化对象，通常是一个容器，例如是宿主或IE窗口 Container 返回**WebBrowser控件容器的自动化对象。通常该值与Parent属性返回的值相同 TopLevelContainer 返回一个**Boolean值，表明IE是否是WebBrowser控件顶层容器，是就返回true Type 返回已被**WebBrowser控件加载的对象的类型。例如：如果加载.doc文件，就会返回Microsoft Word Document LeftTopWidthHeight //返回或设置**WebBrowser控件窗口的内部左边与容器窗口左边的距离//返回或设置**WebBrowser控件窗口的内部左边与容器窗口顶边的距离宽度与高度，以像素为单位 LocationName 返回一个字符串，该字符串包含着**WebBrowser当前显示的资源的名称，如果资源是网页就是网页的标题；如果是文件或文件夹，就是文件或文件夹的名称 LocationURL 返回**WebBrowser当前正在显示的资源的URL Busy 返回一个Boolean值，说明WebBrowser当前是否正在加载URL，如果返回true就可以使用stop方法来撤销正在执行的访问操作 常用事件： 事件名 释义 BeforeNavigate2 导航发生前激发，刷新时不激发 CommandStateChange 当命令的激活状态改变时激发。它表明何时激活或关闭**Back和Forward菜单项或按钮 DocumentCompleted 当整个文档完成时激发，刷新页面不激发 DownloadBeginDownloadCompleted 当某项下载操作已经开始后激发，刷新也可激发此事件当某项下载操作已经完成后激发，刷新也可激发此事件 NavigateCompleted2 导航完成后激发，刷新时不激发 NewWindow2 在创建新窗口以前激发 OnFullScreenOnMenuBarOnQuitOnStatusBarOnToolBar 当**FullScreen属性改变时激发。该事件采用VARIENT_BOOL的一个输 入参数来指示IE是全屏显示方式(VARIENT_TRUE)还是普通显示方式(VARIENT_FALSE)改变**MenuBar的属性时激发，标示参数是VARIENT_BOOL类型的。 VARIANT_TRUE是可见，VARIANT_ FALSE是隐藏无论是用户关闭浏览器还是开发者调用**Quit方法，当IE退出时就会激发OnMenuBar调用方法相同，标示状态栏是否可见。调用方法同上，标示工具栏是否可见。 StatusTextChange 如果要改变状态栏中的文字，这个事件就会被激发，但它并不理会程序是否有状态栏 TitleChange Title 有效或改变时激发 代码示例： 日期时间控件：DateTimePicker（完成）构造方法： 常用API： 表1 DateTimePickerFormat枚举值及说明 枚举值 说明 Custom DateTimePicker控件以自定义格式显示日期/时间值 Long DateTimePicker控件以用户操作系统设置的长日期格式显示日期/时间值 Short DateTimePicker控件以用户操作系统设置的短日期格式显示日期/时间值 Time DateTimePicker控件以用户操作系统设置的时间格式显示日期/时间值 使用DateTimePicker控件以自定义格式显示日期： 需要用到其CustomFormat，其语法格式为 public string CustomFormat{get,set}; 表2 有效日期格式字符串及其说明 格式字符串 说明 D 一位数或两位数的天数 Dd 两位数的天数，一位数天数的前面加一个零 Ddd 3个字符的星期几缩写 Dddd 完整的星期几名称 H 12小时格式的一位数或两位数小时数 Hh 12小时格式的两位数小时数，一位数数值前面加一个0 H 24小时格式的一位数或两位数小时数 HH 24小时格式的两位数小时数，一位数数值前面加一个0 M 一位数或两位数分钟值 Mm 两位数分钟值，一位数数值前面加一个0 M 一位数或两位数月份值 MM 两位数月份值。一位数数值前面加一个0 MMM 3个字符的月份缩写 MMMM 完整的月份名 S 一位数或两位数秒数 Ss 两位数秒数。一位数数值前面加一个 T 单字母A.M./P.M缩写（A.M将显示为“A”） Tt 两字母A.M./P.M缩写（A.M.将显示为“AM”） Y 一位数的年份（2001 显示为“1”） Yy 年份的最后两位数（2001 显示为“01”） Yyyy 完整的年份（2001 显示为“2001”） 代码示例： using System; using System.Windows.Forms; namespace demo{ public partial class Demo:Form{ public Demo(){ InitialComponent(); } } } 日历控件：MonthCalendar（完成）构造方法： Calendar(); //代码示例 Calendar calendar = new Calendar(); 常用API： monthCalendar 控件主要的属性如表 2-13 所示： 属性 说明 Backcolor 月份中显示背景色。 SelectionRange 在月历中显示的起始时间范围，Begin为开始，end为截至。 Minmum 最小值，默认0. Showtody,showtodaycircle,Showweeknumbers 是否显示今天日期是否在今天日期上加红圈是否左侧显示周数（1-52周） TitlebackcolorTitleForcolorTrailingcolor 日历标题背景色。日历标题前景色上下月颜色 代码示例： using System; using System.Windows.Forms; namespace Demo{ public partial class Form1:Form{ public Form1(){ InitializeComponent(); } DateTime mytime = new DateTime(2019, 7, 1); monthCalendar1.AddBoldedDate(mytime); monthCalendar1.UpdateBoldedDates(); } private void monthCalendar1_DateChanged(object sender, DateRangeEventArgs e) { textBox1.Text = e.Start.ToString(); } } } 数据控件：DataGridView构造函数： 常用属性： 代码示例： 验证组件：ErrorProvider（完成）构造方法： 常用属性： 属性值 释义 BlinkStyle：此属性获取或设置一个值，该值指示错误图标闪烁时间。该属性有如下三个选项： AlwaysBlink：当错误图标第一次显示时，或者当为控件设置了错误描述字符串并且错误图标已经显示时，总是闪烁BlinkIfDifferentRrror：当图标已经显示并且为控件设置了新的错误字符串时闪烁；NeverBlink：该错误图标从不闪烁； BlinkRate 此属性获取或设置错误图标的闪烁速率，以毫秒为单位。 SetError方法 此方法将Error属性设置为指定的TextWriter对象。 Validating事件 此事件在控件正在验证时发生。 代码示例： using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Text; using System.Windows.Forms; namespace ErrorProvider1 { public partial class Form1 : Form { #region 构造函数 public Form1() { InitializeComponent(); } string user; string password; #endregion #region 登录名文本框验证时发生的事件 private void txtUser_Validating(object sender, CancelEventArgs e) { if (txtUser.Text != \"sa\") { //当光标放在报警图标上，会显示“登录名错误” errUser.SetError(txtUser, \"登录名错误\"); } else { errUser.SetError(txtUser, \"\"); password = txtUser.Text; } } #endregion #region 密码文本框验证时发生的事件 private void txtPasword_Validating(object sender, CancelEventArgs e) { if (txtPasword.Text != \"rbsoft\")//判断输入是否正确 { //当光标放在报警图标上，会显示“密码错误” errPassword.SetError(txtPasword, \"密码确误\"); } else { errPassword.SetError(txtPasword, \"\"); user = txtPasword.Text; } } #endregion #region 确定按钮事件 private void btnOK_Click(object sender, EventArgs e) { if (password != null &amp;&amp; user != null) { MessageBox.Show(\"登录成功\"); } else { MessageBox.Show(\"输入用户名和密码\"); } } #endregion #region 取消按钮事件 private void btnCancel_Click(object sender, EventArgs e) { Application.Exit(); } #endregion } } 帮助文件：HelpProvider（完成）构造函数： 常用属性： 属性值 释义 Tag 获取或设置包含有关HelpProvider的补充数据对象 HelpNamspace 获取或设置一个值，该值指定与此HelpProvider对象关联的帮助文件名 代码示例： using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; namespace HelpProviderDemo { public partial class Form1 : Form { public Form1() { InitializeComponent(); } HelpProvider HP; private void Form1_Load(object sender, EventArgs e) { MessageBox.Show(\"要想获得帮助。请按F1\"); HP = new HelpProvider(); string Source = \"Help.txt\"; HP.HelpNamespace = Source; HP.SetShowHelp(this, true); } } } 布局管理器：（Layout）流式布局：FlowLayoutpanel网格布局：TablelayPanel卡片布局：TabControl分组布局：GroupBox分割布局：SplitContainer对话框：（Dialog）文件选择对话框：OpenFileDialog（完成）构造函数： 主要属性 属性值 释义 InitialDirectory 对话框的初始目录 Filter 获取或设置当前文件名筛选器字符串，例如，”文本文件(*.txt) FilterIndex 在对话框中选择的文件筛选器的索引，如果选第一项就设为1 RestoreDirectory 控制对话框在关闭之前是否恢复当前目录 FileName 第一个在对话框中显示的文件或最后一个选取的文件 Title 将显示在对话框标题栏中的字符 AddExtension 是否自动添加默认扩展名 CheckPathExists 在对话框返回之前，检查指定路径是否存在 DefaultExtension 默认扩展名 DereferenceLinks 在从对话框返回前是否取消引用快捷方式 ShowHelp 启用”帮助”按钮 代码示例： 保存文件对话框：SaveFileDialog（完成）构造方法： SaveFileDialog(); 主要属性 属性值 释义 AddExtension 获取或设置一个值，该值指示如果用户省略扩展名，对话框是否自动在文件名中添加扩展名。 DefaultExtension 获取或设置默认文件扩展名。 FileName 获取或设置一个包含在文件对话框中选定的文件名的字符串。 Filter 获取或设置当前文件名筛选器字符串，该字符串决定对话框的“另存为文件类型”或“文件类型”框中出现的选择内容。 InitialDirectory 获取或设置文件对话框显示的初始目录。 RestoreDirectory 获取或设置一个值，该值指示对话框在关闭前是否还原当前目录。 Title 获取或设置文件对话框标题。 FilterIndex 获取或设置文件对话框中当前选定筛选器的索引。 注意：第一个扩展名就是1，第二个扩展名就是2。 代码综合示例： using System; using System.IO; using System.Text; using System.Windows.Forms; namespace demo { public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void Form1_Load(object sender, EventArgs e) { MessageBox.Show(\"你强任你强，大哥背行囊\", \"Error!\", MessageBoxButtons.YesNo, MessageBoxIcon.Error); } //打开文件 private void button1_Click(object sender, EventArgs e) { DialogResult dr = openFileDialog1.ShowDialog(); //获取所打开文件的文件名 string filename = openFileDialog1.FileName; if (dr == System.Windows.Forms.DialogResult.OK &amp;&amp; !string.IsNullOrEmpty(filename)) { StreamReader sr = new StreamReader(filename); textBox1.Text = sr.ReadToEnd(); sr.Close(); } } //保存文件 private void button2_Click(object sender, EventArgs e) { DialogResult dr = saveFileDialog1.ShowDialog(); string filename = saveFileDialog1.FileName; if (dr == System.Windows.Forms.DialogResult.OK &amp;&amp; !string.IsNullOrEmpty(filename)) { StreamWriter sw = new StreamWriter(filename, true, Encoding.UTF8); sw.Write(textBox1.Text); sw.Close(); } } } } 字体对话框：FontDialog（完成）构造函数： 主要属性 常用API 释义 void Font 设定或获取字体信息 void Color 设定或获取字符的颜色 void Maxmize/Minmize 获取或设置用户可选择最大磅值 void ShowColor 获取或设置一个值，指示对话框是否显示颜色选择框。 void ShowEffect 获取或设置一个值，指示对话框是否包含允许用户指定删除线、下划线和文本颜色选项控件 代码示例： 浏览文件夹对话框：FolderBrowserDialog（完成）构造方法： FolderBrowserDialog(); //代码示例： FolderBrowserDialog folder = new FolderBrowserDialog(); 属性值： 常用API 释义 Description 表示获取或设置对话框中在树形控件上显示的说明文本 RootFolder 表示获取或设置从其开始浏览的根文件夹 SelectedPath 表示获取或设置用户选定的路径 ShowNewFolderButton 获取或设置一个值，该值指示“新建文件夹”按钮是否显示在文件夹浏览对话框中 常用API： 常用API 释义 ShowDialog 用默认的所有者运行通用对话框。该方法的返回值类型为DialogResult，如果用户在对话框中单击“确定”按钮，则为DialogResult.OK，否则为DialogResult.Cancel 代码示例： using System; using System.Windows.Forms; namespace FolderDialogDemo{ public partial class FolderDialogDemo:Form{ public FolderDialogDemo(){ InitializeComponent(); } private void button1_Click(object sender,EventArgs e){ string defaultPath = \"\"; FolderBrowserDialog dialog = new FolderBrowserDialog(); //打开的文件夹浏览对话框上的描述 dialog.Description = \"请选择一个文件夹\"; //是否显示对话框左下角 新建文件夹 按钮，默认为 true dialog.ShowNewFolderButton = false; //首次defaultPath为空，按FolderBrowserDialog默认设置（即桌面）选择 if (defaultPath != \"\") { //设置此次默认目录为上一次选中目录 dialog.SelectedPath = defaultPath; } //按下确定选择的按钮 if (dialog.ShowDialog() == DialogResult.OK) { //记录选中的目录 defaultPath = dialog.SelectedPath; } MessageBox.show(defaultPath); } } } 颜色选择对话框：ColorDialog（完成）主要属性 常用API 释义 Color 获取或设置用户选中的颜色 AnyColor 指示对话框是否显示基本颜色集中可用的所有颜色 FullOpen 用于创建自定义颜色的空间在对话框打开时是否可见 AllowFullOpen 指示用户是否可以使用该对话框定义自定义颜色 代码示例： using System; using System.Windows.Forms; namespace ColorDialogDemo{ public partial class ColorDialogDemo:Form{ public ColorDialogDemo(){ InitializeComponent(); } } } 消息框：MessageBox（完成）构造方法： MessageBox(\"显示的文字\",\"标题内容\",MessageBoxButtons buttons,DialogBoxIcon icon,DialogResult result,) //代码示例 MessageBox.Show(\"这瓜保熟吗?\",\"Erro!\",MessageBoxButton.RetryCancel); 常用API： 方法 说明 DialogResult Show(string text) 指定消息框中显示的文本（text） DialogResult Show(string text, string caption) 指定消息框中显示的文本（text）以及消息框的标题（caption） DialogResult Show(string text, string caption, MessageBoxButtons buttons) 指定消息框中显示的文本（text）、消息框的 标题（caption）以及消息框中显示的按钮 （buttons） DialogResult Show(string text, string caption, MessageBoxButtons buttons, MessageBoxIcon icon) 指定消息框中显示的文本（text）、消息框的 标题（caption ）、消息框中显示的按钮 （buttons）以及消息框中显示的图标（icon） MessageBoxButtons： 枚举值名称 释义 OKOKCancel 在消息框中显示“确定”按钮。在消息框中显示“确定”和“取消”按钮。 AbortRetryIgnore 在消息框中显示“中止” “重试”和“忽略”按钮。 YesNoCancelYesNo 在消息框中显示“是” “否”和“取消”按钮。在消息框中显示“是”和“否”按钮。 RetryCancel 在消息框中显示“重试”和“取消”按钮。 DialogBoxIcon： 枚举值名称 释义 None 在消息框中不显示任何图标。 Hand、Stop、Error 在消息框中显示由一个红色背景的圆圈及其中的白色X组成 的图标。 Question 在消息框中显示由圆圈和其中的一个问号组成的图标。 Exclamation、Warning 在消息框中显示由一个黄色背景的三角形及其中的一个感叹号组成的图标。 Asterisk、Information 在消息框中显示由一个圆圈及其中的小写字母 i 组成的图标。 DialogResult： 枚举值名称 释义 None 消息框没有返回值，表明有消息框继续运行。 OK 消息框的返回值是 0K （通常从标签为“确定”的按钮发送）。 Cancel 消息框的返回值是 Cancel （通常从标签为“取消”的按钮发送）。 Abort 消息框的返回值是 Abort （通常从标签为“中止”的按钮发送）。 Retry 消息框的返回值是 Retry （通常从标签为“重试”的按钮发送） Ignore 消息框的返回值是 Ignore （通常从标签为“忽略“的按钮发送）。 Yes 消息框的返回值是 Yes （通常从标签为“是“的按钮发送）。 No 消息框的返回值是 No （通常从标签为“否“的按钮发送）。 自定义消息框： 代码示例： using System; using System.Windows.Forms; public partial class MessageBoxDemo:Form{ public MessageBoxDemo(){ InitializeComponent(); } private void MessageBoxDemo_Load(object sender,EventArgs e){ MessageBox.Show(\"这瓜保熟吗?\",\"Erro!\",MessageBoxButton.RetryCancel); MessageBox.Show(\"啊哈哈哈，鸡汤来喽！\",\"Error!\",MessageBoxButton.YesyNoCancel); MessageBox.Show(\"背背背起了行囊，离开家的那一刻，我知道现实生活有太多的不舍\", \"Error!\", MessageBoxButtons.YesNoCancel, MessageBoxIcon.Stop); } } 处理机制：（Handler）定义语法： \"组件名称\".\"事件名称\"+= new Syetem.Windows.Froms. KeyEventHandler（\"事件名称\"）； //代码示例 button.Click + = new EventHandler(this.Demo); private void Demo_Click(object sender,EventArgs e){ } 窗体事件处理：FromHandlerEvent构造方法 FormBorderStyle属性值： 属 性 值 说 明 Fixed3D 固定的三维边框 FixedDialog 固定的对话框样式的粗边框 FixedSingle 固定的单行边框 FixedToolWindow 不可调整大小的工具窗口边框 None 无边框 Sizable 可调整大小的边框 SizableToolWindow 可调整大小的工具窗口边框 StartPosition属性的属性值及说明 属 性 值 说 明 CenterParent 窗体在其父窗体中居中 CenterScreen 窗体在当前显示窗口中居中，其尺寸在窗体大小中指定 Manual 窗体的位置由Location属性确定 WindowsDefaultBounds 窗体定位在Windows默认位置，其边界也由Windows默认决定 WindowsDefaultLocation 窗体定位在Windows默认位置，其尺寸在窗体大小中指定 主要事件 主要事件 释义 Load 第一次显示窗体前发生 Activated 窗体激活时发生 Deactivate 窗体失去焦点成为不活动窗体时发生。 Resize 改变窗体大小时发生 Paint 重绘窗体时发生 Click 单击窗体发生 Closed 关闭窗体时发生 //代码示例 private void Form_事件名(object sender,EventArgs e){ //arguments } 例：private void Form_Load(object sender,EventArgs e){ 代码示例 private void Form1_Load(object sender, EventArgs e){ this.MaximizeBox = false; this.MinimizeBox = true; this.FormBorderStyle = FormBorderStyle.FixedSingle; } 多文档窗体：MDI事件处理机制：HandlerEvent（完成）构造方法： 代码示例： button.Click+=new HandlerEvent(this.DemoMesthod); public void DemoMethod_Click(object sender,EventArgs e){ MessageBox.Show(\"点击按钮弹出对话框\"); } 键盘处理机制：KeyHandlerEvent（完成）构造方法： 常用API： 常用API 释义 KeyPressEventArgs* Handled* KeyChar 用来获取或设置一个值，该值指示是否处理过KeyPress事件。用来获取按下的键对应的字符，通常是该键的ASCII码。 KeyEventArgs：* Alt* Control* Shift* Handled* KeyCode* KeyData* KeyValue* Modifiers 用来获取一个值，该值指示是否曾按下Alt键用来获取一个值，该值指示是否曾按下Ctrl键。用来获取一个值，该值指示是否曾按下Shift键。用来获取或设置一个值，该值指示是否处理过此事件。以 Keys枚举型值返回键盘键的键码，该属性不包含修改键（Alt、Control和 Shift键）信息，用于测试指定的键盘键。以 Keys 枚举类型值返回键盘键的键码，并包含修改键信息，用于判断关于按下键盘键的所有信息。以整数形式返回键码，而不是Keys枚举类型值。用于获得所按下键盘键的数字表示。以 Keys 枚举类型值返回所有按下的修改键（Alt、Control 和 Shift 键），仅用于判断修改键信息。 代码示例： 鼠标处理机制：MouseHandlerEvent（完成）构造方法： 常用API： 常用API 释义 MouseEnter 在鼠标指针进入控件时发生。 MouseHover 当鼠标指针悬停在控件上时将发生该事件。 MouseDown 当鼠标指针位于控件上并按下鼠标键时将发生该事件。 MouseUp 当鼠标指针在控件上并释放鼠标键时将发生该事件。 MouseLeave 在鼠标指针离开控件时将发生该事件。 MouseWheel 在移动鼠标轮并且控件有焦点时将发生该事件。 MouseMove（枚举型）在鼠标指针移到控件上时发生。MouseButton MouseButton枚举型 释义 Left 按下了鼠标左键 Middle 按下了鼠标中键 Right 按下了鼠标右键 None 没有按下按钮 XButton1 按下了第一个XButton按钮 XButton2 按下了第二个XButton按钮 代码示例： 特殊类：媒体播放器：Media PlayerPDF浏览器：Adobe PDF Reader托盘图标： NotifyIcon构造函数： NotifyIcon(); NotifyIcon notifyIcon1 = new NotifyIcon(); 常用API： 常用API 释义 BalloonTipText 气泡所提示的内容 BalloonTipTitle 气泡提示的标题 ContextMenuStrip 绑定的右键菜单 Icon 托盘显示的图标 Text 鼠标靠近图标显示的提示信息 Visible 是否显示图标 代码示例： using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Drawing; using System.Linq; using System.Text; using System.Windows.Forms; namespace notifyIconShow { public partial class ColdJoke : Form { #region //创建NotifyIcon对象 NotifyIcon notifyicon = new NotifyIcon(); //创建托盘图标对象 Icon ico = new Icon(\"snow.ico\"); //创建托盘菜单对象 ContextMenu notifyContextMenu = new ContextMenu(); #endregion public ColdJoke() { InitializeComponent(); } #region 托盘提示 private void Form1_Load(object sender, EventArgs e) { //设置鼠标放在托盘图标上面的文字 this.notifyIcon1.Text = \"笑话\"; } #endregion #region 隐藏任务栏图标、显示托盘图标 private void Form1_SizeChanged(object sender, EventArgs e) { //判断是否选择的是最小化按钮 if (WindowState == FormWindowState.Minimized) { //托盘显示图标等于托盘图标对象 //注意notifyIcon1是控件的名字而不是对象的名字 notifyIcon1.Icon = ico; //隐藏任务栏区图标 this.ShowInTaskbar = false; //图标显示在托盘区 notifyicon.Visible = true; } } #endregion #region 还原窗体 private void notifyIcon1_DoubleClick(object sender, EventArgs e) { //判断是否已经最小化于托盘 if (WindowState == FormWindowState.Minimized) { //还原窗体显示 WindowState = FormWindowState.Normal; //激活窗体并给予它焦点 this.Activate(); //任务栏区显示图标 this.ShowInTaskbar = true; //托盘区图标隐藏 notifyicon.Visible = false; } } #endregion } } 打开文件：ProcessStart构造方法： 构造方法 释义 Process.Start(); Process.Start(ProcessStartInfo); Process.Start(String path,String path2); Process.Start(String path1,String path2,SecureString secure,String) Process.Start(String path1,String path2,String path3,SecureString secure,String path4); 通过指定应用程序的名称和一组命令行参数、用户名、密码和域来启动一个进程资源，并将该资源与新的 Process 组件关联起来。 常用方法： 代码示例 using System; namespace Demo{ public class ProcessStart{ static void Main(string [] args){ } } } 水晶报表Excel数据处理：制作软件技巧与经验：作者的话：","categories":[{"name":"后端编程语言","slug":"后端编程语言","permalink":"http://www.luckyzmj.cn/categories/%E5%90%8E%E7%AB%AF%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://www.luckyzmj.cn/tags/C/"},{"name":"图形化界面","slug":"图形化界面","permalink":"http://www.luckyzmj.cn/tags/%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/"}]},{"title":"Css知识体系","slug":"前端编程语言/Css知识体系","date":"2022-06-23T02:35:58.000Z","updated":"2022-07-01T07:07:25.926Z","comments":true,"path":"posts/4832396d.html","link":"","permalink":"http://www.luckyzmj.cn/posts/4832396d.html","excerpt":"","text":"CSS知识体系：阅读本文前先看： 基本格式 &lt;!DCOTYPE html&gt; &lt;html&gt; &lt;head&gt;&lt;!--头文件用于引入css文件--&gt; &lt;title&gt;Demo功能代码&lt;/title&gt; &lt;style&gt; &lt;!--引入修饰css部分--&gt; p{ text-align:center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--代码主体内容--&gt; &lt;p&gt;这是一段受css影响的文字&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; CSS介绍： 修饰类型语言分支之一，相似语言有Unity中Shader着色器、Animation动画等，主要修饰html内的元素。属于前端开发语言。是用来表现HTML或XML等文件样式计算机语言，既可以修饰静态网页，有可以配合各种脚本语言动态的对网页各元素进行格式化。 元素修饰作用已在开头给出，*修饰为常用元素，请读者多注意！ 选择集：作用：相当于后端语言中JAVA中import、C# 中using导包方式 import java.util.*; //JAVA引入外部文件 using System.Collections.Generic; //C#引入外部文件 //Css引入 方式一： &lt;style&gt;@import url(Style.css);&lt;/style&gt; 方式二：（最常使用） &lt;link rel=\"Stylesheet\" type =\"text/css\" href=\"Style.css\"&gt;&lt;/link&gt; 方式三：内联方式 &lt;div style =\"background:red\"&gt;&lt;/div&gt; 方式四：内嵌方式只能改变当前标签的样式，可维护性查 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;!--头部部分相当于后端语言中导包部分--&gt; &lt;head&gt; &lt;style&gt; .conment{ background-image:url(\"\"); background-repeat:none; } &lt;/style&gt; &lt;/head&gt; &lt;/html&gt; 选择器：只想您需要设置样式的HTML元素 声明块：包含一条或多条用分号分隔的什么 每条声明都包含一个Css属性名称和一个值，以冒号分隔。 多条Css声明用分号分隔，声明块用花括号括起来。 选择器类型： id选择器：可以标记为特殊id的HTML元素指定样式，要选择具有特定id元素后跟元素，不能以数字开头 #{ } 类选择器：选择特定class属性HTML，选择特定class元素，句点字符，后面跟类名。 .center{ text-align:center; color:black; } &lt;h1 class = \"center\"&gt;受影响的红色标题&lt;/h1&gt; &lt;p class = \"center'&gt; 受影响的红色段落&lt;/p&gt; 通用选择器：*选择页面上所有HTML元素，页面内所有元素均受影响： *{ text-align:center; color:blue; } 分组选择器： h1,h2,p{ text-align:center; color:red; } Style（样式）：background（背景）：（完成）background-image：背景图片常用方法： url(URL)：图像的URL地址 none：无图像背景会显示，这是默认 inherit：指定背景图像从父元素继承 &lt;!DOCTYPE html&gt; &lt;html lang=\"zh-cn\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;Multiple backgrounds&lt;/title&gt; &lt;style&gt; .body{ background:image:url(https://s3.bmp.ovh/imgs/2022/05/26/91badb9ac7f72757.png); background-repeat:no-repeat; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt; &lt;/html&gt; background-color：背景颜色常用方法： color：选择指定颜色 transparent：指定背景颜色应该是透明的 inherit：指定背景颜色，应该从父元素继承 代码示例： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;功能Demo&lt;/title&gt; &lt;style&gt; span.highlight{ background-color:yellow; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; &lt;span class=\"highlight\"&gt;水字数&lt;/span&gt; 水字数 &lt;span class=\"highlight\"&gt;这是一些文本。&lt;/span&gt; &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; background-position：背景图像位置 定位方式： 页面背景图像：background-positon:center; %定位背景图像：background-position:50%,20%; 像素定位背景图像：background-position:50px,20px; inherit：继承父元素 background-repeat：背景图像重复常用方法： repeat：背景图像将向垂直和水平方向重复 repeat-x：只有水平位置会重复背景图像 repeat-y：只有垂直位置会重复背景图像 no-repeat：图像不会重复 inherit：从父元素获取 background-attachment：背景图片固定常用方法： scroll：背景图片随页面其余部分滚动（默认） fixed：背景图像是固定的 local：背景图片随滚动元素滚动 background-clip：背景绘制区域： border-box：背景绘制在内容方框内，背景绘制在内容方框内（剪切成内容方框）。 padding-box：背景绘制在衬距方框内（剪切成衬距方框）。 border-box：默认值。背景绘制在边框方框内（剪切成边框方框）。 代码示例：&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;backgroundCSS属性测试&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt; &lt;style&gt; body{ background-image: url(https://s3.bmp.ovh/imgs/2022/05/26/91badb9ac7f72757.png); background-repeat: no-repeat; background-attachment: fixed background-clip:content-box; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;有谁能拒绝一只猫呢？快给我变!&lt;/p&gt; &lt;p&gt;有谁能拒绝一只猫呢？快给我变!&lt;/p&gt; &lt;p&gt;有谁能拒绝一只猫呢？快给我变!&lt;/p&gt; &lt;p&gt;有谁能拒绝一只猫呢？快给我变!&lt;/p&gt; &lt;p&gt;有谁能拒绝一只猫呢？快给我变!&lt;/p&gt; &lt;p&gt;有谁能拒绝一只猫呢？快给我变!&lt;/p&gt; &lt;p&gt;有谁能拒绝一只猫呢？快给我变!&lt;/p&gt; &lt;p&gt;有谁能拒绝一只猫呢？快给我变!&lt;/p&gt; &lt;p&gt;有谁能拒绝一只猫呢？快给我变!&lt;/p&gt; &lt;p&gt;有谁能拒绝一只猫呢？快给我变!&lt;/p&gt; &lt;p&gt;有谁能拒绝一只猫呢？快给我变!&lt;/p&gt; &lt;p&gt;有谁能拒绝一只猫呢？快给我变!&lt;/p&gt; &lt;p&gt;有谁能拒绝一只猫呢？快给我变!&lt;/p&gt; &lt;p&gt;有谁能拒绝一只猫呢？快给我变!&lt;/p&gt; &lt;p&gt;有谁能拒绝一只猫呢？快给我变!&lt;/p&gt; &lt;p&gt;有谁能拒绝一只猫呢？快给我变!&lt;/p&gt; &lt;p&gt;有谁能拒绝一只猫呢？快给我变!&lt;/p&gt; &lt;p&gt;有谁能拒绝一只猫呢？快给我变!&lt;/p&gt; &lt;p&gt;有谁能拒绝一只猫呢？快给我变!&lt;/p&gt; &lt;p&gt;有谁能拒绝一只猫呢？快给我变!&lt;/p&gt; &lt;p&gt;有谁能拒绝一只猫呢？快给我变!&lt;/p&gt; &lt;p&gt;有谁能拒绝一只猫呢？快给我变!&lt;/p&gt; &lt;p&gt;有谁能拒绝一只猫呢？快给我变!&lt;/p&gt; &lt;p&gt;有谁能拒绝一只猫呢？快给我变!&lt;/p&gt; &lt;p&gt;有谁能拒绝一只猫呢？快给我变!&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; border（边框）：border-image：边框样式图像填充border-image-width：图像宽度 number：表示相应border-width倍数 %：边界图像区域的大小 auto：自适应 border-image-source：图像引用 image：边框使用图像路径 none：默认，没有图像使用 border-image-repeat：是否重复： stretch：默认值，拉伸图像来填充区域 repeat：平铺来填充区域 round：对图像进行缩放以适应区域 space：扩展控件分布图像周围 border-right/left：左/右边框属性border-right/left-style：左右边框样式 none：无边框 dotted：定义点状边框（浏览器中为实线） dashed：定义虚线边框（浏览器中为实线） solid：定义实线 double：定义双线，宽度取决于border-width border-right/left-color：左右边框颜色 color：定义左右边框的颜色 transparent：指定边框颜色透明 代码示例： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; border-right/left-width：左右边框框距 thin：细的右边框 medium：默认值，中等的右边框 thick：定义粗的右边框 length：自定义右边框宽度 代码示例：&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; border-top/bottom：顶/底部边框属性border-top/bottom-color：顶/底部边框颜色 color_name：规定颜色值为边框颜色 hex_number：规定颜色值为十六进制边框颜色 rgb_number：规定rgb代码为边框颜色 transparent：边框颜色为透明 border-top/bottom-left/right-radius：左/右下角圆角边框 length：定义右下角形状 %：使用%定义右下角形状 /* 圆形 */ /* border-bottom-left-radius: radius */ border-bottom-left-radius: 3px; /* 椭圆形 */ /* border-bottom-left-radius: 水平方向 垂直方向 */ border-bottom-left-radius: 0.5em 1em; border-bottom-left-radius: inherit; border-top/bottom-style：顶/底部边框样式 none：无边框 hidden：解决边框冲突 dotted：点状边框 dashed：虚线边框 solid：实线边框 double：双边框 groove：双线 border-top/bottom-width：顶/底部边框宽度 thin：细的下边框： medium：定义中等的下边框 thick：粗的下边框 length：长度 代码示例：&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; outline（线条轮廓）（完成）out-line-color：线条轮廓颜色 color：指定轮廓颜色 invert：默认，颜色反转，可使轮廓在不同的背景颜色中都是可见的。 outline-style：线条轮廓样式 dotted：点状轮廓 dashed：虚线轮廓 solid：实线轮廓 double：双线轮廓 online-width：线条轮廓宽度 thin：细轮廓 thick：粗轮廓 medium：中等轮廓 length：规定轮廓粗细值 代码示例： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;online功能demo测试&lt;/title&gt; &lt;/head&gt; &lt;style&gt; p.one{ border:1px solid red; outline-style:solid; outline-width:thin; outline-color:red; } p.two{ border:1px solid red; outline-style:dotted; outline-width:3px; outline-color:blue; } &lt;/style&gt; &lt;body&gt; &lt;p class =\"one\"&gt;受影响的文字1&lt;/p&gt; &lt;p class =\"two\"&gt;受影响的文字2&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; margin（外边距）：(完成)margin-bottom/top（上下边距） auto：浏览器设置的上/下外边距 length：定义固定的上/下外边距，默认值为0 %：定义基于父对象总宽度的百分比上外边距。 margin-left/right（左右边距）： auto：浏览器设置的左/右外边距 length：定义固定的左/右外边距，默认值为0 $：定义基于父对象总宽度的百分比左/右外边距。 代码示例：&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;margin外边距测试&lt;/title&gt; &lt;style&gt; p.demo1{ padding:2cm } p.demo2{ padding-left:0.5,3cm; } p.demo3{ padding-right:2cm } p.demo4{ padding-top:2cm } p.demo5{ padding-bottom:2cm } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p class=\"demo1\"&gt;这段文字每边的内边距相等。两边的衬垫是2cm.&lt;/p&gt; &lt;p class=\"demo2\"&gt;该文本的上下padding为0.5cm，左右padding为3cm.&lt;/p&gt; &lt;p class =\"demo3\"&gt; &lt;/p&gt; &lt;p class =\"demo4\"&gt; &lt;/p&gt; &lt;p class =\"demo5\"&gt; &lt;/p&gt; &lt;/body&gt; &lt;/body&gt; &lt;/html&gt; padding（内边距）：（完成）padding-top/bottom（内边距上下）： lentth：规定以具体单位计的固定的下内边距值，比如像素、厘米等。默认值是 0px。 $：定义基于父元素宽度的百分比下内边距。此值不会如预期地那样工作于所有的浏览器中。 padding-left/right（内边距左右）： lentth：规定以具体单位计的固定的下内边距值，比如像素、厘米等。默认值是 0px。 $：定义基于父元素宽度的百分比下内边距。此值不会如预期地那样工作于所有的浏览器中。 代码示例：&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt; &lt;style&gt; p.padding-left{ padding-left:2cm; } p.padding-right{ padding-right:2cm; } p.padding-bottom{ padding-bottom:2cm; } p.padding-top{ padding-top:2cm } &lt;/style&gt; &lt;body&gt; &lt;p class = \"padding-left\"&gt;受影响的左边元素&lt;/p&gt; &lt;p class =\"padding-right\"&gt;受影响的右边元素&lt;/p&gt; &lt;p class =\"padding-bottom\"&gt;受影响的底部元素&lt;/p&gt; &lt;p class =\"padding-top\"&gt;受影响的顶部元素&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; Element（构成元素）：text（文本）：（完成）text-align-last：对齐文本最后一行常用方法： auto：最后一行被调整，并向左对齐（默认值） left：最后一行向左对齐 right：最后一行向右对齐 center：最后一行居中对齐 start：最后一行在行开头对齐 end： text-align：文本对齐方式 left：排列左边对齐（默认） right：排列到右边 center：排列到中间 justify：两端对齐文本效果 inherit：继承父元素 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;tltle&gt;测试文档&lt;/tltle&gt; &lt;style&gt; b.{ color:red; text-align:right; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class =\"b\"&gt; &lt;b&gt;这是一段测试文字&lt;/b&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; text-decoration-line：顶部显示线条常用方法： none：文本修饰没有线条（默认值） underline：文本下方显示条线 overline：文本上方显示一条线 line-through：文本中间显示一条线 inherit：继承父元素 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;功能Demo测试&lt;/title&gt; &lt;style&gt; p{ text-decoration-line:overline; -moz-text-decoration-line:overline; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; 本实例中的段落上方会显示一条线 &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; text-decoration-style：下方显示波浪线常用方法： solid：默认值，线条将显示为单线 double：线条显示双线 dotted：线条将显示为点状线 dashed：线条显示为虚线 wavy：线条显示为波浪线 inherit：继承父元素 代码示例： p{ text-decoration:underline; -moz-text-decoration-style:wavy; } text-indent：缩进段落第一行：代码示例： p{ text-indent:50px text-indent:50%; } text-justify：改变字与字之间间距常用API： auto：浏览器决定齐行算法 none：禁用齐行 inter-word：增加/减少单词间间隔 inter-ideograph：用文意文本来排齐内容 inter-cluster：只对不包含内部单词间隔内容进行排齐 distribute：类似报纸版面 kashida：通过拉伸字符来排齐内容。 div{ text-align:justify; text-justify:inter-word; } text-overflow：文本溢出包含它元素发生常用API： clip：修建文本 ellipsis：显示省略符号来代表被修建的文本 代码示例： p{ text-overflow:clip; } text-shadow：文本阴影效果：常用API： h-shadow：必须，水平阴影位置 v-shadow：必须，垂直阴影位置 blur：可选，模糊距离 color：可选阴影颜色 代码示例： h1{ text-shadow:5px 5px 5px ##FF0000; } text-transform：转换不同元素文本常用方法： none：带有小写字母和大写字母标准文本 capitalize：文本中的每个单词以大写字母开头 uppercase：定义仅有大写字母 lowercase：定义无大写字母，仅有小写字母 代码示例： h1{ text-transform:uppercase; } h2{ text-transform:capitalize; } p{ text-transform:lowercase; } Font（字体）：（完成）常用API： xx-small：（把字体尺寸设置为不同尺寸） x-small： small： medium lagre x-lagre xx-lagre smaller：设置为比父元素更小尺寸 larger：设置为比父元素更大尺寸 length：设置为一个固定值 代码示例： h1{ font-size:250%; } h2{ font-size:1105; } font-size-adjust： font-size-adjust 属性为某个元素规定一个 aspect 值，这样就可以保持首选字体的 x-height。 h1{ font-size-adjust:0.58; } p{ font-size-adjust:0.60; } font-size：字体尺寸常用方法： xx-small x-small small medium（默认） large x-large xx-large smaller：比父元素更小的尺寸 larger：比父元素更大的尺寸 length：设置为固定值 %：设置基于父元素百分比 font-family：字体系列 family-name - 指定的系列名称：具体字体的名称，比如：”times”、”courier”、”arial”。 generic-family - 通常字体系列名称：比如：”serif”、”sans-serif”、”cursive”、”fantasy”、”monospace”。 使用某种特定的字体系列（Geneva）完全取决于用户机器上该字体系列是否可用；这个属性没有指示任何字体下载。因此，强烈推荐使用一个通用字体系列名作为后路。 font-style：字体样式常用API： normal：标准字体样式 italic：斜体字体样式 bolique：倾斜字体样式 代码示例： p.normal{ font-style:normal; } p.italic{ font-style:italic; } p.oblique{ font-style:oblique; } &lt;p class -\"normal\"&gt;这是默认文字&lt;/p&gt; font-weight：文字粗细常用API： normal：标准字符（默认） bold：粗体字符 bolder：定义更粗的字符 lighter：定义更细的字符 数字值：100、200 代码示例： p.normal{ font-weight:normal; } p.thick{ font-weight:bold; } p.thicker{ font-weight:900; } 代码示例： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Font系列功能测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p class =\"one\"&gt; 这是受影响的文字1 &lt;/p&gt; &lt;p class =\"two\"&gt; 这是受影响的文字2 &lt;/p&gt; &lt;p class = \"three\"&gt; 这是第三段受影响的文字3 &lt;/p&gt; &lt;p class =\"four\"&gt; 这是第四段受影响的文字 &lt;/p&gt; &lt;/body&gt; &lt;/html&gt; CSS文件： .one{ font-family:\"微软雅黑\", \"方正舒体\", \"方正宋一简体\";/* 设置字体，一般不用设置该属性*/ font-weight:bold; /* 设置加粗样式*/ font-size:100px; /* 设置文本大小样式*/ color:#F00; /* 设置文本颜色样式*/ font-style:italic; /* 设置文本斜体样式*/ } .two{ font:italic 150px bold;/* 对于文本样式来说不建议采用综合写法*/ color:#f00; } .three{ font-size:80px; font-weight:bold; text-shadow:#f00 10px 10px 30px; text-align:center; text-decoration:line-through; letter-spacing:50px; /* text-shadow:#000 0px 0px 5px, #C93 0px 0px 10px , #F00 5px -5px;*/ 多重阴影叠加在一起 } .four{ font-size:24px; text-indent:48px;/*缩进值等于文字大小的乘以2*/ } List-style（列表）：（完成）list-style-image：图片设置列表项标记常用方法： URL();图像路径 none：默认，无图形显示 list-style-position：列表项标记放置位置常用方法： inside：列表项标记放置文本以内，且环绕文本根据标记对齐。 outside：保持标记谓语文本左侧，列表项目标记位置在文本之外。 综合代码示例：&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;list列表元素功能测试&lt;/title&gt; &lt;style&gt; ul{ list-style:none; list-style-image:url(\"\"); list-style-position: outside; &lt;!--inside--&gt; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;li&gt; &lt;ul&gt; 测试元素1&lt;/ul&gt; &lt;ul&gt;测试元素2&lt;/ul&gt; &lt;ul&gt;测试元素3&lt;/ul&gt; &lt;/li&gt; &lt;/body&gt; &lt;/html&gt; Table（表格）：（正在进行）border-collapse：合并表格边框常用方法： collapse：边框会合并单一边框 seperate：默认值，边框会被分开。 代码示例： &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;border-collapse功能测试&lt;/title&gt; &lt;style&gt; table { border-collapse: collapse; } table, td, th { border: 1px solid black; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;th&gt;Firstname&lt;/th&gt; &lt;th&gt;Lastname&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Peter&lt;/td&gt; &lt;td&gt;Griffin&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Lois&lt;/td&gt; &lt;td&gt;Griffin&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; border-spacing：单元格边框间距离常用方法： length：规定响铃单元的边框之间的距离 如果定义一个length参数，定义的是水平和垂直间距 定义两个参数，第一个设置是水平间距，第二个是垂直间距。 代码示例： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;border-spacing功能测试&lt;/title&gt; &lt;/head&gt; &lt;style&gt; table.ex1{ border-collapse:seperate; border-spacing:10px 50px; } table.ex2{ border-collapse:seperate; border-spacing:10px } &lt;/style&gt; &lt;body&gt; &lt;table class=\"ex1\" border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;Peter&lt;/td&gt; &lt;td&gt;Griffin&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Lois&lt;/td&gt; &lt;td&gt;Griffin&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br&gt; &lt;table class=\"ex2\" border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;Cleveland&lt;/td&gt; &lt;td&gt;Brown&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Glenn&lt;/td&gt; &lt;td&gt;Quagmire&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; caption-side：规定标题位置 top：默认值，表格标题定位在表格之上。 bottom：把表格标题定位在表格之下 empty-cells：是否显示表格中空单元格边框与背景：table-layout：表格布局 automatic：默认，列宽度由单元格内容设定 fixed：列宽由表格宽度和列宽度设定 Marquee（字幕）：其他元素：display：布局设置opacity：透明度 value：指定透明度 float：元素浮动 left：元素向左浮动 right：元素向右浮动 none：元素不浮动 代码示例：&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;style&gt; div { background-color:red; opacity:0.5; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;这是一段受影响的文字&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 实战附赠：导航栏：&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;导航栏测试&lt;/title&gt; &lt;link rel =\"stylesheet\" type=\"css/text\" href=\"Demo.css\"&gt;&lt;/link&gt; &lt;/head&gt; &lt;body&gt; &lt;div class =\"navbar\"&gt; &lt;div class =\"nav\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;一级菜单&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;一级菜单&lt;/a&gt; &lt;ol&gt; &lt;li&gt;&lt;a href =\"#\"&gt;二级菜单&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href =\"#\"&gt;二级菜单&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href =\"#\"&gt;二级菜单&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;&lt;a href =\"#\"&gt;第二个一级菜单&lt;/a&gt; &lt;ol&gt; &lt;li&gt;&lt;a href =\"#\"&gt;二级导航菜单&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href =\"#\"&gt;二级导航菜单2&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt; &lt;a href =\"#\"&gt;B站链接&lt;/a&gt; &lt;ol&gt; &lt;li&gt;&lt;a href =\"\"&gt;主页地址&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href =\"#\"&gt;二级导航菜单&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href =\"#\"&gt;二级导航菜单&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href =\"#\"&gt;二级导航菜单&lt;/a&gt;&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt; &lt;a href =\"#\"&gt;一级菜单&lt;/a&gt; &lt;/li&gt; &lt;!--这个元素定义导航切换线条--&gt; &lt; div class =\"underline\"&gt; &lt;/div&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; css文件： /*设置全局属性*/ *{ /* 页面初始化,清楚元素的内外边距 */ padding: 0; margin: 0; } body{ /* 宽度占浏览器可视区域的高度 */ width: 100vm; background-color: #f2f2f2; } li{ list-style: none; } a{ text-decoration: none; color: #000; } .navbar{ width: 100%; height: 70px; background-color: #fff; /* 盒子阴影 */ box-shadow: 0 0 5px rgba(0, 0, 0, 0.3); } .navbar .nav{ width: 1200px; height: 100%; /* 让元素自动水平居中 */ margin: 0 auto; } .navbar .nav ul{ /* 相对定位 */ position: relative; /* 弹性布局 */ display: flex; /* 让子元素平均分配宽度 */ justify-content: space-around; width: 100%; height: 100%; } .navbar .nav ul &gt; li{ width: 100%; height: 100%; } .navbar .nav ul &gt; li &gt; a{ /* 因为a元素是行内元素 必须将其转为行内块或者块级才能设置宽度和高度 */ display: block; width: 100%; height: 100%; line-height: 70px; text-align: center; } .navbar .nav ul &gt; li ol{ width: 100%; background-color: #fff; box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2); /* 让盒子先沿着y轴缩放到0 也就是隐藏了 */ transform: scaleY(0); /* 我们需要将盒子从上面滑动下来 设置一下缩放的中心点即可 设置到最上面的中间位置 */ transform-origin: 50% 0; /* 设置过渡 */ transition: all 0.6s; } .navbar .nav ul &gt; li ol li{ height: 70px; border-bottom: 1px solid rgb(245, 245, 245); } .navbar .nav ul &gt; li ol li a{ display: block; width: 100%; height: 100%; line-height: 70px; text-align: center; } .navbar .nav ul &gt; li ol li:hover{ background-color: rgba(0, 0, 0, 0.03); } .navbar .nav ul &gt; li:hover ol{ transform: scaleY(1); } .navbar .nav ul .underline{ /* 绝对定位 */ position: absolute; bottom: 0; left: 0; width: 240px; height: 6px; /* 设置一下盒子的左上角和右上角的圆角 */ border-top-left-radius: 6px; border-top-right-radius: 6px; background-color: #cc3333; /* 加上过渡 */ transition: all 0.5s; /* 现在有个小问题 我们一起看看 ne /* 就是这个问题 这个线条有点影响鼠标移入li这个效果 */ /* 这个属性就可以解决这个问题 就貌似这个元素你能看见 但是鼠标是点击不到了 现在鼠标放到线条也没事了 */ pointer-events: none; } .navbar .nav ul .underline::before{ content: \"\"; /* 利用::before伪元素设置三角 */ position: absolute; top: -10px; /* calc方法自动计算数值 让盒子居中 */ left: calc(50% - 9px); width: 18px; height: 10px; /* inherit可以继承父元素的属性值 */ background-color: inherit; clip-path: polygon(0 100%,50% 0,100% 100%); } /*切换不同菜单显示底色*/ .navbar .nav ul &gt; li:nth-child(2):hover ~ .underline{ left: 240px; /*每次+240间距*/ background-color: #ff9933; } .navbar .nav ul &gt; li:nth-child(3):hover ~ .underline{ left: 480px; background-color: #339933; } .navbar .nav ul &gt; li:nth-child(4):hover ~ .underline{ left: 720px; background-color: #0099cc; } .navbar .nav ul &gt; li:nth-child(5):hover ~ .underline{ left: 960px; background-color: #9966cc; }","categories":[{"name":"前端编程语言","slug":"前端编程语言","permalink":"http://www.luckyzmj.cn/categories/%E5%89%8D%E7%AB%AF%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"前端三件套","slug":"前端三件套","permalink":"http://www.luckyzmj.cn/tags/%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97/"},{"name":"Css","slug":"Css","permalink":"http://www.luckyzmj.cn/tags/Css/"}]},{"title":"Unity引擎","slug":"编程语言框架/Unity引擎","date":"2022-06-22T14:13:01.000Z","updated":"2022-07-01T04:18:52.417Z","comments":true,"path":"posts/e8496c7a.html","link":"","permalink":"http://www.luckyzmj.cn/posts/e8496c7a.html","excerpt":"","text":"Unity游戏引擎//即将更新，敬请期待","categories":[{"name":"引擎框架","slug":"引擎框架","permalink":"http://www.luckyzmj.cn/categories/%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://www.luckyzmj.cn/tags/C/"},{"name":"Unity引擎","slug":"Unity引擎","permalink":"http://www.luckyzmj.cn/tags/Unity%E5%BC%95%E6%93%8E/"},{"name":"Animation","slug":"Animation","permalink":"http://www.luckyzmj.cn/tags/Animation/"},{"name":"ShaderLab","slug":"ShaderLab","permalink":"http://www.luckyzmj.cn/tags/ShaderLab/"},{"name":"Mesh","slug":"Mesh","permalink":"http://www.luckyzmj.cn/tags/Mesh/"}]},{"title":"排序算法","slug":"计算机原理/排序算法","date":"2022-06-21T15:54:31.000Z","updated":"2022-07-01T04:18:52.424Z","comments":true,"path":"posts/735e5788.html","link":"","permalink":"http://www.luckyzmj.cn/posts/735e5788.html","excerpt":"","text":"十种排序算法：冒泡排序： 思想：若干次遍历要排序的数列，每次遍历时，从前往后一次比较相邻两个数大小，前者比后者大就交换他们的位置。 原理演示 int destination = {21,56,92,62,45,75,36}; int count=0; for( int i =0;i&lt;destination.length-1;i++){ //控制比较次数 for(int j=0;j&lt;destination.length-i-1;j++){ //控制比较相邻的两个元素 if(destination[j]&gt;destination[j+1]){ int temp = destination[j]; destination[j]=destination[j+1]; //交换位置 destination[j+1] = temp; } count++; } } System.out.println(Arrays.toString(destination)); System.out.println(\"一共比较了\" + count+\"次\"); 代码模板： public class BubbleSort{ public static void main(String[] args){ int[] arr={11,55,33,62,78,95}; bubbleSort(arr); System.out.println(Arrays.toString(arr)); } private static void bubbleSort(int[] arr){ for(int i=0;i&lt;arr.length;i++){ boolean sorted = true; for(int j=0;j&lt;arr.length-i-1;j++){ if(arr[j]&gt;arr[j+1]){ sorted=false; arr[j] = arr[j] ^ arr[j + 1] ^ (arr[j + 1] = arr[j]); } } if(sorted) return; } } } 时间复杂度 冒泡排序的时间复杂度是O(N2)。 假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢? N-1次！因此，冒泡排序的时间复杂度是O(N2)。 空间复杂度 冒泡排序是稳定的算法，它满足稳定算法的定义。 算法稳定性 – 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！ 快速排序： 思想 时间复杂度： 空间复杂度： 选择排序： 思想： 代码演示： import java.util.*; public class SelectSort{ public static void main(String[] args){ int[] arr={11.553.23,45,26,95}; for(int i=0;i&lt;arr.length-1;i++){ int index =i; //标记第一个为待比较的数字 for(int j=i+1;j&lt;arr.length;j//然后从后面遍历与第一个数比较 if(arr[j]&lt;arr[index]){ index =j; } } //交换位置 int temp =arr[index]; arr[index] =arr[i]; arr[i]=temp; } System.out.println(Arrays.toString(arr)); } } 代码模板： class Solution{ public int[] arr = {11,22,366,8989,45}; SelectSort(arr); System.out.println(Arrays.toString(arr)); } private static void SelectSort(int[] arr){ } 时间复杂度： 空间复杂度： 插入排序：时间复杂度： 空间复杂度： 希尔排序：时间复杂度： 空间复杂度： 归并排序：时间复杂度： 空间复杂度： 计数排序：时间复杂度： 空间复杂度： 基数排序：时间复杂度： 空间复杂度： 堆排序：时间复杂度： 空间复杂度： 桶排序：时间复杂度： 空间复杂度： 思想： 代码思想演示：","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.luckyzmj.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.luckyzmj.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"计算机原理","slug":"计算机原理","permalink":"http://www.luckyzmj.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"},{"name":"排序算法","slug":"排序算法","permalink":"http://www.luckyzmj.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}]},{"title":"SpringBoot框架","slug":"编程语言框架/SpringBoot框架","date":"2022-06-21T15:07:01.000Z","updated":"2022-07-01T04:18:52.406Z","comments":true,"path":"posts/1c23133a.html","link":"","permalink":"http://www.luckyzmj.cn/posts/1c23133a.html","excerpt":"","text":"//即将更新，敬请期待","categories":[{"name":"引擎框架","slug":"引擎框架","permalink":"http://www.luckyzmj.cn/categories/%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.luckyzmj.cn/tags/JAVA/"},{"name":"SpringBoot框架","slug":"SpringBoot框架","permalink":"http://www.luckyzmj.cn/tags/SpringBoot%E6%A1%86%E6%9E%B6/"}]},{"title":"动态规划","slug":"计算机原理/动态规划","date":"2022-06-21T14:58:56.000Z","updated":"2022-07-01T04:18:52.422Z","comments":true,"path":"posts/a80d0031.html","link":"","permalink":"http://www.luckyzmj.cn/posts/a80d0031.html","excerpt":"","text":"//先画一个饼，有时间再不上。捂脸","categories":[{"name":"计算机原理","slug":"计算机原理","permalink":"http://www.luckyzmj.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.luckyzmj.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://www.luckyzmj.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"JAVA常用类","slug":"后端编程语言/JAVA常用类","date":"2022-06-21T14:12:34.000Z","updated":"2022-07-01T04:18:52.408Z","comments":true,"path":"posts/ee391c0.html","link":"","permalink":"http://www.luckyzmj.cn/posts/ee391c0.html","excerpt":"","text":"常用API：Arrays类：常用API： 常用API 释义 void sort(type[] a)void sort(type[] a, int fromIndex, int toIndex) 对 a 数组的数组元素进行排序。该方法仅仅对 fromIndex 到 toIndex 索引的元素进行排序。 void fill(type[] a, type val)void fill(type[] a, int fromIndex, int toIndex, type val) 将会把 a 数组的所有元素都赋值为 val。将 a 数组的 fromIndex 到 toIndex 索引的数组元素赋值为 val。 type[] copyOf(type[] original, int length)type[] copyOfRange(type[] original, int from, int to) original 数组复制成一个新数组，其中 length 是新数组的长度。只复制 original 数组的 from 索引到 to 索引的元素 int binarySearch(type[] a, type key)int binarySearch(type[] a, int fromIndex, int toIndex, type key) 二分法查询 key 元素值在 a 数组中出现的索引，如果 a 数组不包含 key 元素值，则返回负数。只搜索 a 数组中 fromIndex 到 toIndex 索引的元素。调用该方法时要求数组中元素己经按升序排列，这样才能得到正确结果。 代码示例； package Demo; import java.util.*; public class ArrayTest{ public static void main(String[] args){ } } Scanner类：import java.util.Scanner; 构造函数： Scanner scan = new Scanner(System.in); 常用API： 1. 接收键盘输入： String receive = scan.next(); int receive = scan.nextInt(); 2. 判断是否还有输入 if(scan.hasNext()){ String str1 =scan.next(); System.println(\"输入的数据为\" + str1); } 3. 关闭输入流：scan.close(); //偷学一招：接受键盘输入还有 BufferedInputStream in = new BufferedInputStream(System.in); int number = in.nextInt(); API用法辨析： next()与nextLine()区别： next(): 1、一定要读取到有效字符后才可以结束输入。 2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。 3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。 4. next() 不能得到带有空格的字符串。 nextLine()： 1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。 2、可以获得空白。 代码示例 import java.util.Scanner; class Demo{ public static void main(String[] args){ System.out.println(\"请输入数字\"); double sum = 0; int m = 0; while (scan.hasNextDouble()) { double x = scan.nextDouble(); m = m + 1; sum = sum + x; } System.out.println(m + \"个数的和为\" + sum); System.out.println(m + \"个数的平均值是\" + (sum / m)); scan.close(); } } Random类：import java.util.Random 构造函数： Random(random random); //代码示例 Random random = new Random(); Random(long seed); 使用一个long 代码示例 package demo; import java.util.*; public class Demo{ public static void main(String[] args){ Random random = new Random(); for(int i=0;i&lt;10;i++){ System.out.println(random.nextInt(100)); } //传入种子 Random random = new Random(13); for(int i=0;) } } Math类：常用API： 常用API 释义 abs(); //absolute 计算绝对值 sqrt(); //计算方根 random(); //生成一个0~1.0之间随机值 pow(); abs(); //absolute 计算绝对值 sqrt(); //计算方根 cell(a,b); random(); 生成一个0~1.0之间随机值 round(); pow(); //计算指数函数值 代码示例： package demo; import java.util.*; public class Demo{ public static void main(String[] args){ System.out.println(\"计算绝对值的结果: \" + Math.abs(-10)); System.out.println(\"求大于参数的最小整数: \" + Math.ceil(5.6)); System.out.println(\"求小于参数的最大整数: \" + Math.floor(-4.2)); System.out.println(\"对小数进行四舍五入后的结果: \" + Math.round(-4.6)); System.out.println(\"求两个数的较大值: \" + Math.max(2.1, -2.1)); System.out.println(\"求两个数的较小值: \" + Math.min(2.1, -2.1)); System.out.println(\"生成一个大于等于0.0小于1.0随机值: \" + Math.random()); System.out.println(\"开平方的结果: \"+Math.sqrt(4)); System.out.println(\"指数函数的值: \"+Math.pow(2, 3)); } } System类：常用API： 常用API 释义 (static void) gc(); //运行垃圾回收器，用于对垃圾进行回收。 (public void) exit() //退出虚拟机 (static Properities) getProperities()： //取得当前系统属性 (static String) getProperities() //获取指定键描述的系统属性。 (public void) currentTimeMills() //返回以毫秒的当前时间。 代码示例： package demo; import java.util.*; public class Demo{ public static void main(String[] args){ } } currentTimeMills(); long startTime = System.currentTimeMills(); int sum = 0; for(int i=0i&lt;10000000;i++){ sum+ =i; } long endTime = System.currentTimeMills(); System.out.println(\"系统操作所消耗的时间\" + endTime-startTime + \"毫秒\"); getProperities(); Properities properities = System.getProperities(); Enumeration propertyNames = properties.propertyNames(); while(propertyNames.hasMoreElements()){ //获取系统属性键key String key =(String)propertyNames.nextElement(); String value = System.getProperty(key); System.out.println(key + value); } RunTime类：import java.util.*; RunTime(runtime runtime); 构造函数： RunTime run = new RunTime(); 常用API： 常用API 释义 getRuntime() //返回当前应用程序操作对象 exec() //根据指定路径执行对应可执行文件 freeMemory()maxMemory() //返回java虚拟机中空闲内存量返回java虚拟机最大可用内存量 availiableProcessors() 返回当前虚拟机处理器个数 totalMemory() //返回java虚拟机内存总量 代码示例： Runtime rt = Runtime.getRuntime(); // 获取 System.out.println(\"处理器的个数: \" + rt.availableProcessors()+\"个\"); System.out.println(\"空闲内存数量: \" + rt.freeMemory() / 1024 / 1024 + \"M\"); System.out.println(\"最大可用内存数量: \" + rt.maxMemory() / 1024 / 1024 + \"M\"); System.out.println(\"虚拟机中内存总量: \" + rt.totalMemory() / 1024 / 1024 + \"M\"); 操作系统进程： try{ rt.exec(\"notepad.exe\"); }catch(Exception e){ e.printStackTrace(); } 关闭进程： Process process = rt.exec(\"notepad.exe\"); //得到表示进程的process对象 Thread.sleep(3000); process.destroy(); LocalTime类Date类：import java.util.Date; 构造函数： Date date = new Date(); 常用API： 常用API 释义 代码示例： package demo; import java.util.*; public class Demo{ public static void main(String[] args){ } } Duration类Applet类import java.applet.Applet; 播放音频：常用API： public void play(); public void loop(); public void stop(); 代码示例： package demo; import java.applet.*; import java.util.*; import java.net.*; public clas Demo{ public static void main(String[] args){ try{ File file = new File(\"\"); URI uri = file.toURI(); URL url = uri.toURL(); AudioClip clip = Applet.newAudioClip(url); clip.play(); } }catch(Exception e){ e.printStackTrace(); } } }","categories":[{"name":"后端编程语言","slug":"后端编程语言","permalink":"http://www.luckyzmj.cn/categories/%E5%90%8E%E7%AB%AF%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.luckyzmj.cn/tags/JAVA/"},{"name":"常用API","slug":"常用API","permalink":"http://www.luckyzmj.cn/tags/%E5%B8%B8%E7%94%A8API/"}]},{"title":"Mysql测试","slug":"后端编程语言/Mysql测试","date":"2022-06-20T03:29:59.000Z","updated":"2022-07-01T04:18:52.412Z","comments":true,"path":"posts/b5ac0bed.html","link":"","permalink":"http://www.luckyzmj.cn/posts/b5ac0bed.html","excerpt":"","text":"Mysql整理通用语法及分类： DDL: 数据定义语言，用来定义数据库对象（数据库、表、字段） DML: 数据操作语言，用来对数据库表中的数据进行增删改 DQL: 数据查询语言，用来查询数据库中表的记录 DCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限 数据定义语句（DDL）：数据库操作 登录数据库：mysql -uroot -proot 创建数据库：create database test 查看所有数据库：show databases 使用数据库：use test 查看所有数据表：show tables 删除数据库：drop database test 表操作 创建表：create table emp(ename varchar(10),hiredate date,sal decimal(10,2),deptno int(2)) create table dept(deptno int(2),deptname varchar(10)) 查看表的定义：desc emp 查看表定义（详细）：show create table emp \\G 删除表：drop table emp 修改表字段：alter table emp modify ename varchar(20) 添加表字段：alter table emp add column age int(3) 删除表字段：alter table emp drop column age 字段改名；alter table emp change age age1 int(4) 修改表名：alter table emp rename emp1 注意事项： 数据操纵语句(DML)Crud增删查改： 指定名称插入：insert into emp (ename,hiredate,sal,deptno) values (‘zhangsan’,’2018-01-01’,’2000’,1) 不指定名称插入：insert into emp values (‘lisi’,’2018-01-01’,’2000’,1) 批量插入数据：insert into dept values(1,’dept1’),(2,’dept2’) 插入记录 update emp set sal=’4000’,deptno=2 where ename=’zhangsan’ 删除记录 delete from emp where ename=’zhangsan’ 查询记录 查询所有记录：select from emp 查询不重复的记录：select distinct deptno from emp 条件查询：select * from emp where deptno=1 and sal&lt;3000 排序和限制：select * from emp order by deptno desc limit 2 聚合(查询部门人数大于1的部门编号)：select deptno,count(1) from emp group by deptno having count(1) &gt; 1 连接查询：select * from emp e left join dept d on e.deptno=d.deptno 子查询：select * from emp where deptno in (select deptno from dept) 记录联合：select deptno from emp union select deptno from dept 代码示例： 数据控制语句(DCL) 授予操作权限：grant select,insert on test.* to ‘test’@’localhost’ identified by ‘123’ 收回操作权限：revoke insert on test.* from ‘test’@’localhost’ 代码示例： -- 创建用户test，只能在当前主机localhost访问 create user 'test'@'localhost' identified by '123456'; -- 创建用户test，能在任意主机访问 create user 'test'@'%' identified by '123456'; create user 'test' identified by '123456'; -- 修改密码 alter user 'test'@'localhost' identified with mysql_native_password by '1234'; -- 删除用户 drop user 'test'@'localhost'; 数据查询语言(DQL)常用API：字符串函数： 函数 功能 CONCAT(s1, s2, …, sn) 字符串拼接，将s1, s2, …, sn拼接成一个字符串 LOWER(str) 将字符串全部转为小写 UPPER(str) 将字符串全部转为大写 LPAD(str, n, pad) 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 RPAD(str, n, pad) 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 TRIM(str) 去掉字符串头部和尾部的空格 SUBSTRING(str, start, len) 返回从字符串str从start位置起的len个长度的字符串 使用示例： -- 拼接 SELECT CONCAT('Hello', 'World'); -- 小写 SELECT LOWER('Hello'); -- 大写 SELECT UPPER('Hello'); -- 左填充 SELECT LPAD('01', 5, '-'); -- 右填充 SELECT RPAD('01', 5, '-'); -- 去除空格 SELECT TRIM(' Hello World '); -- 切片（起始索引为1） SELECT SUBSTRING('Hello World', 1, 5); 数值函数常见函数： 函数 功能 CEIL(x) 向上取整 FLOOR(x) 向下取整 MOD(x, y) 返回x/y的模 RAND() 返回0~1内的随机数 ROUND(x, y) 求参数x的四舍五入值，保留y位小数 日期函数常用函数： 函数 功能 CURDATE() 返回当前日期 CURTIME() 返回当前时间 NOW() 返回当前日期和时间 YEAR(date) 获取指定date的年份 MONTH(date) 获取指定date的月份 DAY(date) 获取指定date的日期 DATE_ADD(date, INTERVAL expr type) 返回一个日期/时间值加上一个时间间隔expr后的时间值 DATEDIFF(date1, date2) 返回起始时间date1和结束时间date2之间的天数 例子： -- DATE_ADD SELECT DATE_ADD(NOW(), INTERVAL 70 YEAR); 流程函数常用函数： 函数 功能 IF(value, t, f) 如果value为true，则返回t，否则返回f IFNULL(value1, value2) 如果value1不为空，返回value1，否则返回value2 CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END 如果val1为true，返回res1，… 否则返回default默认值 CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END 如果expr的值等于val1，返回res1，… 否则返回default默认值 例子： select name, (case when age &gt; 30 then '中年' else '青年' end) from employee; select name, (case workaddress when '北京市' then '一线城市' when '上海市' then '一线城市' else '二线城市' end) as '工作地址' from employee; 约束：查询： 一对多（多对一） 多对多 一对一 一对多 案例：部门与员工关系：一个部门对应多个员工，一个员工对应一个部门实现：在多的一方建立外键，指向一的一方的主键 多对多 案例：学生与课程关系：一个学生可以选多门课程，一门课程也可以供多个学生选修实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键 一对一 案例：用户与用户详情关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE） 内连接查询内连接查询的是两张表交集的部分 隐式内连接：SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...; 显式内连接：SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...; 显式性能比隐式高 例子： -- 查询员工姓名，及关联的部门的名称 -- 隐式 select e.name, d.name from employee as e, dept as d where e.dept = d.id; -- 显式 select e.name, d.name from employee as e inner join dept as d on e.dept = d.id; 外连接查询外连接查询左外连接：查询左表所有数据，以及两张表交集部分数据SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;相当于查询表1的所有数据，包含表1和表2交集部分数据 右外连接：查询右表所有数据，以及两张表交集部分数据SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...; 例子： -- 左 select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id; select d.name, e.* from dept d left outer join emp e on e.dept = d.id; -- 这条语句与下面的语句效果一样 -- 右 select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id; 左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept 自连接查询当前表与自身的连接查询，自连接必须使用表别名 语法：SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...; 自连接查询，可以是内连接查询，也可以是外连接查询 例子： -- 查询员工及其所属领导的名字 select a.name, b.name from employee a, employee b where a.manager = b.id; -- 没有领导的也查询出来 select a.name, b.name from employee a left join employee b on a.manager = b.id; 联合查询联合查询 union, union all把多次查询的结果合并，形成一个新的查询集 语法： SELECT 字段列表 FROM 表A ... UNION [ALL] SELECT 字段列表 FROM 表B ... 注意事项 UNION ALL 会有重复结果，UNION 不会 联合查询比使用or效率高，不会使索引失效 子查询SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个 根据子查询结果可以分为： 标量子查询（子查询结果为单个值） 列子查询（子查询结果为一列） 行子查询（子查询结果为一行） 表子查询（子查询结果为多行多列） 根据子查询位置可分为： WHERE 之后 FROM 之后 SELECT 之后 标量子查询子查询返回的结果是单个值（数字、字符串、日期等）。常用操作符：- &lt; &gt; &gt; &gt;= &lt; &lt;= 例子： -- 查询销售部所有员工 select id from dept where name = '销售部'; -- 根据销售部部门ID，查询员工信息 select * from employee where dept = 4; -- 合并（子查询） select * from employee where dept = (select id from dept where name = '销售部'); -- 查询xxx入职之后的员工信息 select * from employee where entrydate &gt; (select entrydate from employee where name = 'xxx'); 列子查询返回的结果是一列（可以是多行）。 常用操作符： 操作符 描述 IN 在指定的集合范围内，多选一 NOT IN 不在指定的集合范围内 ANY 子查询返回列表中，有任意一个满足即可 SOME 与ANY等同，使用SOME的地方都可以使用ANY ALL 子查询返回列表的所有值都必须满足 例子： -- 查询销售部和市场部的所有员工信息 select * from employee where dept in (select id from dept where name = '销售部' or name = '市场部'); -- 查询比财务部所有人工资都高的员工信息 select * from employee where salary &gt; all(select salary from employee where dept = (select id from dept where name = '财务部')); -- 查询比研发部任意一人工资高的员工信息 select * from employee where salary &gt; any (select salary from employee where dept = (select id from dept where name = '研发部')); 行子查询返回的结果是一行（可以是多列）。常用操作符：=, &lt;, &gt;, IN, NOT IN 例子： -- 查询与xxx的薪资及直属领导相同的员工信息 select * from employee where (salary, manager) = (12500, 1); select * from employee where (salary, manager) = (select salary, manager from employee where name = 'xxx'); 表子查询返回的结果是多行多列常用操作符：IN 例子： -- 查询与xxx1，xxx2的职位和薪资相同的员工 select * from employee where (job, salary) in (select job, salary from employee where name = 'xxx1' or name = 'xxx2'); -- 查询入职日期是2006-01-01之后的员工，及其部门信息 select e.*, d.* from (select * from employee where entrydate &gt; '2006-01-01') as e left join dept as d on e.dept = d.id; 事务：事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。 基本操作： -- 1. 查询张三账户余额 select * from account where name = '张三'; -- 2. 将张三账户余额-1000 update account set money = money - 1000 where name = '张三'; -- 此语句出错后张三钱减少但是李四钱没有增加 模拟sql语句错误 -- 3. 将李四账户余额+1000 update account set money = money + 1000 where name = '李四'; -- 查看事务提交方式 SELECT @@AUTOCOMMIT; -- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效 SET @@AUTOCOMMIT = 0; -- 提交事务 COMMIT; -- 回滚事务 ROLLBACK; -- 设置手动提交后上面代码改为： select * from account where name = '张三'; update account set money = money - 1000 where name = '张三'; update account set money = money + 1000 where name = '李四'; commit; 操作方式二： 开启事务：START TRANSACTION 或 BEGIN TRANSACTION;提交事务：COMMIT;回滚事务：ROLLBACK; 操作实例： start transaction; select * from account where name = '张三'; update account set money = money - 1000 where name = '张三'; update account set money = money + 1000 where name = '李四'; commit; 四大特性ACID 原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败 一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态 隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行 持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的 并发事务 问题 描述 脏读 一个事务读到另一个事务还没提交的数据 不可重复读 一个事务先后读取同一条记录，但两次读取的数据不同 幻读 一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在 这三个问题的详细演示：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd 并发事务隔离级别： 隔离级别 脏读 不可重复读 幻读 Read uncommitted √ √ √ Read committed × √ √ Repeatable Read(默认) × × √ Serializable × × × √表示在当前隔离级别下该问题会出现 Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差 查看事务隔离级别：SELECT @@TRANSACTION_ISOLATION;设置事务隔离级别：SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE };SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效 SQL底层逻辑理解存储引擎 特点 InnoDB MyISAM Memory 存储限制 64TB 有 有 事务安全 支持 - - 锁机制 行锁 表锁 表锁 B+tree索引 支持 支持 支持 Hash索引 - - 支持 全文索引 支持（5.6版本之后） 支持 - 空间使用 高 低 N/A 内存使用 高 低 中等 批量插入速度 低 高 高 支持外键 支持 - - 在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。 InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择 MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。 Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性 电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。 InnoDBMyISAMMemory性能分析：查看执行频次慢查询日志Profileexplain索引SQL优化插入数据主键优化order by优化group by优化limit优化count优化update（避免行锁升级为表锁）","categories":[{"name":"后端编程语言","slug":"后端编程语言","permalink":"http://www.luckyzmj.cn/categories/%E5%90%8E%E7%AB%AF%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://www.luckyzmj.cn/tags/Mysql/"}]},{"title":"JAVA集合与泛型","slug":"后端编程语言/JAVA集合与泛型","date":"2022-06-19T01:46:41.000Z","updated":"2022-07-01T04:18:52.414Z","comments":true,"path":"posts/83eb274c.html","link":"","permalink":"http://www.luckyzmj.cn/posts/83eb274c.html","excerpt":"","text":"JAVA集合与泛型：import java.util.*; 集合优点： 降低编程难度 提高程序性能 提高API间的互操作性 降低学习难度 降低设计和实现相关API的难度 增加程序的重用性 JAVA容器里只能放对象，对于基本类型（int long float\\double）需要包装成对象类型才能放到容器里。很多时候拆包装和解包能够自动完成，虽然会导致额外性能和空间开销，但简化了设计和编程。 Collection：集合集合框架继承体系： 常用API 释义 boolean add(E e)boolean addAll(Collection&lt;? extends E&gt; c) //向集合添加元素e，若指定集合元素改变了则返回true//把集合C中的元素全部添加到集合中，若指定集合元素改变返回true boolean contains(Object o)boolean containsAll(Collection&lt;?&gt; c) 判断指定集合是否包含对象o//判断指定集合是否包含集合c的所有元素 boolean remove(Object o)boolean removeAll(Collection&lt;?&gt; a）void clear() //删除集合中的元素对象o,若集合有多个o元素，则只会删除第一个元素//删除指定集合包含集合c的元素//清空所有集合元素 boolean isEmpty()boolean retainAll(Collection&lt;?&gt; c) //判断指定集合的元素size是否为0//从指定集合中保留包含集合c的元素,其他元素则删除 int size() 集合的元素个数 T[] toArray(T[] a) 将集合转换为T类型的数组 Intertor接口：主要方法 .next()：返回迭代器的下一个元素，并更新迭代器状态 .hasNext()：用于检测集合中是否还有其他元素 .remove()：将迭代器返回的元素删除。 循环集合元素：while(it.hasNext()){} 优点：不用担心遍历过程中会超出集合超度而报错。 代码示例 package demo; import java.util.*; public class LinkedHashSetDemo { public static void main(String[] args) { ArrayList&lt;Integer&gt; numbers = new ArrayList&lt;Integer&gt;(); numbers.add(12); numbers.add(8); numbers.add(2); numbers.add(23); Iterator&lt;Integer&gt; it = numbers.iterator(); while(it.hasNext()) { Integer i = it.next(); if(i &lt; 10) { it.remove(); // 删除小于 10 的元素 } } System.out.println(numbers); } } Set集合：常用API：继承于Collection Set集合特点：无序且不可重复 无序：添加的顺序和迭代的顺序可能不一致，无序不代表随机，元素没有对应的下标，不能通过像传统for循环来通过下标遍历元素 不可重复：每个元素都是互不相等的 构造函数： 构造函数名称 释义 子类Set() 使用默认容量和 loadFactor 参数构造默认 TreeSet。 子类Set (int capacity) 子类Set (int capacity, float loadFactor) 在 Java 中构造一个具有初始容量值的 TreeSet，该容量值可以自动增加。 子类Set (Collection c) 构造一个TreeSet 并使用集合 C 中的元素对其进行初始化。 TreeSet：构造函数 构造函数名称 释义 TreeSet() 使用默认容量和 loadFactor 参数构造默认 TreeSet。 TreeSet (int capacity)TreeSet (int capacity, float loadFactor) 在 Java 中构造一个具有初始容量值的 TreeSet，该容量值可以自动增加。 TreeSet (Collection c) 构造一个TreeSet 并使用集合 C 中的元素对其进行初始化。 常用API：继承于Collection集合 代码示例： package demo; import java.util.*; public class LinkedHashSetDemo { public static void main(String[] args) { Set treeset = new TreeSet&lt;&gt;(); //structMethod1(); //structMethod2(); structMethod3(); treeset.add(1); treeset.add(5); Iterator it = treeset.iterator(); while(it.hasNext()) { Object next = it.next(); System.out.println(next); } } private static void structMethod1() { Collection arraylist = new ArrayList(); arraylist.add(11); arraylist.add(55); arraylist.add(33); Set treeset1 = new TreeSet(arraylist); System.out.println(treeset1); } private static void structMethod2() { TreeSet treeSet2 = new TreeSet&lt;&gt;(new Comparator&lt;Integer&gt;() { @Override public int compare(Integer num1, Integer num2) { return num2-num1; } }); treeSet2.add(1); treeSet2.add(3); treeSet2.add(2); System.out.println(treeSet2); } private static void structMethod3() { SortedSet s = new TreeSet(new Comparator&lt;Integer&gt;() { @Override public int compare(Integer first, Integer second) { return second-first; } }); TreeSet treeSet3 = new TreeSet&lt;&gt;(s); treeSet3.add(11); treeSet3.add(55); treeSet3.add(33); System.out.println(treeSet3); } } HashSet：构造函数： 构造函数名称 释义 HashSet() 使用默认容量和 loadFactor 参数构造默认 HashSet。 HashSet (int capacity) HashSet (int capacity, float loadFactor) 在 Java 中构造一个具有初始容量值的 HashSet，该容量值可以自动增加。 HashSet (Collection c) 构造一个 HashSet 并使用集合 C 中的元素对其进行初始化。 常用API：继承于Collection接口 代码示例： package demo; import java.util.*; class GalCharacters{ private String name; private String sex; private String dialog; public GalCharacters(String name, String sex, String dialog) { this.name = name; this.sex = sex; this.dialog = dialog; } } public class LinkedHashSetDemo{ public static void main(String[] args) { Set hashset = new HashSet&lt;GalCharacters&gt;(); GalCharacters xinling = new GalCharacters(\"杏铃\",\"女\",\"呀呀呀！\"); GalCharacters ningning = new GalCharacters(\"绫地宁宁\",\"女\",\"宁宁起爆器\"); GalCharacters minglaibaiyu = new GalCharacters(\"鸣濑白羽\",\"女\",\"烦色特了！\"); hashset.add(xinling); hashset.add(ningning); hashset.add(minglaibaiyu); Iterator it =hashset.iterator(); while(it.hasNext()) { Object next =it.next(); System.out.println(next); } } } LinkedHashSet构造函数： 构造函数名称 释义 LinkedHashSet() 使用默认容量和 loadFactor 参数构造默认 TreeSet。 LinkedHashSet (int capacity) LinkedHashSet (int capacity, float loadFactor) 在 Java 中构造一个具有初始容量值的 TreeSet，该容量值可以自动增加。 LinkedHashSet (Collection c) 构造一个TreeSet 并使用集合 C 中的元素对其进行初始化。 常用API：继承于Collection类方法 代码示例： package demo; import java.util.*; public class LinkedHashSetDemo{ public static void main(String[] args){ Set linkedHashSet = new LinkedHashSet(); List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(); arrayList.add(\"测试元素一\"); arrayList.add(\"测试元素二\"); //其余三种构造方法 Set linkedHashSet1 = new LinkedHashSet(arrayList); Set linkedHashSet2 = new LinkedHashSet(32); Set linkedHashSet3 = new LinkedHashSet(32,0.8f); linkedHashSet2.add(\"鹰仓杏铃); linkedHashSet2.add(\"姬野星奏\"); linkedHashSet2.add(\"鸣濑白羽\"); Iterator iterator = linkedHashSet2.iterator(); while(iterator.hasNext()){ Object next = iterator.next(); System.out.println(next); } } Map集合：常用API： 常用API 释义 void get(Object key) 返回Map集合中指定键对象所对应的值 V put(K key, value va)void putAll(map m); 向Map集合中添加键-值对，返回key以前对应value，如果没有则返回null。 void remove(Object key)void removeAll(object key)void clear(); //从Map集合中删除key对应键-值对，返回key对应的value，如没有则返回null Set entrySet()Set keySet() //返回 Map 集合中所有键-值对的 Set 集合，此 Set 集合中元素的数据类型为 Map.Entry返回 Map 集合中所有键对象的 Set 集合 boolean containsKey();boolean containsValueboolean is Empty(); 中是否存在指定的 key 对应的映射关系。中是否存在指定的 value 对应的映射关系。 int size 返回该 Map 里 key-value 对的个数 元素遍历： package demo; import java.util.*; public class HashMapDemo { public static void main(String[] args) { Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(\"1\", \"value1\"); map.put(\"2\", \"value2\"); map.put(\"3\", \"value3\"); Method1(map); Method2(map); Method3(map); Method4(map); } private static void Method1(Map&lt;String, String&gt; map) { System.out.println(\"通过Map.keySet遍历key和value：\"); for (String key : map.keySet()) { System.out.println(\"key= \"+ key + \" and value= \" + map.get(key)); } } private static void Method2(Map&lt;String,String&gt; map) { System.out.println(\"通过Map.entrySet使用iterator遍历key和value：\"); Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) { Map.Entry&lt;String, String&gt; entry = it.next(); System.out.println(\"key= \" + entry.getKey() + \" and value= \" + entry.getValue()); } } private static void Method3(Map&lt;String,String&gt; map) { System.out.println(\"通过Map.entrySet遍历key和value\"); for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) { System.out.println(\"key= \" + entry.getKey() + \" and value= \" + entry.getValue()); } } private static void Method4(Map&lt;String,String&gt; map) { System.out.println(\"通过Map.values()遍历所有的value，但不能遍历key\"); for (String v : map.values()) { System.out.println(\"value= \" + v); } } } 选择合适的Map？ HashMap可实现快速储存和检索，但其缺点是包含的元素是无序的，这就导致存在大量迭代的情况下表现不佳，项目实操中用于空间复杂度换取时间复杂度。 LinkedHashMap保留了HashMap的优势，且其包含的元素是有序的。它在有大量迭代的情况下表现更好。 TreeMap能便捷的实现对其内部元素的各种排序，但其一般性能比前两种map差。 HashMap构造函数： HashMap(); HashMap(int initialCapacity); HashMap(int initialCapacity,float loadFactor); HashMap(Map&lt;? extends K,? extends V&gt; m); //代码示例 HashMap&lt;Integer,String&gt; mao = new HashMap&lt;Integer,String&gt;(); 常用API： 常用API 释义 void containsKey();void containsValue hashMap 中是否存在指定的 key 对应的映射关系。hashMap 中是否存在指定的 value 对应的映射关系。 void replace();void replaceAll(); 获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值 void get();void getOrDefault(); 获取指定 key 对应对 value获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值 void comput();void computAbsent();void computePresent(); 对 hashMap 中指定 key 的值进行重新计算对 hashMap 中指定 key 的值进行重新计算，如果不存在这个 key，则添加到 hasMap 中对 hashMap 中指定 key 的值进行重新计算，前提是该 key 存在于 hashMap 中。 void merge(key,value,remappingFunction); 如果 key 对应的 value 不存在，则返回该 value 值，如果存在，则返回通过 remappingFunction 重新计算后的值。 void size(); 计算 hashMap 中键/值对的数量 boolean isEmpty(); 判断 hashMap 是否为空 代码示例： package demo; import java.util.*; public class HashMapDemo { public static void main(String[] args) { Map&lt;String,String&gt; hashmap = new HashMap&lt;&gt;(); hashmap.put(\"11\", \"JAVA\"); hashmap.put(\"22\", \"C#\"); hashmap.put(\"33\", \"Python\"); Iterator&lt;String&gt; it =hashmap.keySet().iterator(); while(it.hasNext()) { Object key = it.next(); Object val = hashmap.get(key); System.out.println(\"编号\" + key +\"编程语言\" + val); } Scanner scan = new Scanner(System.in); System.out.println(\"请输入删除的编号\"); int choice = scan.nextInt(); //查询 if(hashmap.containsKey(String.valueOf(choice))) { hashmap.remove(String.valueOf(choice)); }else { System.out.println(\"该书籍不存在\"); } System.out.println(\"删除后的编号\"); it=hashmap.keySet().iterator(); while(it.hasNext()) { Object key = it.next(); Object val = hashmap.get(key); System.out.println(\"编号\" + key + \"编程语言\" + val); } } } TreeMap构造方法： TreeMap(); 1. TreeMap(Comparator comparator); //按照指定的comparator排序 2. TreeMap(Map m); //由给定的map创建一个TreeMap，keys按照自然排序 3. TreeMap(SortedMap m); //由给定的有序map创建TreeMap，keys按照原顺序排序。 //代码示例 1. //=========================TreeMap(Comparator comparator);====================== TreeMap&lt;Integer, String&gt; map = new TreeMap&lt;&gt;(Comparator.reverseOrder()); 2. //===============================TreeMap(Map m);================================ Map&lt;Integer,String&gt; map = new HashMap&lt;&gt;(); map.put(1,\"测试文字\"); TreeMap&lt;Integer,String&gt; treemap = new TreeMap&lt;map&gt;(); 常用API 释义 Map.Entry&lt;K,V&gt; firstEntryMap.Entry&lt;K,V&gt; lastEntry 返回该TreeMap的第一个（最小的）映射返回该TreeMap的最后一个（最大的）映射 k fistKey();k lastKey(); 返回该TreeMap的第一个（最小的）映射的key返回该TreeMap的最后一个（最大的）映射的key SortedMap&lt;K,V&gt; headMap(K toKey);SortedMap&lt;K,V&gt; 返回该TreeMap中严格小于指定key的映射集合返回该TreeMap中指定范围的映射集合（大于等于fromKey，小于toKey） Comparator&lt;? super k&gt; comparator(); 返回给该TreeMap的keys排序的comparator，若为自然排序则返回null 遍历接口： 遍历接口 释义 void forEach(BiConsumer&lt;? super K,? super V&gt; action) 对该TreeMap中的每一个映射执行指定操作 Set&lt;Map&lt;K, V&gt;&gt; entrySet() 返回由该TreeMap中的所有映射组成的Set对象 Collection values() 返回由该TreeMap中所有的values构成的集合 代码示例： package 集合与泛型练习; import java.util.*; class Goods { String name; int salary; public Goods(String name, int salary) { super(); this.name = name; this.salary = salary; } } class MyComparator implements Comparator&lt;Goods&gt;{ @Override public int compare(Goods o1, Goods o2) { return o1.salary - o2.salary; } } public class LinkedHashSetDemo { public static void main(String[] args){ MyComparator comparator = new MyComparator(); TreeMap&lt;Goods,String&gt; tree = new TreeMap&lt;Goods,String&gt;(comparator); tree.put(new Goods(\"生瓜蛋子\",2000),\"001\"); tree.put(new Goods(\"老坛酸菜牛肉面\",4000),\"002\"); tree.put(new Goods(\"双汇火腿肠\",7000),\"003\"); tree.put(new Goods(\"干净又喂牲\",29000),\"004\"); for(Goods key:tree.keySet()) { System.out.println(\"键值 \" + key + \"对应值\" + tree.get(key)); } } } HashTable构造函数： HashTable(); HashTable(int initialCapacity); HashTable(int initialCapacity,float loadFactor); HashTable(Map&lt;? extends K,? extends V&gt; m); 常用API：继承部分HashMap方法 常用API 释义 protected void rehash() 增加这个散列表的内部重组能力，从而更有效地适应和访问其条目。 V putIfAbsent(K key, V value) 如果指定的键尚未与值相关联（或映射到 null ）将其与给定值相关联并返回 null ，否则返回当前值。 V merge(K key, V value, BiFunction&lt;? super V,? super V,? extends V&gt; remappingFunction) 如果指定的键尚未与值相关联或与null相关联，则将其与给定的非空值相关联。 Enumeration keys() Enumeration elements() 返回此散列表中键的枚举。 返回HashTable中value的枚举。 int hashCode() 按照Map界面中的定义返回此Map的哈希码值。 V put(K key, V value)void putAll(Map&lt;? extends K,? extends V&gt; t)V putIfAbsent(K key, V value) 将指定的 key映射到此 key value中指定的value。将所有从指定地图的映射复制到此散列表。如果指定的键尚未与值相关联（或映射到 null ）将其与给定值相关联并返回 null ，否则返回当前值。 代码示例： package demo; import java.util.*; public class HashTableDemo { public static void main(String args[]) { Hashtable&lt;Integer, String&gt; hash_table = new Hashtable&lt;Integer, String&gt;(); hash_table.put(10, \"背背背起了行囊\"); hash_table.put(15, \"离开家的那一刻\"); hash_table.put(20, \"我知道现实生活有太多不舍\"); hash_table.put(25, \"假如你看到了我\"); hash_table.put(30, \"也不要太过冷漠\"); System.out.println(\"初始值为 \" + hash_table); System.out.println(\"25号元素为 \" + hash_table.get(25)); System.out.println(\"10号元素为 \" + hash_table.get(10)); } } LinkedHashMap构造方法： LinkedHashMap(); LinkedHashMap(int initialCapacity); LinkedHashMap(int initialCapacity,float loadFactor); LinkedHashMap(Map&lt;? extends K,? extends V&gt; m); //构造方法 LinkedHashMap linked = new LinkedHashMap(5,0.5f); 常用API：继承父类Map集合 代码示例： package 集合与泛型练习; import java.util.LinkedHashMap; import java.util.Set; public class LinkedHashMapDemo { public static void main(String[] args) { LinkedHashMap&lt;String, String&gt; linked = new LinkedHashMap&lt;String, String&gt;(); // 创建并添加元素 linked.put(\"2345\", \"hello\"); linked.put(\"1234\", \"world\"); linked.put(\"3456\", \"java\"); linked.put(\"1234\", \"javaee\"); linked.put(\"3456\", \"android\"); // 遍历 Set&lt;String&gt; set = linked.keySet(); for (String key : set) { String value = linked.get(key); System.out.println(key + \"---\" + value); } } } List集合选择合适的List？对数组查询次数多：ArrayList 对数组修改次数多：LinkedList 数组线程安全：Vector 常用API： 常用API 释义 void add(int index, Object obj)boolean addAll(int index, Collection c) 链表末尾添加元素，返回是否成功 public E get(int index); 返回集合中指定位置的元素。 int indexOf(object obj)int lastIndexOf(Object obj) 返回调用列表obj的第一个（最后一个）实例的索引。如果obj不是列表中的一个元素，则返回-1。 public E set(int index,E element) 用指定元素替换集合中指定位置的元素，返回值的更新前的元素。 ArrayList基于动态数组实现，支持随机访问 优点：底层数据结构是数组，查询快，增删慢 缺点：线程不安全，效率高。 构造函数： ArrayList(); //代码示例 ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); 常用API 释义 public void addFirst(E e):public void addLast(E e)public void addpush(E e): 将指定元素插入此列表的开头将指定元素添加到此列表的结尾将元素推如此列表所表示的推栈 public E getFirst():public E getLast() 返回此列表的第一个（最后一个元素）元素 public E removeFirst()public E removeLast(): 移除并返回此列表的第一个元素（最后一个元素） ublic boolean isEmpty(): 如果列表不包含元素，则返回true 代码示例 package 集合与泛型练习; import java.util.*; class Student{ private String name; private String id; public Student(String name,String id) { this.name=name; this.id=id; } } public class ArrayListDemo { public static void main(String[] args) { List&lt;Student&gt; list = new ArrayList(); Student one = new Student(\"学生名字\",\"学号\"); Student two = new Student(\"学生名字2\",\"学号设置\"); list.add(one); list.add(two); Iterator it =list.iterator(); while(it.hasNext()) { Object obj = it.next(); System.out.println(obj); } } } Vector优点：底层数据结构是数组，查询快，增删慢 缺点：线程安全但效率低 构造方法： Vector(); Vector(int size); Vector(int size,int increaseNumber); Vector(Collection c); //代码示例 Vector vector = new Vector(10,2); 常用API： 常用API 释义 add(int index,Object element)add(object e)addAll(Collection c);addAll(int index,Collection c);addElement(Object obj) 将指定的组件添加到此向量的末尾，将其大小增加 1在此向量的（指定位置）插入指定的元素。将指定 Collection 中的所有元素添加到此向量的末尾，按照指定 collection 的迭代器所返回的顺序添加这些元素。在指定位置将指定 Collection 中的所有元素插入到此向量中。 Object elementAt(index); 返回指定索引处的组件。 Enumeration elements(); 返回此向量的组件的枚举 Object remove(int index)boolean remove(Object o)boolean removeAll(Collection c)void removeAllElements()boolean removeElement(Object obj)void removeElementAt(int index) //删除指定index元素//移除此向量中指定元素的第一个匹配项，如果向量不包含该元素，则元素保持不变。从此向量中移除包含在指定 Collection 中的所有元素。从此向量中移除全部组件，并将其大小设置为零。 Object set(int index, Object element)void setElementAt(Object obj, int index) //用指定的元素替换此向量中指定位置处的元素。将此向量指定 index 处的组件设置为指定的对象。 代码示例： package demo; import java.util.*; public class GenericTest { public static void main(String[] args) { Vector vector = new Vector(3,2); System.out.println(\"初始大小为\" +vector.size()); System.out.println(\"初始容量为\" + vector.capacity()); vector.add(1); vector.add(2); vector.add(3); vector.add(56); System.out.println(\"添加元素后当前Vector容量为\" + vector.capacity()); vector.addElement(new Double(1.2)); vector.addElement(new String(\"测试字符串\")); vector.addElement(new Integer(5656)); vector.addElement(new Character('E')); if(vector.contains(new String(\"测试字符串\"))) { vector.remove(new String(\"测试字符串\")); } Enumeration num = vector.elements(); while(num.hasMoreElements()) { System.out.println(num.nextElement() + \"\"); System.out.println(); } } } LinkedList：基于双向链表实现，快速在链表中间插入和删除元素。LinkedList 还可以用作栈、队列和双向队列 优点：底层数据结构是链表，查询慢，增删快 缺点：线程不安全但效率高 LinkedList(); LinkedList（Collection&lt;? extends E&gt; c） //按照集合的迭代器返回的顺序构造一个包含指定集合元素的列表。 //代码示例 LinkedList list = new LinkedList(); 常用API： 常用API 释义 addFirst(E e) addLast(E e) offer(E e) offerFirst(E e) offerLast(E e) 元素添加到头部（尾部）向链表末尾添加元素，返回是否成功，成功为 true，失败为 false。头部（尾部）插入元素，返回是否成功，成功为 true，失败为 false。 poll() pollFirst() pollLast(); removeFirst() removeLast(); JDK1.6新更新内容，删除并返回第一个元素删除并返回第一个元素删除并返回最后一个元素 set (int index, E element) 设置指定位置的元素。 element()getFirst() getLast()indexOf(Object o) lastIndexOf(Object o)peek() peekFirst() peekLast() 返回第一个元素。返回第一个元素。返回最后一个元素查找指定元素从前往后第一次出现的索引。查找指定元素最后一次出现的索引。返回第一个元素。返回头部（尾部）元素。 代码示例： package demo; import java.util.*; class Goods{ private int id; private String name; private float price; public Goods(int id, String name, float price) { this.name = name; this.id = id; this.price = price; } public String toString() { return\"商品编号\" + id +\",名称：\" + name + \",价格\" + price; } } public class ArrayListDemo { public static void main(String[] args) { List&lt;Goods&gt; list =new LinkedList&lt;Goods&gt;(); Goods rsq = new Goods(4,\"热水器\",10); Goods watermelon = new Goods(5,\"生瓜蛋子\",15); Goods toplap = new Goods(6,\"笔记本电脑\",23); list.add(watermelon); list.add(toplap); list.add(rsq); System.out.println(\"*****商品信息********\"); for(int i=0;i&lt;list.size();i++) { Goods goods = (Goods)list.get(i); System.out.println(goods); } System.out.println(\"首个商品为\" + ((LinkedList&lt;Goods&gt;) list).getFirst()); System.out.println(\"末尾商品为\" + ((LinkedList&lt;Goods&gt;) list).getLast()); } } Generic：泛型泛型定义：本质上是参数化类型，也就是说操作的数据类型被指定为一个参数。将类型由原来的具体的类型参数化，然后在使用或者调用时传入具体类型。这种参数可以用在类、方法、接口中被称作为泛型类、泛型方法、泛型接口。 泛型定义格式： &lt;类型&gt;：指定一种类型的格式。这里的类型可以看成是形参。 &lt;类型1,类型2…&gt;：指定多种类型的格式，多种类型用逗号隔开，这里的类型可以看成是形参。 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。 使用泛型好处： 避免了强制类型转换 运行使其的问题提前到了编译期间。 Java中泛型标记符含义： E - Element (在集合中使用，因为集合中存放的是元素) T - Type（Java 类） K - Key（键） V - Value（值） N - Number（数值类型） ？ - 表示不确定的 java 类型 类型通配符 类型通配符：&lt; ?&gt; 类型通配符用?代替具体类型实参的父类，它的元素可以匹配任何类型 带通配符的List仅仅表示他是各种类型的父类，并不能把元素添加到其中。 通配符上限： 类型通配符上限：&lt; ? extends 类型&gt; List&lt;? extends Number&gt;：表示的类型是Number或者其子类型 通配符下限： 类型通配符下限：&lt;?super类型&gt; List&lt;?super Number&gt;：表示的类型是Number或者其父类型 例如： package demo; import java.util.*; public class Demo{ public static void main(String[] args){ List&lt;String&gt; name = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; age = new ArrayList&lt;Integer&gt;(); List&lt;Number&gt; number = new ArrayList&lt;Number&gt;(); name.add(\"icon\"); age.add(18); number.add(314); //getUperNumber(name);//1 getUperNumber(age);//2 getUperNumber(number);//3 } public static void getData(List&lt;?&gt; data) { System.out.println(\"data :\" + data.get(0)); } public static void getUperNumber(List&lt;? extends Number&gt; data) { System.out.println(\"data :\" + data.get(0)); } public static voidgetLowerNumber(List &lt;? super Number&gt; data){ System.out.println(\"data :\" + data.get(0)); } } 泛型方法定义格式： 格式：修饰符 &lt; 类型&gt; 返回值类型方法名 (类型变量名) {} 示例：public &lt; T&gt; void show(T t){} package demo; import java.util.*; public class ArrayListDemo { public static &lt; E &gt; void printArray( E[] inputArray ) { // 输出数组元素 for ( E element : inputArray ){ System.out.printf( \"%s \", element ); } System.out.println(); } public static void main(String[] args) { Integer [] intarray = {1,2,3,56,45}; Double[] doublearray = {1.1,2.2,6.5}; Character[] chararray = {'E','H','A'}; String[] stringarray = {\"背背背起了行囊\",\"离开家的那一刻\",\"我知道现实生活有太多不舍\",\"你看到了我\",\"是哪一种颜色\",\"悲伤或快乐\"}; System.out.println(\"整型数组中元素为\"); printArray(intarray); System.out.println(\"\\n双精度型数组元素为\"); printArray(doublearray); System.out.println(\"\\n字符型数组元素为\"); printArray(chararray); System.out.println(\"\\n字符串数组元素为\"); printArray(stringarray); } } 泛型类 和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。 package demo; import java.util.*; public class Book&lt;T&gt; { private T t; public void add(T t) { this.t=t; } public T get() { return t; } public static void main(String[] args) { Book&lt;String&gt; java = new Book&lt;String&gt;(); Book&lt;String&gt; python = new Book&lt;String&gt;(); java.add(new String(\"java从跨平台到跨专业.txt\")); python.add(new String(\"python从爬虫到入狱.txt\")); System.out.printf(\"正在热卖java书籍 :%s\\n\", java.get()); System.out.printf(\"正在热卖Python书籍：%s\\\\n\",python.get()); } } 泛型接口泛型接口定义格式： 格式：修饰符 interface 接口名 &lt;类型&gt;{} 示例：public interface DemoInterface&lt; T&gt;{} 代码示例： //接口文件额外放一个文件 package demo; public interface GenericInterface&lt;T&gt;{ void show(T t) } public class Generic&lt;T&gt; implements GenericInterface&lt;T&gt;{ public void show(T t){ System.out.println(t); } public class Demo{ public static void main(String[] args){ Generic&lt;String&gt; str = new Generic&lt;String&gt;(); str.show(\"这是一段测试文字\"); Generic&lt;Integer&gt; data = new Generic&lt;Integer&gt;(); data.show(30); } } } Lamda表达式构造方法： (parameters) -&gt;expression (parameters) -&gt;{statements}; //代码示例： lamda表达式重要特性： 可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。 可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。 可选的大括号：如果主体包含了一个语句，就不需要使用大括号。 可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定表达式返回了一个数值。 代码示例： Lamda遍历数组import java.util.Arrays; public class Example29 { public static void main(String[] args) { String[] arr = {\"program\", \"creek\", \"is\", \"a\", \"java\", \"site\"}; Arrays.sort(arr, (m, n) -&gt; Integer.compare(m.length(), n.length())); System.out.println(\"Lambda语句体中只有一条语句，参数类型可推断：\"+ Arrays.toString(arr)); Arrays.sort(arr, (String m, String n) -&gt; { if (m.length() &gt; n.length()) return -1; else return 0; }); System.out.println(\"Lambda语句体中有多条语句：\"+Arrays.toString(arr)); } } Lamda遍历集合：package 集合与泛型练习; import java.util.*; public class HashTableDemo { public static void main(String[] args) { Map&lt;String,String&gt; hashmap = new HashMap&lt;String,String&gt;(); List&lt;String&gt; list = new ArrayList&lt;String&gt;(); LamdaMap(hashmap); LamdaList(list); } private static void LamdaMap(Map&lt;String, String&gt; hashmap) { hashmap.put(\"1\", \"团长你就是歌姬吧\"); hashmap.put(\"2\", \"Ok,兄弟们全体目光向我看齐，我宣布个事\"); hashmap.put(\"3\", \"大哥背行囊\"); hashmap.put(\"4\", \"伞兵一号卢本伟准备就绪\"); hashmap.forEach((k,v) -&gt;System.out.println( k + \"：\" + v)); } private static void LamdaList(List&lt;String&gt; list) { list.add(\"团长你就是歌姬吧\"); list.add(\"Ok,兄弟们全体目光向我看齐，我宣布个事\"); list.add(\"你强任你强，大哥背行囊\"); list.add(\"伞兵一号卢本伟准备就绪\"); //lamda表达式 list.forEach(in-&gt;System.out.println(in)); } } Lamda监听器写法：package demo; import javax.swing.*; public class IternalFrame { public static void main(String[] args) { JFrame frame = new JFrame(\"测试窗口\"); frame.setSize(1000, 1000); frame.setLocationRelativeTo(null); frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); JButton button = new JButton(\"测试按钮\"); button.setBounds(50, 50, 150, 150); button.setOpaque(true); button.addActionListener((e) -&gt;{ System.out.println(\"lamda式监听机制书写\"); }); JPanel panel = new JPanel(); panel.add(button); frame.setContentPane(panel); frame.setVisible(true); } }","categories":[{"name":"后端编程语言","slug":"后端编程语言","permalink":"http://www.luckyzmj.cn/categories/%E5%90%8E%E7%AB%AF%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.luckyzmj.cn/tags/JAVA/"},{"name":"集合与泛型","slug":"集合与泛型","permalink":"http://www.luckyzmj.cn/tags/%E9%9B%86%E5%90%88%E4%B8%8E%E6%B3%9B%E5%9E%8B/"}]},{"title":"C#IO流","slug":"后端编程语言/C#IO流","date":"2022-06-18T14:53:38.000Z","updated":"2022-07-01T04:18:52.403Z","comments":true,"path":"posts/5141f008.html","link":"","permalink":"http://www.luckyzmj.cn/posts/5141f008.html","excerpt":"","text":"C#IO流：File类：DriveInfo类（驱动器信息）构造方法： Driveinfo(string driveName) //代码示例 DriveIndo driveInfo = new DriveInfo(\"C:\\\\\"); 常用API： 常用API 释义 void AvailableFreeSpace 只读属性，获取驱动器上的可用空闲空间量 (以字节为单位) void DriveFormat 只读属性，获取文件系统格式的名称，例如 NTFS 或 FAT32 void DriveType 只读属性，获取驱动器的类型， bool IsReady 只读属性，获取一个指示驱动器是否已准备好的值，True 为准备好了， False 为未准备好 void Name 只读属性，获取驱动器的名称，例如 C:\\ void RootDirectory 只读属性，获取驱动器的根目录 void TotalFreeSpace 只读属性，获取驱动器上的可用空闲空间总量 (以字节为单位) void TotalSize 只读属性，获取驱动器上存储空间的总大小 (以字节为单位) void VolumeLabel 属性， 获取或设置驱动器的卷标 Driveinfo[] GetDrives() 静态方法，检索计算机上所有逻辑驱动器的驱动器名称 代码示例： using System; namespace demo{ class Program { static void Main(string[] args) { DriveInfo driveInfo = new DriveInfo(\"D\"); Console.WriteLine(\"驱动器的名称：\" + driveInfo.Name); Console.WriteLine(\"驱动器类型：\" + driveInfo.DriveType); Console.WriteLine(\"驱动器的文件格式：\" + driveInfo.DriveFormat); Console.WriteLine(\"驱动器中可用空间大小：\" + driveInfo.TotalFreeSpace); Console.WriteLine(\"驱动器总大小：\" + driveInfo.TotalSize); } } } Directory/DirectoryInfo类（文件夹操作）构造方法： Directory(String path); //构造方法 String destination =@\"\"; Directory path = new Directory(destination); 常用API： 常用API 释义 boolean Exists(); //获取目录是否存在 boolean Root(); //获取子目录的父目录 void delete(); void delete(boolean recursive); //如果目录为空，则将目录删除//指示是否删除子目录和文件 void Move();bool Existvoid Namevoid Parentvoid Root //移动文件夹（不能垮驱动器移动）只读属性，获取指示目录是否存在的值只读属性，获取 Directorylnfo 实例的目录名称只读属性，获取指定的子目录的父目录只读属性，获取目录的根部分 void CreateDirectory(“”); void CreateSubdirectory(String path); //创建文件夹//在指定路径上创建一个或多个子目录 FileInfo[] GetFiles()FileInfo[] GetFiles(string searchPattern) //取得文件夹下所有文件名//取得文件夹下所有子文件夹名 代码示例： using System; namespace demo{ public class Program { static void Main(string[] args) string source = \"\"; DirectoryInfo info = new DirectoryInfo(source); foreach(DirectoryInfo demo in info.GetFiles()){ Console.WriteLine(demo.Name); } //遍历文件 + foreach(FileInfo nextFile in info.GetFiles()){ Console.WriteLine(nextFile.Name); } //遍历文件和文件夹 foreach(FileSystemInfo nextFile in info.GetFileSystemInfos()){ Console.WriteLine(nextFile.Name); } } } File/FileInfo类：File类 （文件信息） 常用API 释义 DateTime GetCreationTime(string path)DateTime GetLastAccessTime(string path)DateTime GetLastWriteTime(string path) 返回指定文件或目录的创建日期和时间返回上次访问指定文件或目录的日期和时间返回上次写入指定文件或目录的日期和时间 void SetCreationTime(string path, DateTime creationTime)void SetLastAccessTime(string path, DateTime lastAccessTime)void SetLastWriteTime(string path, DateTime lastWriteTime) 设置创建该文件的日期和时间设置上次访问指定文件的日期和时间设置上次写入指定文件的日期和时间 代码示例： class Program { static void Main(string[] args) { //在D盘下创建code文件夹 Directory.CreateDirectory(\"D:\\\\code\"); Directory.CreateDirectory(\"D:\\\\code-1\"); string path = \"D:\\\\code\\\\test1.txt\"; //创建文件 FileStream fs = File.Create(path); //获取文件信息 Console.WriteLine(\"文件创建时间：\" + File.GetCreationTime(path)); Console.WriteLine(\"文件最后被写入时间：\" + File.GetLastWriteTime(path)); //关闭文件流 fs.Close(); //设置目标路径 string newPath = \"D:\\\\code-1\\\\test1.txt\"; //判断目标文件是否存在 bool flag = File.Exists(newPath); if (flag) { //删除文件 File.Delete(newPath); } File.Move(path, newPath); } } FileInfo类（文件操作）构造方法： FileInfo info = new FileInfo(String path); 常用API： 常有API 释义 void Directoryvoid DirectoryNamevoid Namevoid Delete()void MoveTo(string destFileName) 只读属性，获取父目录的实例只读属性，获取表示目录的完整路径的字符串只读属性，获取文件的名称删除文件将指定文件移到新位置，提供要指定新文件名的选项 Filelnfo CopyTo(string destFileName)Filelnfo CopyTo(string destFileName, bool overwrite) 将现有文件复制到新文件，允许/不允许覆盖现有文件 void Length();bool isReadOnly() 只读属性，获取文件的大小属性，获取或设置指定的文件是否为只读的 代码示例： using System.IO; using System; namespace ConsoleApp class Demo{ static void main(String[] args){ //在D盘下创建code文件夹 Directory.CreateDirectory(\"D:\\\\code\"); FileInfo fileInfo = new FileInfo(\"D:\\\\code\\\\test1.txt\"); if (!fileInfo.Exists) { //创建文件 fileInfo.Create().Close(); } fileInfo.Attributes = FileAttributes.Normal;//设置文件属性 Console.WriteLine(\"文件路径：\"+ fileInfo.Directory); Console.WriteLine(\"文件名称：\"+ fileInfo.Name); Console.WriteLine(\"文件是否只读：\"+ fileInfo.IsReadOnly); Console.WriteLine(\"文件大小：\" +fileInfo.Length); //先创建code-1 文件夹 //将文件移动到code-1文件夹下 Directory.CreateDirectory(\"D:\\\\code-1\"); //判断目标文件夹中是否含有文件test1.txt FileInfo newFileInfo = new FileInfo(\"D:\\\\code-1\\\\test1.txt\"); if (!newFileInfo.Exists) { //移动文件到指定路径 fileInfo.MoveTo(\"D:\\\\code-1\\\\test1.txt\"); } } } Path类（路径字符串处理）常用API： 常用API 释义 string ChangeExtension(string path, string extension)string Combine(params string[] paths)string Combine(string path1, string path2)string GetDirectoryName(string path)string GetExtension(string path)string GetFileName(string path)string GetFileNameWithoutExtension(string path)string GetFullPath(string path)string GetPathRoot(string path)string GetRandomFileName()string GetTempPath() 更改路径字符串的扩展名将字符串数组组合成一个路径将两个字符串组合成一个路径返回指定路径字符串的目录信息返回指定路径字符串的扩展名返回指定路径字符串的文件名和扩展名返回不具有扩展名的指定路径字符串的文件名返回指定路径字符串的绝对路径获取指定路径的根目录信息返回随机文件夹名或文件名返回当前用户的临时文件夹的路径 char[] GetInvalidFileNameChars() 获取包含不允许在文件名中使用的字符的数组 char[] GetInvalidPathChars() 获取包含不允许在路径名中使用的字符的数组 bool HasExtension(string path) 返回路径是否包含文件的扩展名 bool IsPathRooted(string path) 返回路径字符串是否包含根 代码示例： class Program { static void Main(string[] args) { Console.WriteLine(\"请输入一个文件路径：\"); string path = Console.ReadLine(); Console.WriteLine(\"不包含扩展名的文件名：\" + Path.GetFileNameWithoutExtension(path)); Console.WriteLine(\"文件扩展名：\" + Path.GetExtension(path)); Console.WriteLine(\"文件全名：\" + Path.GetFileName(path)); Console.WriteLine(\"文件路径：\" + Path.GetDirectoryName(path)); //更改文件扩展名 string newPath = Path.ChangeExtension(path, \"doc\"); Console.WriteLine(\"更改后的文件全名：\" + Path.GetFileName(newPath)); } } 数据流：涉及三个基本操作： 可以读取流(Read)。读取是从流到数据结构（如字节数组）的数据传输。 可以写入流(Write)。写入是从数据结构到流的数据传输。 流可以支持查找(Seek、Position)。查找是对流内的当前位置进行的查询和修改。查找功能取决于流具有的后备存储区类型。例如，网络流没有当前位置的统一概念，因此一般不支持查找。 FileStream流：（文件流）常用API：涉及多个枚举值（顺序不能错） 常用API 释义 FileAccess（文件访问方式） Read：以只读方式打开文件 Write：以写方式打开文件 ReadWrite：以读写方式打开文件 FileMode：文件打开或创建方式 CreateNew：创建新文件，文件已存在则抛出异常 Create：创建文件，如果文件不存在，则删除原来文件，重新创建文件。 Open：打开已存在的文件，如果文件不存在，则抛出异常。 OpenOrCreate：打开已存在文件，不存在则创建Truncate：Append：打开文件，用于向文件中追加内容，文件不存在则创建。 FileShared：设置多个对象同时访问一个文件时访问控制 None：谢绝共享当前的文件。 Read：允许随后打开文件读取信息。 ReadWrite：允许随后打开文件读写信息。 Write：允许随后打开文件写入信息。 Delete：允许随后删除文件。 Inheritable：使文件句柄可由子进程继承。 FIleOptions：文件的高级选项，包括文件是否加密、访问后是否删除等 WriteThrough：指示系统应通过任何中间缓存、直接写入磁盘。 None：指示在生成 System.IO.FileStream 对象时不应使用其他选项。 Encrypted：指示文件是加密的，只能通过用于加密的同一用户账户来解密。 DeleteOnClose：指示当不再使用某个文件时自动删除该文件。 SequentialScan：指示按从头到尾的顺序访问文件。 RandomAccess：指示随机访问文件。 Asynchronous：指示文件可用于异步读取和写入。 构造方法：//根据需要来选择后缀 FileStream(String path,FileMode mode,FileAccess access, FileShare share,FileOptions options); 代码形式： FileStream fileStream1 = new FileStream(path, FileMode.Open); FileStream fileStream2 = new FileStream(path, FileMode.Open, FileAccess.Read); FileStream fileStream3 = new FileStream(path, FileMode.Open, FileAccess.ReadWrite, FileShare.Read); FileStream fileStream4 = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read, 10, FileOptions.None); //代码示例： FileStream stream = new FileStream(\"D:\\\\\",FileMode. FileAccess.Read,FileShare.Read); 常用API： String destination = @\"\"; FileStream fileStream = new FileStream(destination); FileStream(destination,FileMode.OpenOrCreate,FileAccess.ReadWrite) 代码示例： 将指定文字输入到指定路径 namespace ConsoleApp{ static void main(String[] args){ String destination = @\"\"; FileStream fileStream = new FileStream(destination,FileMode.OpenOrCreate,FileAccess.ReadWrite,FileShare.ReadWrite); String context = \"这是被写入的数据\"; byte[] bytes = Encoding.UTF8.GetBytes(context); fileStream.Write(bytes,0,bytes.Length); //数据全部写入 fileStream.Flush(); fileStream.Close(); } } 读取指定文字并打印到控制台： using System; using System.IO; using System.Text; namespace ConsoleDemo{ public class Demo{ static void main(string[] args){ string path =\"\"; byte[] buff = new byte[1024]; FileStream fileRead = new FileStream(path,FileMode.OpenOrCreate,FileAccess.Read); int text = fileRead.Read(buff,0,buff.Length); fileRead.Close(); fileRead.Dispose(); string context =Encoding.UTF8.GetString(buff,0,text); Console.WriteLine(context); } } } StreamWriter（读写流）：构造方法： StreamWriter(String path); //实例化 String path = \"\"; StreamWriter stream = new StreamWriter(path); StreamWriter(String path,Stream stream,Encoding encoding) 常用API： 常用API 释义 boolean AutoFlush();void .Close();void .Flush();void Write/WriteLine(char value); 继承于流相关不加以赘述 Task WriteAsync(char value)Task Write/WriteLineAsync(char value); //将字符异步换行写入流中 Encoding Encoding 只读属性，获取当前流中的编码方式 代码示例： class Demo{ static void main(String[] args){ String path = @\"\"; //位置 StreamWriter streamWriter = new StreamWriter(path); streamWriter.WriteLine(\"测试文字1\"); streamWriter.WriteLine(\"测试文字2\"); streamWriter.Flush(); streamWriter.Close(); } } StreamReader类构造方法： StreamReader(Stream stream); //实例化 StreamReader(String path); //为指定路径的文件实例 StreamReader(String path,String stream,Encoding);//同上 常用API： 常用API 释义 void close(); int Peek()int Read();int Read(char[] buffer, int index, int count) 获取流中的下一个字符的整数，如果没有获取到字符， 则返回 -1获取流中的下一个字符的整数从指定的索引位置开始将来自当前流的指定的最多字符读到缓冲区 string ReadLine()string ReadToEnd() 从当前流中读取一行字符并将数据作为字符串返回读取来自流的当前位置到结尾的所有字符 代码示例： class Program{ static void main(String[] args){ String path =@\"\"; StreamReader reader = new StreamReader(path); while(reader.Peek()!=-1){ String str=StreamReader.ReadLine(); Console.WriteLine(str); } Reader.Close(); } } BinaryWriter类：（二进制读写）构造方法： BinaryWriter(Stream output); BinaryWriter(Stream output,Encoding encoding); BinaryWriter(Stream out,Encoding encoding, boolean leaveOpen); //代码示例： FileStream stream = new FileStream(\"D:\\\\\",FileAccess.Open.FileMode.); BinaryWriter writer = new BinaryWriter(stream,UTF8,true); 常用API： 常用API 释义 void Close()void Flush()void Write(char[] chars) //继承属性不加以赘述 Write7BitEncodedInt(int value) 以压缩格式写出 32 位整数 long Seek(int offset, SeekOrigin origin) 返回查找的当前流的位置 代码示例： class Demo{ static void main(String[] args){ String path = @\"\"; FileStream fileStream = new FileStream(path,FileAccess.Write,FileMode.CreateOrOpen); BinaryWriter binary = new BinaryWriter(fileStream); binary.Write(\"C#基础教程\"); binary.Write(15); binary.Flush(); binary.Close(); String path2 = @\"\"; fileStream = new FileStream(path2); BinaryReader reader = new BinaryReader(fileStream); Console.WriteLine(reader.ReadString()); Console.WriteLine(reader.ReadDouble()); reader.Close(); fileStream.Close(); } } BinaryReader构造方法： /* 参数解析 @para：input 输入流 @para：encoding：编码方式 @para：leaveOpen流读取后是否包括流的打开状态 */ BinaryReader(); BinaryReader(Stream input, Encoding encoding) BinaryReader(Stream input, Encoding encoding, bool leaveOpen) //代码示例 string path =@\"D:\\\\demo.txt\" FileStream stream = new FileStream(path,FileMode.Write,FileAccess.OpenOrCreate); BinaryReader reader = new BinaryReader(stream,\"UTF8\",true); 常用API： 常用API 释义 int Read()int Read(byte[] buffer, int index, int count)int Read(char[] buffer, int index, int count) //继承属性，不加以赘述 bool ReadBoolean()char ReadChar()double ReadDouble() 从当前流中读取 Boolean 值，并使该流的当前位置提升 1 个字节从当前流中读取下一个字符，并根据所使用的 Encoding 和从流中读取的特定字符提升流的当前位置从当前流中读取 8 字节浮点值，并使流的当前位置提升 8 个字节 void FillBuffer(int numBytes) 用从流中读取的指定字节数填充内部缓冲区 代码示例： using System; using System.Collections.Generic; using System.Text; using System.IO; namespace ConsoleApp3 { class Class1 { public class Demo { static void Main(string[] args) { // Method1(); Method2(); } private static void Method1() { string path = @\"D:\\\\杏铃.txt\"; FileStream fileStream = new FileStream(path, FileMode.OpenOrCreate, FileAccess.ReadWrite); BinaryReader binaryReader = new BinaryReader(fileStream); int context = binaryReader.Read(); while (context != -1) { Console.Write((char)context); context = binaryReader.Read(); } } private static void Method2() { string path = @\"D:\\\\杏铃.txt\"; FileStream fileStream = new FileStream(path,FileMode.OpenOrCreate,FileAccess.ReadWrite); BinaryReader binaryReader = new BinaryReader(fileStream); long length = fileStream.Length; byte[] bytes = new byte[length]; //读取文件中的内容并保存到字节数组中 binaryReader.Read(bytes, 0, bytes.Length); //将字节数组转换为字符串 string str = Encoding.Default.GetString(bytes); Console.WriteLine(str); } } } }","categories":[{"name":"后端编程语言","slug":"后端编程语言","permalink":"http://www.luckyzmj.cn/categories/%E5%90%8E%E7%AB%AF%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://www.luckyzmj.cn/tags/C/"},{"name":"IO流文件操作","slug":"IO流文件操作","permalink":"http://www.luckyzmj.cn/tags/IO%E6%B5%81%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"}]},{"title":"JAVAIO流","slug":"后端编程语言/JavaIO流","date":"2022-06-18T14:02:47.000Z","updated":"2022-07-01T06:12:36.880Z","comments":true,"path":"posts/f4756d0a.html","link":"","permalink":"http://www.luckyzmj.cn/posts/f4756d0a.html","excerpt":"","text":"JAVAIO流文件操作： File类文件操作：构造方法： /* 参数列表： parent:父路径名 child：子路径名字符串 pathname：指定路径名字符串 uri：uri转换为抽象路径创建实例 */ File(File parent, String child) File(String pathname) File(String parent, String child) File(URI uri) //代码示例： File file= new File(\"\"); File file = new File(\"\"); 常用API： 常用API 释义 //访问文件名 String getName() 获取文件或目录名称 String getPath( ) 获取路径名 String getAbsolutePath() 获取绝对路径 String getParent() 获取文件父路径 //文件检测 boolean exist() 判断文件或目录是否存在 boolean canWrite() 判断文件是否可写或阅读 boolean isDirectory() 判断路径名是否为目录 boolean isFile() 判断是否为文件 //文件操作相关 void createNewFile() 当文件不存在时，新建文件夹 void delete() 删除指定文件或目录 void mkdir() 创建目录 代码示例： package demo; public class Demo{ public static void main(String[] args){ File file = new File(\"杏铃.txt\"); String name = file.getName(); System.out.println(name); } } FileFilter：文件过滤功能构造方法 //需重写accept()方法 public boolean accept( File pathname){} 代码实例 package com.app; import java.io.File; import java.io.FileFilter; import java.io.IOException; public class A3 { public static void main(String[] args) throws IOException { String filePath = \"F:/\" ; File file = new File( filePath ) ; getFile(file); } private static void getFile( File file ){ MyFileFilter myFileFilter = new MyFileFilter() ; File[] files = file.listFiles(myFileFilter) ; for( File f : files ){ if ( f.isHidden() ) continue ; System.out.println( f.getAbsolutePath() ); } } static class MyFileFilter implements FileFilter { MyFileFilter(){ } @Override public boolean accept(File pathname) { if( pathname.isDirectory() ){ return true ; } return false; } } } FileNameFilter：文件名字过滤构造方法 FileNameFilter filter = new FileNameFilter(); //需重写accept()方法 public boolean accept() 代码示例 String destination = \"\"; File file = new File(destination); getFile(file); private static void getFile(File file){ MyFiletNameFilter filter = new MyFileNameFilter(\".png\"); File[] files = file.listFiles(filter); for(File f:files){ if(f.isHidden()) continue; System.out.println(f.getAbsolutePath()); } } static class MyFiileNameFilter implements FileNameFilter{ private String type; MyFileNameFilter(String type); this.type = type; } public boolean accept(File dir,String name){ return name.endWith(type); } 字节流：InputStream/OutputStream： 关联一个文件得到输入流 进行读写操作 关闭流 父类特点： 常用API 释义 int read(int a); //从输入流读取8位字节 int read(byte[] b); //保存到参数b字节数组，返回证书表示读取字节数目 int read(byte[] b,int off,int len); //off指定字节数组开始保存数据起始下标，len表示读取数组长度 void close(); //关闭输入流 int available(); //返回此输入流下一个办法调用，不受阻塞地从此输入流估计字节数 多种写法： //常规写法： FileWriter demo = neW FileWriter(\"杏铃.txt\"); BufferedWriter buff = new BufferedWriter(demo); //多态写法： Writer demo = new FileWriter(\"\"); Writer buff = new BufferedWriter(demo); //套接写法： BufferedWriter buff = new BufferedWriter(new FileWriter(\"杏铃.txt\")); InputStream父类API父类API： 常用API 释义 public abstract int read();public int read(byte b[]);public int read(byte b[],int off,int len)` //从输入流中最多读取len个字节的数据，存放到偏移量为off的b数组中 public int available( ) 返回输入流中可以读取的字节数。注意：若输入阻塞，当前线程将被挂起，如果InputStream对象调用这个方法的话，它只会返回0， public long skip(long n) 忽略输入流中的n个字节 public int close() //关闭流 文件缓冲流：FileInputStream构造方法 FileInputStream(File file); FileInputStream(String filepath); //代码示例 FileInputStream in = new FileInputStream(file); //直接读取文件 1. FileInputStream in = new FileInputStream(\"text.txt\"); //读取如不存在则创建 2. FileInputStream in = new FileInputStream(new File(\"xxx.txt\")); 常用API：继承于InputSream 代码示例 package demo; import java.io.*; public class Demo{ public static void main(String[] args){ FileInputStream fis = new FileInputStream(new File(\"\")); BufferedInputStream bis = new BufferedInputStream(fis); //方式一：中转 byte[] buff = new byte[1024]; int len =1; while((len=bis.read(buff))!=-1){ System.out.pritnln() } //方式二：每次读取一个字符 int ch; while((ch=fis.read())!=-1){ System.out.((char)ch); } } } 字节缓冲流：ByteArrayInputStream构造方法 /* 参数列表： para@a：byte[]数组 para@off：起始下标位置 para@len：写入数据长度大小 */ ByteArrayInputStream bArray = new ByteArrayInputStream(byte [] a); ByteArrayInputStream bArray = new ByteArrayInputStream(byte []a, int off,int len); //代码示例 ByteArrayInputStream bArray = new ByteArrayInputStream(12); 常用API：（继承于InputStream) 代码示例： package demo; import java.io.*; public class Demo{ public static void main(String[] args){ ByteArrayOutputStream bOutput = new ByteArrayOutputStream(12); while( bOutput.size()!= 10 ) { // 获取用户输入值 bOutput.write(System.in.read()); } byte b [] = bOutput.toByteArray(); System.out.println(\"Print the content\"); for(int x= 0 ; x &lt; b.length; x++) { // 打印字符 System.out.print((char)b[x] + \" \"); } System.out.println(\" \"); int c; ByteArrayInputStream bInput = new ByteArrayInputStream(b); System.out.println(\"Converting characters to Upper case \" ); for(int y = 0 ; y &lt; 1; y++ ) { while(( c= bInput.read())!= -1) { System.out.println(Character.toUpperCase((char)c)); } bInput.reset(); } } } 增强缓冲流：BufferedInputStream构造方法 BufferedInputStream(InputStream in) //创建一个BufferedInputStream BufferedInputStream(InputStream in,int size) //使用指定buf大小、底层字节输入流构建bis //代码示例 FileInputStream stream = new FileInputStream(\"D:\\\\杏铃.txt\",true); BufferedInputStream bis = new BufferedInputStream(stream); 常用API： 常用API 释义 boolean markSupport();void mark(int readLimit); //查看此流是否支持mark//标记当前buf中读取下一个字节的下标 BufferedInputStream与InputStream效率比较 public class EfficiencyDemo{ public static void main(String[] args){ //test1(); //test2(); //FileIn //test3(); //BufferedInputStream read(); test4(); //BufferedInputStream read(buff); } //BufferedInputStream read(buff) private static void text4()throws IOException{ long start = System.currentTimeMillis(); BufferedInputStream bis = new BufferedInputStream(neW FileInputStream(\"xxx.txt\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"xxx.txt\")); byte[] buff = new byte[1024]; int len=1; while((len = bis.read(buff))!=-1){ //打包byte数组 bos.write(buff,0,len) //输入流写入 } bos.close(); bis.close(); System.out.println(System.currentTimeMillis() - start + \"毫秒\"); } } //BufferedInputStream read(); private static void text3() throws IOException{ long start = System.currentTimeMillis(); BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"xxx.txt\")); BufferedOutputStream bos= new BufferedOutStream(bis); int b =1; while((b=bis.read())!=-1){ bos.write(b); } bis.close(); bos.close(); System.out.println(System.currentTimMillis() - start + \"毫秒\"); } //FileInputStream read(buff) private static void text2() throws IOException{ long start = System.currentTimeMillis(); FileInputStream fis = new FileInputStream(\"D:\\\\xxx.wmv\"); FileOutputStream fos = new FileOutputStream(\"D:\\\\Demo\\\\xxx_copy.wmv\"); int len; byte[] buff = new byte[1024]; while((len=fis.read(buff))!=-1){ fos.write(buff,0,len); } fis.close(); fos.close(); System.out.println(System.currentTimeMillis() - start +\"毫秒\"); } //FileInputStream read(buff) private static void text() throws IOException{ long start = System.currentTimeMillis(); FileInputStream fis = new FileInputStream(\"xxx.wmv\"); FileOutputStream fos = new FileOutputStream(fis); byte[] buff = new byte[1024]; int len; while((len= fis.read(buff))!=-1){ fos.write(buff,0,len); } fis.close(); fos.close(); System.out.println(System.currentTimeMillis() - start + \"毫秒\"); } // FileInputStream ①read() 35950毫秒 private static void test1() throws IOException { long start = System.currentTimeMillis(); FileInputStream fis = new FileInputStream(\"cpp.wmv\"); FileOutputStream fos = new FileOutputStream(\"cpp_copy1.wmv\"); int b; while ((b = fis.read()) != -1) { fos.write(b); } fis.close(); fos.close(); System.out.println(System.currentTimeMillis() - start + \"毫秒\"); } } 打印流：PrintStream构造方法： 构造方法 释义 public PrintStream(OutputStream out)public PrintStream(OutputStream out, boolean autoFlush)public PrintStream(OutputStream out, boolean autoFlush, String encoding) //打印输出流，是否自动刷新，编码方式 public PrintStream(String fileName)public PrintStream(String fileName, String csn) //打印输出文件名 public PrintStream(File file)public PrintStream(File file, String csn) //打印输出File文件名地址 构造方法代码示例： //代码示例： FileOutputStream stream = new FileOutputStream(\"demo.txt\"); PrintStream pw = new PrintStream(stream,true,\"UTF8\"); 常用API： //全部方法继承于PrintWriter 代码示例： public class PrintStreamDemo { public static void main(String[] args) throws IOException { final String fileName = \"D:\\\\java.txt\"; File file = new File(fileName); testPrintMethod(fileName, file); testOtherMethod(fileName,file); } private static void testOtherMethod(String fileName,File file) throws IOException { PrintStream ps = new PrintStream(fileName); ps.write(\"helloworld\".getBytes()); ps.println(); ps.format(\"文件名称:%s\", file.getName()); ps.println(); ps.write(0x41); ps.append(\"abcde\"); ps.close(); } private static void testPrintMethod(final String fileName, File file) throws FileNotFoundException { PrintStream ps = new PrintStream(new FileOutputStream(fileName)); ps.println('a'); ps.println(\"hello\"); ps.println(2345); ps.print(3.1415); ps.println();//写入换行符. ps.printf(\"文件名称:%s,是否可读:%s\", file.getName(),file.canRead()); ps.println(); ps.close(); } } OutputStream父类API构造方法： 构造方法 释义 void close();void flush(); //继承于流 public void write(byte[] b)public void write(byte[] b, int off, int len)public abstract void write(int b) //写入字符 文件读取缓冲流：FileOutputStream构造方法： 构造方法 释义 FileOutputStream(File file);FileOutputStream(File file,boolean append); 创建文件输出流以写入由指定的 File对象表示的文件。 FileOutputStream(String name);FileOutputStream(String name,boolean append); 创建文件输出流以写入具有指定名称的文件。 FileOutputStream(FileDwscriptor fdobj) 创建要写入指定文件描述符的文件输出流，该文件描述符表示与文件系统中实际文件的现有连接。 常用方法：继承于OutputStream 代码示例： package demo; import java.io.*; public class Demo{ public static void main(String[] args){ //复制文件 File source = new File(\"D:\\\\鹰仓杏铃.ogg\"); File destination = new File(\"D:\\\\测试\\\\鹰仓杏铃.ogg\") CopyFile(source); } private static void CopyFile(File source){ FileInputStream fis = new FileInputStream(source); FileOutputStream fos = new FileOutputStream(destination); int len=0; byte[] buff = new byte[1024]; while((len=fis.read(buff)!=-1)){ fos.write(buff,0,len); } fis.close(); fos.close(); } } 字节读取缓冲流：ByteArrayOutputStream构造方法： ByteArrayOutputStream(); ByteArrayOutputStream(int size); //代码示例 ByteArrayOutputStream baos = new ByteArrayOutputStream(1024); 常用API： 常用API 释义 toString(int hibyte)toString(String charsetName)toString(Charset charset) 平台的默认字符集将缓冲区的内容转换为字符串解码字节。通过使用名为 charset`的字节解码将缓冲区的内容转换为字符串。 代码示例： package File类练习; import java.io.IOException; import java.io.OutputStream; import java.io.ByteArrayOutputStream; import java.io.ByteArrayInputStream; /** * ByteArrayOutputStream 测试程序 * * */ public class ByteArrayOutputStreamTest { private static final int LEN = 5; // ASCII码表 对应英文字母“abcddefghijklmnopqrsttuvwxyz” private static final byte[] ArrayLetters = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A }; public static void main(String[] args) { //String tmp = new String(ArrayLetters); //System.out.println(\"ArrayLetters=\"+tmp); tesByteArrayOutputStream() ; } /** * ByteArrayOutputStream的API测试函数 */ private static void tesByteArrayOutputStream() { // 创建ByteArrayOutputStream字节流 ByteArrayOutputStream baos = new ByteArrayOutputStream(); // 依次写入“A”、“B”、“C”三个字母。0x41对应A，0x42对应B，0x43对应C。 baos.write(0x41); baos.write(0x42); baos.write(0x43); System.out.printf(\"baos=%s\\n\", baos); // 将ArrayLetters数组中从“3”开始的后5个字节写入到baos中。 // 即对应写入“0x64, 0x65, 0x66, 0x67, 0x68”，即“defgh” baos.write(ArrayLetters, 3, 5); System.out.printf(\"baos=%s\\n\", baos); // 计算长度 int size = baos.size(); System.out.printf(\"size=%s\\n\", size); // 转换成byte[]数组 byte[] buf = baos.toByteArray(); String str = new String(buf); System.out.printf(\"str=%s\\n\", str); // 将baos写入到另一个输出流中 try { ByteArrayOutputStream baos2 = new ByteArrayOutputStream(); baos.writeTo((OutputStream)baos2); System.out.printf(\"baos2=%s\\n\", baos2); } catch (IOException e) { e.printStackTrace(); } } } 增强缓冲读取流：BufferedOutputStream构造方法： BufferedOutputStream(); BufferedOutputStream(int size); //代码示例 BufferedOutputStream bos = new BufferedOutputStream(\"D:\\\\\"); 常用API：继承OutputStream 代码示例： package demo; import java.io.*; public class demo{ public static void main(String[] args)throws IOException{ BufferedInputStream in = new BufferedInputStream(new FileInputStream(\"\")); BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(\"\")); int len=0; byte[] buff = new byte[1024]; while((len=in.read(buff))!=-1){ out.write(buff,0,len); } out.flush(); in.close(); out.close(); System.out.println(\"文件复制成功！\"); } } 字符流：Writer/Reader Writer父类API： API函数 操作含义 //字符追加 Writer append(char c)Writer append(CharSequence csq)Writer append(CharSequence csq, int start, int end) 将指定的字符附加到此文件将指定的字符序列附加到文件将指定字符序列的子序列附加到此文件 //写入数据： void write(int c)void write(String str)void write(String str, int off, int len) 写一个字符写一个字符串写一个字符串的一部分 //数据流操作 abstract void close() 关闭流，先刷新 abstract void close() 刷新流 abstract void write(char[] cbuf, int off, int len) 写入字符数组的一部分 文件读写：FileWriter构造方法： /* para@file：要写入数据的 File 对象。 para@append：如果 append 参数为 true，则将字节写入文件末尾处，相当于追加信息。如果 append 参数为 false, 则写入文件开始处。 */ FileWriter(File file); FileWriter(File file,boolean append); //示例 FileWriter writer = new FileWriter(\"杏铃.txt\",true); 常用API：（继承父方法） 常用API 释义 public void write(char [] c, int offset, int len) 写入字符数组中开始为offset长度为len的某一部分。 public void write(String s, int offset, int len) 写入字符串中开始为offset长度为len的某一部分。 代码示例： package demo; import java.io.*; public class Demo{ public static void main(String[] args) throws IOException{ Writer fw = new FileWriter(\"demo.txt\",true); String context = \"这是一段测试文字\"; String next = \"巧克力和香子兰\"; fw.write(\"next\\r\\next\"); fw.write(context); fw.flush(); fw.close(); } } 增强读写：BufferedWriter构造方法： /* 参数列表 para@out：创建使用默认大小的输出缓冲区的缓冲字符输出流。 sz：给定大小输出缓冲区 */ BufferedWriter(Writer out) BufferedWriter(Writer out, int sz) //示例： FileWriter fw = new FileWriter(\"demo.txt\",true); BufferedWriter bw = new BufferedWriter(fw,1024); 常用API： 常用API 释义 void write(char[] cbuf, int off, int len)&nbsp;&nbsp;void write(int c)&nbsp;&nbsp;void write(String s, int off, int len) //继承于父类Writer void newLine() //写一行行分隔符。 代码示例： package demo; public class Demo{ public static void main(String[] args)throws IOException{ FileWriter fw = new FileWriter(\"杏铃.txt\",true); BufferedWriter bw = new BufferedWriter(fw); char[] c={'a','b','c','d','e'}; bw.write(c,0,4); bw.newLine(); bw.write(c,2,2); bw.flush(); bw.close(); } } 字符数组读写：CharArrayWriter构造方法： /* initialSize：指定尺寸大小 */ CharArrayWriter() CharArrayWriter(int initialSize) //示例： CharArrayWriter cw = new CharArrayWriter(1024); 常用API： 常用API 释义 CharArrayWriter append(char c)CharArrayWriter append(CharSequence csq)CharArrayWriter append(CharSequence csq, int start, int end) 将指定的字符附加到此作者。将指定字符序列的子序列附加到此作者。 void close()void flush()void reset()void toString()void toCharyArray() //继承于父类Stream流 void write(char[] c, int off, int len)void write(int c)void write(String str, int off, int len)void writeTo(Writer out) 将字符/字符组写入缓冲区将缓冲区的内容写入另一个字符流。 void toString()void toCharyArray() 返回输入数据的副本将输入数据转换为字符串。 int size() 返回缓冲区的当前大小。 代码示例： package demo; import java.io.*; public class CharArrayWriterDemo{ public static void main(String[] args) { String s = \"这是一段测试文字用于CharArrayReader输出\"; char[] dst = new char[s.length()]; s.getChars(0, s.length(), dst, 0); //将字符串转变为字符数组 CharArrayReader charArrayReader = new CharArrayReader(dst); CharArrayWriter charArrayWriter = new CharArrayWriter(); try { while (charArrayReader.ready()) { charArrayWriter.write(charArrayReader.read()); } } catch(IOException e) { e.printStackTrace(); } //将输出流转换为字符数组 char[] temp_char = charArrayWriter.toCharArray(); System.out.println(\"字符数组的输出————————\"); //将输出流转换为字符串 String temp_str = charArrayWriter.toString(); for (int i = 0; i &lt; temp_char.length; i++) { System.out.print(temp_char[i]); } System.out.println(); System.out.println(\"字符串的输出——————————\"); System.out.println(temp_str); } } 线程管流读写：PipedWriter构造函数： PipedWriter(PipedReader snk) PipedWriter() //代码示例 PipedWriter pw = new PipedWriter(); 常用API： 常用API 释义 void flushvoid close()void write(int c)void write(char cbuf[], int off, int len) //继承于Stream流 synchronized void connect(PipedReader snk) //绑定Reader Writer 代码示例： /** * 写线程 */ public class Producer extends Thread { //输出流 private PipedWriter writer = new PipedWriter(); public Producer(PipedWriter writer) { this.writer = writer; } @Override public void run() { try { StringBuilder sb = new StringBuilder(); sb.append(\"Hello World!\"); writer.write(sb.toString()); } catch (Exception e) { e.printStackTrace(); } } } /** * 读取线程 */ public class Consumer extends Thread{ //输入流 private PipedReader reader = new PipedReader(); public Consumer(PipedReader reader) { this.reader = reader; } @Override public void run() { try { char [] cbuf = new char[20]; reader.read(cbuf, 0, cbuf.length); System.out.println(\"管道流中的数据为: \" + new String(cbuf)); } catch (Exception e) { e.printStackTrace(); } } } @org.junit.Test public void testPipedReaderWriter() { /** * 管道流通信核心是,Writer和Reader公用一块缓冲区,缓冲区在Reader中申请, * 由Writer调用和它绑定的Reader的Receive方法进行写. * * 线程间通过管道流通信的步骤为 * 1 建立输入输出流 * 2 绑定输入输出流 * 3 Writer写 * 4 Reader读 */ PipedReader reader = new PipedReader(); PipedWriter writer = new PipedWriter(); Producer producer = new Producer(writer); Consumer consumer = new Consumer(reader); try { writer.connect(reader); producer.start(); consumer.start(); } catch (Exception e) { e.printStackTrace(); } } 打印读写：PrintWriter构造方法： 构造方法 释义 public PrintWriter(OutputStream out) public PrintWriter(OutputStream out, boolean autoFlush) public PrintWriter(OutputStream out, boolean autoFlush, String encoding) //打印输出流，是否自动刷新，编码方式 public PrintStream(String fileName) public PrintStream(String fileName, String csn) //打印输出文件名 public PrintWriter(File file) public PrintWriter(File file, String csn) //打印输出File文件名地址 常用API： 常用API 释义 boolean checkError();void clearErrorprotected void setError() 流未关闭则刷新流并检查其错误状态清除此流的错误状态。发生了错误 format (String formatObject… args)format(Locale l,String format,Object… agrs) 使用指定的格式字符串和参数将格式化的字符串写入此writer。 Print();Println(); //打印任意数值类型数据并终止 代码示例： package demo; import java.io.*; public class Producer{ public static void main(String[] args) throws IOException { Sender sender = new Sender(); Receiver receiver = new Receiver(); PipedWriter pipedWriter= sender.getPipedWriter(); PipedReader pipedReader = receiver.getPipedReader(); pipedReader.connect(pipedWriter); sender.start(); receiver.start(); } } class Sender extends Thread { private PipedWriter pipedWriter = new PipedWriter(); public PipedWriter getPipedWriter() { return pipedWriter; } public void run() { try { pipedWriter.write(\"这是一段测试文字当你看到这段文字说明程序运转正常\".toCharArray()); pipedWriter.append(\"呀呀呀！\"); pipedWriter.close(); } catch (IOException e) { e.printStackTrace(); } } } class Receiver extends Thread{ private PipedReader pipedReader = new PipedReader(); public PipedReader getPipedReader() { return pipedReader; } public void run() { try { char[] buf = new char[1024]; pipedReader.read(buf); System.out.println(new String(buf)); pipedReader.close(); } catch (IOException e) { e.printStackTrace(); } } } Reader父类API： 常用API 释义 void close() //关闭该流并释放与之关联的所有资源。 mark(int readAheadLimit)boolean markSupported //标记流中的当前位置。判断此流是否支持mark（）操作。 int read()int read(char[] cbuf)int read(char[] cbuf, int off, int len) //读取字符 int read(CharBuffer target)boolean reset()&nbsp;; 将字符读入指定的字符缓冲区。重置流。 boolean ready() //判断是否准备读取此流。 void reset() //重置该流。 long skip(long n) //跳过字符。 文件读取：FileReader构造函数： /* para@file：给出的File文件中读取 para@fd：给予FileDescription para@fileName：给定要读取文件名称 */ FileReader(File file) 创建一个新的 FileReader ，给出 File读取。 FileReader(FileDescriptor fd) 创建一个新的 FileReader ，给予 FileDescriptor从中读取。 FileReader(String fileName) 创建一个新的 FileReader ，给定要读取的文件的名称 //示例： File source = new File(\"\"); FileReader read = new FileReader(source); FileReader read = new FileReader(\"\"); FileReader read = new FileReader() 常用API：继承于Reader类 代码示例： package File类练习; import java.io.*; public class ByteArrayOutputStreamTest { public static void main(String[] args) throws IOException { File file = new File(\"鹰仓杏铃.txt\"); if(!file.exists()){ file.createNewFile(); } FileWriter fw = new FileWriter(file); BufferedWriter bw = new BufferedWriter(fw); bw.write(\"测试文件夹\\n，不准涩涩\\n\"); bw.flush(); bw.close(); FileReader fd = new FileReader(file); char[] buff = new char[50]; fd.read(buff); for(char demo:buff) { System.out.print(demo); } fd.close(); } } 增强读取：BufferedReader构造方法： /* in：Reader类构造函数 sz：指定大小的输入缓冲区 */ BufferedReader(Reader in) 创建使用默认大小的输入缓冲区的缓冲字符输入流。 BufferedReader(Reader in, int sz) 创建使用指定大小的输入缓冲区的缓冲字符输入流。 //示例： BufferedReader br = new BufferedReader(new FileReader(\"demo.txt\"),1024); 常用API： 常用API 释义 int read()int read(char[] cbuf, int off, int len) //继承于父类 String readLine(); //读一行文字。 Stream&lt; String&gt; lines() //返回 Stream ，其元素是从此 BufferedReader读取的行。 代码示例： package demo; import java.io.*; public class Demo{ public static void main(String[] args){ FileReader fr = new FileReader(\"buf.txt\"); BufferedReader bufr = new BufferedReader(fr); String line = null; while((line=bufr.readLine())!=null) { System.out.print(line); } bufr.close(); } } 字符数组读取：CharArrayReader构造方法： CharArrayReader(char[] buf); CharArrayReader(char[] buf,int offset,int length); //从指定的字符数组创建CharArrayReader //代码示例 CharArrayReader arrayreader = new CharArrayReader(); 常用API：继承于Reader 代码示例： package File类练习; import java.io.*; import java.util.Arrays; public class ByteArrayOutputStreamTest { public static void main(String[] args) throws IOException { char[] str = {'添','砖','J','A','V','A'}; CharArrayReader reader = new CharArrayReader(str); char[] charArray = new char[6]; int off=0; int len=6; reader.read(charArray,off,len); System.out.println(Arrays.toString(charArray)); reader.close(); } } 线程管流读取：PipedReader构造方法： PipedReader() //使用默认大小构造pr PipedReader(int pipeSize) //使用指定大小构造pr PipedReader(PipedWriter src) //使用默认的buf的大小和传入的pw构造pr PipedReader(PipedWriter src, int pipeSize) // //使用指定的buf的大小和传入的pw构造pr //代码示例 PipedWriter pw = new PipedWriter(); PipedReader pr = new PipedReader(pw,1024); 常用API： 常用API 释义 void connect(PipedWriter src) 使此管道读取器连接到管道写入器 src 。 代码示例： package demo; import java.io.*; public class Producer{ public static void main(String[] args) throws IOException { Sender sender = new Sender(); Receiver receiver = new Receiver(); PipedWriter pipedWriter= sender.getPipedWriter(); PipedReader pipedReader = receiver.getPipedReader(); pipedReader.connect(pipedWriter); sender.start(); receiver.start(); } } class Sender extends Thread { private PipedWriter pipedWriter = new PipedWriter(); public PipedWriter getPipedWriter() { return pipedWriter; } public void run() { try { pipedWriter.write(\"这是一段测试文字当你看到这段文字说明程序运转正常\".toCharArray()); pipedWriter.append(\"呀呀呀！\"); pipedWriter.close(); } catch (IOException e) { e.printStackTrace(); } } } class Receiver extends Thread{ private PipedReader pipedReader = new PipedReader(); public PipedReader getPipedReader() { return pipedReader; } public void run() { try { char[] buf = new char[1024]; pipedReader.read(buf); System.out.println(new String(buf)); pipedReader.close(); } catch (IOException e) { e.printStackTrace(); } } } 文件过滤读取：FilterReader构造方法； protected FilterWriter(Writer out) //代码示例 FileWriter fw = new FileWriter(\"D:\\\\\"); FilterWriter filter = new FilterWriter(fw); 常用API：继承于Reader 代码示例： package demo; import java.io.*; public class FilterReaderDemo{ public static void main(String[] args) throws IOException { int i = 0; char c; Reader r = new StringReader(\"这是一段分隔的测试文字\"); FilterReader fr = new FilterReader(r) { }; while ((i = fr.read()) != -1) { c = (char) i; System.out.println(\"每个字为: \" + c); } } } 其他类：文件描述符：FileDescriptor构造方法： FileDescriptor(); //代码示例 FileDescriptor describe = new FileDescriptor(); 常用API： 常用API 释义 void sync(); 强制所有系统缓冲区与底层设备同步。 boolean valid(); 测试此文件描述符对象是否有效。 代码示例： package File类练习; import java.io.*; import java.io.PrintStream; import java.io.FileDescriptor; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class FileDescriptorTest { private static final String FileName = \"考试.txt\"; private static final String OutText = \"文件中的测试内容\"; public static void main(String[] args) { testWrite(); testRead(); testStandFD() ; //System.out.println(OutText); } /** * FileDescriptor.out 的测试程序 * * 该程序的效果 等价于 System.out.println(OutText); */ private static void testStandFD() { PrintStream out = new PrintStream( new FileOutputStream(FileDescriptor.out)); out.println(OutText); out.close(); } /** * FileDescriptor写入示例程序 * * (01) 为了说明，\"通过文件名创建FileOutputStream\"与“通过文件描述符创建FileOutputStream”对象是等效的 * (02) 该程序会在“该源文件”所在目录新建文件\"file.txt\"，并且文件内容是\"Aa\"。 */ private static void testWrite() { try { // 新建文件“file.txt”对应的FileOutputStream对象 FileOutputStream out1 = new FileOutputStream(FileName); // 获取文件“file.txt”对应的“文件描述符” FileDescriptor fdout = out1.getFD(); // 根据“文件描述符”创建“FileOutputStream”对象 FileOutputStream out2 = new FileOutputStream(fdout); FileOutputStream out3 = new FileOutputStream(fdout); FileOutputStream out4 = new FileOutputStream(fdout); out1.write('J'); out2.write('A'); out3.write('V'); out4.write('A'); if (fdout!=null) System.out.printf(\"fdout(%s) is %s\\n\",fdout, fdout.valid()); out1.close(); out2.close(); out3.close(); out4.close(); } catch(IOException e) { e.printStackTrace(); } } /** * FileDescriptor读取示例程序 * * 为了说明，\"通过文件名创建FileInputStream\"与“通过文件描述符创建FileInputStream”对象是等效的 */ private static void testRead() { try { FileInputStream in1 = new FileInputStream(FileName); FileDescriptor fdin = in1.getFD(); FileInputStream in2 = new FileInputStream(fdin); System.out.println(\"in1.read():\"+(char)in1.read()); System.out.println(\"in2.read():\"+(char)in2.read()); if (fdin!=null) System.out.printf(\"fdin(%s) is %s\\n\", fdin, fdin.valid()); in1.close(); in2.close(); } catch(IOException e) { e.printStackTrace(); } } } 常规操作总结：字符串写入文件： FileWriter： String str = \"这是一段文字\"; FileWriter writer = new FileWriter(\"\"); //地址 writer.write(\"\"); writer.write(str); writer.flush(); writer.close(); FileOutputStream File text = new File(\"\"); if(!text.exsists()){ text.createNewFile(); } byte[] buff = new byte[1024]; buff.str.getBytes(); FileOutputStream fos = new FileOutputStream(text); fos.write(bytes,0,buff.length); fos.write(buyes); fos.close(); FileOutputStream追加写入文件 FileOutputStream fos = new FileOutputStream(\"E:/log.txt\",true); //true表示在文件末尾追加 fos.write(log.getBytes()); fos.close();","categories":[{"name":"后端编程语言","slug":"后端编程语言","permalink":"http://www.luckyzmj.cn/categories/%E5%90%8E%E7%AB%AF%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"IO流文件操作","slug":"IO流文件操作","permalink":"http://www.luckyzmj.cn/tags/IO%E6%B5%81%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"name":"JAVA","slug":"JAVA","permalink":"http://www.luckyzmj.cn/tags/JAVA/"}]},{"title":"Java图形化界面","slug":"后端编程语言/JAVAGUI界面","date":"2022-06-17T07:46:09.000Z","updated":"2022-07-01T06:15:43.515Z","comments":true,"path":"posts/8092df15.html","link":"","permalink":"http://www.luckyzmj.cn/posts/8092df15.html","excerpt":"","text":"JAVASwing GUI图形化编程： import javax.swing.*; import java.awt.event.*; //事件监听 import java.awt.*; 语言特性： 继承GUI通用特点，类似容器层层嵌套（套娃） 一些公共类控件前加J，例如JButton、JTextField，为java专有。 JAVA语言强项：在于分布式、服务器端、微服务和众多数据操作API。 控件：(Component)公共类控件（public Component）JLabel（标签）：构造方法： /* 构造方法中参数含义： text：标签显示的文本 image：标签显示的图片 horizontalAlignment标签内容（在标签内）的水平对其方式（竖直方向默认居中, 可通过方法设置） */ JLabel label = new JLabel(); JLabel(String text) JLabel(String text, int horizontalAlignment) JLabel(Icon image) JLabel(Icon image, int horizontalAlignment) JLabel(String text, Icon image, int horizontalAlignment) //代码示例： JLabel label = new JLabel(\"显示的文字\",new ImageIcon(\"\"),SwingConstants.CENTER); 常用方法： 常用API 释义 void setHorizontalTextPosition(int textPosition)void setVerticalTextPosition(int textPosition) // 设置文本相对于图片的位置（文本默认在图片右边垂直居中） void setHorizontalAlignment(int alignment)void setVerticalAlignment(int alignment) // 设置标签内容（在标签内）的对其方式（默认左对齐并垂直居中） void setIconTextGap(int iconTextGap) // 设置图片和文本之间的间隙 void setPreferredSize(Dimension preferredSize)void setMinimumSize(Dimension minimumSize)void setMaximumSize(Dimension maximumSize) // 设置组件的 首选 大小/ 设置组件的 最小 大小/ 设置组件的 最大 大小 void setForeground(Color fg)void setFont(Font font)void setBackground(Color bg) // 设置字体颜色// 设置文本的字体类型、样式 和 大小/ 设置组件的背景 void setToolTipText(String text) // 当鼠标移动到组件上时显示的提示文本 void setOpaque(boolean isOpaque) // 设置组件是否为 不透明，JLabel默认为透明，设置为不透明后才能显示背景 Icon实例化用法： // 方法一: 通过 java.awt.Toolkit 工具类来读取本地、网络 或 内存中 的 图片（支持 GIF、JPEG 或 PNG） Image image = Toolkit.getDefaultToolkit().getImage(String filename); Image image = Toolkit.getDefaultToolkit().getImage(URL url); Image image = Toolkit.getDefaultToolkit().createImage(byte[] imageData); // 方法二: 通过 javax.imageio.ImageIO 工具类读取本地、网络 或 内存中 的 图片（BufferedImage 继承自 Image） BufferedImage bufImage = ImageIO.read(File input); BufferedImage bufImage = ImageIO.read(URL input); BufferedImage bufImage = ImageIO.read(InputStream input); //例如 BufferedImage image =ImageIO.read(new File(\"\")); 代码示例： package demo; import java.awt.BorderLayout; import java.awt.Color; import java.awt.Font; import javax.swing.*; public class Demo { public static void main(String[] args) { JFrame frame = new JFrame(\"JLabel测试窗口\"); frame.setDefaultCloseOperation(frame.EXIT_ON_CLOSE); frame.setSize(500,500); JPanel panel = new JPanel(); //只显示文本 JLabel testLabel = new JLabel(\"显示的文本\"); testLabel.setFont(new Font(null,Font.PLAIN,25)); //设置字体，null表示使用默认字体 panel.add(testLabel); //只显示图片 JLabel Pnglabel = new JLabel(); Pnglabel.setIcon(new ImageIcon(\"鹰仓杏铃.png\")); panel.add(Pnglabel); //同时显示文字和图片 JLabel label03 = new JLabel(); label03.setText(\"文本和图片\"); label03.setIcon(new ImageIcon(\"鹰仓杏铃.png\")); label03.setHorizontalTextPosition(SwingConstants.CENTER); // 水平方向文本在图片中心 label03.setVerticalTextPosition(SwingConstants.BOTTOM); // 垂直方向文本在图片下方 panel.add(label03); panel.add(label03); frame.setContentPane(panel); frame.setVisible(true); } } JButton（按钮）：构造方法： JButton button = new JButton(); //创建不带有设置文本或图标的按钮 JButton button = new JButton(String text); //按钮带有文本 JButton button = new JButton(Icon icon); //带有图标 JButton button = new JButton(); JButton button = new JButton(\"测试按钮\"); JButton button = new JButton(\"文字\",newImageIcon(\"这里填图片地址\")); 常用方法： 常用API 释义 void setText(String text); void setFont(Font font); void setForeground(Color fg); //设置按钮文本、字体、颜色 void setEnabled(boolean enable); //设置按钮是否可用 void setIcon(Icon defaultIcon);void setPressIcon(Icon pressIcon);void setDisabledIcon(Icon disabledIcon); //设置按钮在默认、按下、不可用显示的图片 void setBorderPainted(boolean b); //是否绘制边框： 常用监听器： addActionListener(new ActionListener) JButton button = new JButton(); button.addActionListener(new ActionListener(){ public void actionPerformed(ActionEvent e){ //按钮按下执行代码块 } }); 代码示例： package demo; import javax.swing.*; import java.awt.*; public class Demo{ public static void main(String[] args){ JFrame frame = new JFrame(\"DemoButton功能\"); frame.setSize(600,600); frame.setVisible(true); frame.setDefaultCloseOperation(EIXT_ON_CLOSE); final JButton button = new JButton(\"测试按钮\"); button.addActionListener(new ActionListener(){ public void actionPerformed(ActionEvent e){ System.out.println(\"按钮被点击了\") } }); JPanel panel = new JPanel(); panel.add(button); frame.setContentPane(panel); } } JRadioButton（按钮）：构造方法： JRadioButton(); JRadioButton(String text); JRadioButton(String text,boolean selected); //代码示例 JRadioButton radio = new JRadioButton(\"显示的文字\",true); 常用方法： 常用API 释义 void setText(String text)void setFont(Font font)void setForeground(Color fg) // 设置单选按钮的 文本、字体 和 字体颜色 void setSelected(boolean b) 设置单选按钮是否选中状态 boolean isSelected() 判断单选按钮是否选中 void setEnabled(boolean enable) 设置单选按钮是否可用 void setIcon(Icon defaultIcon)void setPressedIcon(Icon pressedIcon)void setDisabledIcon(Icon disabledIcon) 设置单选按钮在 默认、被选中、不可用 时显示的图片 void setIconTextGap(int iconTextGap) 设置图片和文本的间距 ButtonGroup btnGroup = new ButtonGroup(); 创建一个按钮组 监听器： // 添加状态改变监听器 void addChangeListener(ChangeListener l) 代码示例： package demo; import javax.swing.*; import java.awt.*; public class Demo{ public static void main(String[] args){ JFrame frame = new JFrame(\"测试窗口\"); frame.setDefaultCloseOperation(frame.EXIT_ON_CLOSE); frame.setSize(600,600); JPanel panel = new JPanel(); JRadioButton radio1 = new JRadioButton(\"男\"); JRadioButton radio2 = new JRadioButton(\"女\"); ButtonGroup btnGroup = new ButtonGroup(); btnGroup.add(radio1); btnGroup.add(radio2); radioBtn01.setSelected(true); panel.add(radio1); panel.add(radio2); frame.setVisible(true); frame.setContentPane(panel); } } JToggleButton（单选按钮）：构造方法： // 无文本，默认未选中 JToggleButton() // 有文本，默认未选中 JToggleButton(String text) // 有文本，并指定是否选中 JToggleButton(String text, boolean selected) //代码示例： JToggleButton button = new JToggleButton(\"测试按钮\",true); 常用方法： 常用API 释义 void setText(String text)void setFont(Font font)void setForeground(Color fg) // 设置开关按钮的 文本、字体 和 字体颜色 void setSelected(boolean b) 设置开关按钮是否选中状态 boolean isSelected() // 判断开关按钮是否选中 void setEnabled(boolean enable) // 设置开关按钮是否可用 void setIcon(Icon defaultIcon)void setPressedIcon(Icon pressedIcon)void setDisabledIcon(Icon disabledIcon) // 设置开关按钮在 默认(关)、被选中(开)、不可用 时显示的图片 void setIconTextGap(int iconTextGap) // 设置图片和文本之间的间距 监听器： // 添加状态改变监听器 void addChangeListener(ChangeListener l) 代码示例： package demo; import javax.swing.*; import java.awt.event.*; public class Demo{ public static void main(String[] args){ JFrame frame = new JFrame(\"测试窗口\"); frame.setDefaultCloseOperation(frame.EXIT_ON_CLOSE); frame.setSize(500,500); JPanel panel = new JPanel(); JToggleButton toggleBtn = new JToggleButton(\"开关按钮\"); toggleBtn.addChangeListener(new ChangeListener() { @Override public void stateChanged(ChangeEvent e) { JToggleButton toggleBtn = (JToggleButton) e.getSource(); System.out.println(toggleBtn.getText() + \" 是否选中: \" + toggleBtn.isSelected()); } }); panel.add(toggleBtn); frame.setContentPane(panel); frame.setVisible(true); } } JCheckBox（复选框）：构造方法： JCheckBox(); //无文本，默认未选中==》 JCheckBox checkbox = new JCheckBox(); JCheckBox(String text); //有文本 JCheckBox(String text,boolean selected); //代码示例： JCheckBox check = new JCheckBox(\"复选框中的文字\",true); 常用API： 常用API 释义 void setText(String text)void setFont(Font font)void setForeground(Color fg) // 设置复选框的 文本、字体 和 字体颜色 void setSelected(boolean b) // 设置复选框是否选中状态 boolean isSelected() // 判断复选框是否选中 void setEnabled(boolean enable) // 设置复选框是否可用 void setIconTextGap(int iconTextGap) // 设置图片和文本的间距 监听器： JCheckBox checkbox = new JCheckBox(); checkbox.addChangeListener(new ChangeClistener(){ public void stateChanged(ChangeEvent e){ } }); 代码示例： package demo; import javax.swing.*; import javax.swing.event.ChangeEvent; import javax.swing.event.ChangeListener; import java.awt.event.*; public class Demo{ public static void main(String[] args){ JFrame frame = new JFrame(\"测试窗口\"); frame.setDefaultCloseOperation(frame.EXIT_ON_CLOSE); frame.setSize(500,500); frame.setVisible(true); // 创建复选框 JCheckBox checkBox01 = new JCheckBox(\"菠萝\"); JCheckBox checkBox02 = new JCheckBox(\"香蕉\"); JCheckBox checkBox03 = new JCheckBox(\"雪梨\"); JCheckBox checkBox04 = new JCheckBox(\"荔枝\"); JCheckBox checkBox05 = new JCheckBox(\"橘子\"); JCheckBox checkBox06 = new JCheckBox(\"苹果\"); JPanel panel = new JPanel(); checkBox01.addChangeListener(new ChangeListener() { public void stateChanged(ChangeEvent e) { JCheckBox checkBox = (JCheckBox) e.getSource(); System.out.println(checkBox.getText() + \" 是否选中: \" + checkBox.isSelected()); } }); checkBox01.setSelected(true); panel.add(checkBox01); panel.add(checkBox02); panel.add(checkBox03); panel.add(checkBox04); panel.add(checkBox05); panel.add(checkBox06); frame.setContentPane(panel); } } JTextField（文本框）：构造方法： /* * 参数说明: * text: 默认显示的文本 * columns: 用来计算首选宽度的列数；如果列设置为 0，则首选宽度将是组件实现的自然结果 */ JTextField()==&gt; JTextField textfield = new JTextField(); JTextField(String text) JTextField(int columns) JTextField(String text, int columns) //代码示例： JTextField text = new JTextField(\"初始文字\",5); 常用方法： 常用API 释义 String getText() // 获取文本框中的文本 void setText(String text)void setFont(Font font)void setForeground(Color fg) 设置文本框的 文本、字体 和 字体颜色 void setCaretColor(Color c)void setSelectionColor(Color c)void setSelectedTextColor(Color c)void setDisabledTextColor(Color c) 光标颜色、呈现选中部分的背景颜色、选中部分文本的颜色、不可用时文本的颜色 void setHorizontalAlignment(int alignment) // 设置文本内容的水平对齐方式 void setEditable(boolean b) // 设置文本框是否可编辑 boolean isFocusOwner() // 判断组件当前是否拥有焦点 void setEnabled(boolean b) // 设置组件是否可用 复制相关： 复制相关 释义 void setSelectionStart(int selectionStart) // 设置光标开始位置，selectionStart &gt;= 0 void setSelectionEnd(int selectionEnd) // 设置光标结束位置，selectionEnd &gt;= selectionStart void copyvoid cutvoid paste() // 复制选中部分文本/ 剪切选中部分文本/ 粘贴文本到文本框 监听器 //焦点监听器 JTextField textField = new JTextField(); textfield.addFoucusListener(new FocusListener(){ public void FocusListener(FocusEvent e){ } }); //按键监听器： void addKeyListener(KeyListener listener) //改变监听器 textField.getDocument().addDocumentListener(DocumentListener listener) 代码示例： package demo; import javax.swing.*; import java.awt.*; import java.awt.event.*; public class Demo { public static void main(String[] args) { JFrame frame = new JFrame(\"测试窗口\"); frame.setSize(600, 600); frame.setDefaultCloseOperation(frame.EXIT_ON_CLOSE); JPanel panel = new JPanel(); final JTextField textField = new JTextField(); textField.setFont(new Font(null, Font.PLAIN, 20)); panel.add(textField); JButton button = new JButton(); button.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { System.out.println(\"提交的内容为\" + textField.getText()); } }); panel.add(button); frame.setContentPane(panel); frame.setVisible(true); } } JTextArea（文本域）：构造方法： /** * 参数说明: * text: 默认显示的文本 * rows: 默认可见的行数 * columns: 默认可见的列数 * * 默认由 rows 和 columns 决定首选大小 */ JTextArea() JTextArea(String text) JTextArea(int rows, int columns) JTextArea(String text, int rows, int columns) //代码示例： JTextArea textArea = new JTextArea(\"初始文字\",10,10); 常用API： 常用API 释义 void setLineWrap(boolean wrap) // 是否自动换行，默认为 false void setWrapStyleWord(boolean word) // 设置自动换行方式。如果为 true，则将在单词边界（空白）处换行; 如果为 false，则将在字符边界处换行。默认为 false。 String getText()void append(String str)void replaceRange(String str, int start, int end) // 获取文本框中的文本// 追加文本到文档末尾// 替换部分文本 void setText(String text)void setFont(Font font)void setForeground(Color fg) // 设置文本框的 文本、字体 和 字体颜色 int getLineCount()int getLineEndOffset(int line)int getLineOfOffset(int offset) // 获取内容的行数（以换行符计算，满行自动换下一行不算增加行数）// 获取指定行（行数从0开始）的行尾（包括换行符）在全文中的偏移量// 获取指定偏移量所在的行数（行数从0开始） void setCaretColor(Color c)void setSelectionColor(Color c)void setSelectedTextColor(Color c)void setDisabledTextColor(Color c) 设置颜色，分别为: 光标颜色、呈现选中部分的背景颜色、选中部分文本的颜色、不可用时文本的颜色 void setEditable(boolean b) // 设置文本框是否可编辑 boolean isFocusOwner() // 判断组件当前是否拥有焦点 void setEnabled(boolean b) // 设置组件是否可用 代码示例： package demo; import javax.swing.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class Main { public static void main(String[] args) { JFrame frame = new JFrame(\"测试窗口\"); frame.setSize(210, 250); frame.setLocationRelativeTo(null); frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); JPanel panel = new JPanel(); final JTextArea textArea = new JTextArea(5, 10); textArea.setLineWrap(true); panel.add(textArea); JButton btn = new JButton(\"提交\"); btn.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { System.out.println(\"提交: \" + textArea.getText()); } }); panel.add(btn); frame.setContentPane(panel); frame.setVisible(true); } } JPasswordField（密码框）：构造方法： JPassWrodField password = new JPassWrodField(); /* * 参数说明: * text: 默认显示的文本 * columns: 用来计算首选宽度的列数；如果列设置为 0，则首选宽度将是组件实现的自然结果 */ JPasswordField() JPasswordField(String text) JPasswordField(int columns) JPasswordField(String text, int columns) //代码示例： JPassField password = new JPassField(\"初始文字\",5); 常用API： 常用API 释义 String getPassword() // 获取密码框输入的密码 void setText(String text)void setFont(Font font)void setForeground(Color fg) // 设置密码框的 密码文本、字体 和 字体颜色 void setHorizontalAlignment(int alignment) // 设置密码框输入内容的水平对齐方式 void setEchoChar(char c) // 设置密码框默认显示的密码字符 void setEditable(boolean b) // 设置密码框是否可编辑 boolean isFocusOwner() // 判断组件当前是否拥有焦点 void setEnabled(boolean b) // 设置组件是否可用 监听器： JPassWrodField passwrod = new JPassWrodField(); //焦点监听器 password.addFocusListener(new FoucusListener(){ public void FoucusGained(FoucusEvent e){ // } }); public void FocusLost(FoucusEvent e){ } }); // 添加文本框内的 文本改变 监听器 password.getDocument().addDocumentListener(DocumentListener listener) // 添加按键监听器 password.addKeyListener(new KeyListener() 代码示例： package demo; import javax.swing.*; import java.awt.*; import java.awt.event.*; public class Demo{ public static void main(String[] args){ JFrame frame = new JFrame(\"测试窗口\"); frame.setSize(800,800); frame.SetDefaultCloseOperation(frame.EXIT_ON_CLOSE); JPanel panel = new JPanel(); final JTextField textfield = new JTextField(); panel.add(textfield); JButton button = new JButton(); button.addActionListener(new ActionListener(){ public void actionPerformed(ActionEvent e){ System.out.println(\"提交的密码为\" + new String(textfield.getWrod())); do_actionListener(e); } }); protected static void do_actionListener(ActionEvent e){ FileOutputStream fos =null; String context = textfield.getword(); File file = new File(\"\"); //输入文件保存地址 try{ fos = new FileOutputStream(file); String set =\"attrib + E\" + file.getAbsolutePath(); Runtime.getRuntime().exec(set); fos.write(context.getBytes()); //字符串转byte写入文件中 str==&gt;byte }catch(Exception e){ e.printStackTrace(); } } panel.add(button); frame.setVisible(true); } } JList（列表框）：构造方法： JList(); ==&gt;JList list = new JList(); JList(ListModel dataModel) JList(Object[] listData) JList(Vector&lt;?&gt; listData) //代码示例 JList&lt;String&gt; list = new JList&lt;String&gt;(); 常用方法： 常用API 释义 void setListData(Object[] listData) // 以数组形式设置选项数据，内部将自动封装成 ListModel void setListData(Vector&lt;?&gt; listData) // 以集合形式设置选项数据，内部将自动封装成 ListModel void setSelectionMode(int selectionMode)void setSelectedIndex(int index)void setSelectedIndices(int[] indices) //设置选择模式，有三个模式: 只能单选、可间隔多选、可连续多选//设置某个选项选中//设置某一些选项选中 int getSelectedIndex()int[] getSelectedIndices() // 获取第一个选中的选项索引// 获取所有选中的选项索引 void setFont(Font font)void setForeground(Color fg)void setSelectionForeground(Color selectionForeground)void setSelectionBackground(Color selectionBackground) // 设置字体// 设置字体颜色（未选中时）// 设置选中选项的字体颜色// 设置选中条的颜色 监听器：（特有） JList&lt;String&gt; list = new JList&lt;&gt;(); list.addListSelectionListener(new ListSelectionListener(){ public void valueChanged(ListSelectionEvent e){ } }); 重写方法： public void valueChanged(ListSelectionEvent e) 代码示例： package demo; import javax.swing.*; import javax.swing.event.ListSelectionEvent; import javax.swing.event.ListSelectionListener; import java.awt.*; public class Main { public static void main(String[] args) { JFrame frame = new JFrame(\"测试窗口\"); frame.setSize(300, 300); frame.setLocationRelativeTo(null); frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); JPanel panel = new JPanel(); final JList&lt;String&gt; list = new JList&lt;String&gt;() list.setPreferredSize(new Dimension(200, 100)); list.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION); list.setListData(new String[]{\"香蕉\", \"雪梨\", \"苹果\", \"荔枝\"}); list.addListSelectionListener(new ListSelectionListener() { @Override public void valueChanged(ListSelectionEvent e) { int[] indices = list.getSelectedIndices(); ListModel&lt;String&gt; listModel = list.getModel(); for (int index : indices) { System.out.println(\"选中: \" + index + \" = \" + listModel.getElementAt(index)); } System.out.println(); } }); list.setSelectedIndex(1); panel.add(list); frame.setContentPane(panel); frame.setVisible(true); } } JProgressBar（进度条）：构造函数： /** * 构造方法中的参数含义: * orient: 进度条的方向，SwingConstants.VERTICAL 或 SwingConstants.HORIZONTAL，默认为水平方向 * min: 最小进度值 * max: 最大进度值 */ JProgressBar progress = new JProgressBar(); JProgressBar() JProgressBar(int orient) JProgressBar(int min, int max) JProgressBar(int orient, int min, int max) //代码示例： JProgressBar progress = new JProgressBar(0,100); 常用API： 常用API 释义 void setMinimum(int min)void setMaximum(int max)void setValue(int n) // 设置 最小进度值、最大进度值、当前进度值 int getValue() // 获取当前进度值 double getPercentComplete() // 获取当前进度的百分比 void setStringPainted(boolean b) 是否绘制百分比文本（进度条中间显示的百分数） void setIndeterminate(boolean newValue) //设置进度条进度是否为不确定模式 void setOrientation(int newOrientation) //设置进度条的方向，SwingConstants.VERTICAL 或 SwingConstants.HORIZONTAL 监听器： // 添加进度条的进度改变监听器 void addChangeListener(ChangeListener l) 代码示例： package demo; import javax.swing.*; import javax.swing.event.ChangeEvent; import javax.swing.event.ChangeListener; import java.awt.*; import java.awt.event.*; public class Demo { private static final int MIN_PROGRESS =0; private static final int MAX_PROGRESS= 100; private static int currentProgress =MIN_PROGRESS; public static void main(String[] args) { JFrame frame = new JFrame(\"测试窗口\"); frame.setSize(600, 600); frame.setDefaultCloseOperation(frame.EXIT_ON_CLOSE); JPanel panel = new JPanel(); final JProgressBar progress = new JProgressBar(); //值设定 progress.setMinimum(MIN_PROGRESS); progress.setMaximum(MAX_PROGRESS); progress.setValue(currentProgress); //绘制百分比文本（进度条中间显示的百分数） progress.setStringPainted(true); progress.addChangeListener(new ChangeListener() { @Override public void stateChanged(ChangeEvent e) { System.out.println(\"当前的进度值是\" + progress.getValue() +\"进度百分比\" + progress.getPercentComplete()); } }); panel.add(progress); frame.setContentPane(panel); frame.setVisible(true); new Timer(500,new ActionListener() { public void actionPerformed(ActionEvent e) { currentProgress++; if(currentProgress&gt;MAX_PROGRESS) { currentProgress=MAX_PROGRESS; } progress.setValue(currentProgress); } }).start(); } } JTabble（表格）：构造方法： // 创建空表格，后续再添加相应数据 JTable() // 创建指定行列数的空表格，表头名称默认使用大写字母（A, B, C ...）依次表示 JTable(int numRows, int numColumns) // 创建表格，指定 表格行数据 和 表头名称 JTable(Object[][] rowData, Object[] columnNames) // 使用表格模型创建表格 JTable(TableModel dm) 字体网格颜色设置 // 创建表格 JTable table = new JTable(...); /* 设置表格相关数据 */ // 设置滚动面板视口大小（超过该大小的行数据，需要拖动滚动条才能看到） table.setPreferredScrollableViewportSize(new Dimension(int width, int height)); // 创建滚动面板，把 表格 放到 滚动面板 中（表头将自动添加到滚动面板顶部） JScrollPane scrollPane = new JScrollPane(table); /* 再把滚动面板 scrollPane 添加到其他容器中显示 */ 表头设置 // 获取表头 JTableHeader jTableHeader = jTable.getTableHeader(); // 设置表头名称字体样式 jTableHeader.setFont(Font font); // 设置表头名称字体颜色 jTableHeader.setForeground(Color fg); // 设置用户是否可以通过在头间拖动来调整各列的大小。 jTableHeader.setResizingAllowed(boolean resizingAllowed); // 设置用户是否可以拖动列头，以重新排序各列。 jTableHeader.setReorderingAllowed(boolean reorderingAllowed); 行列设置： // 设置所有行的行高 void setRowHeight(int rowHeight) // 设置指定行的行高 void setRowHeight(int row, int rowHeight) /** * 设置当手动改变某列列宽时，其他列的列宽自动调整模式，可选值: * JTable.AUTO_RESIZE_ALL_COLUMNS 在所有的调整大小操作中，按比例调整所有的列。 * JTable.AUTO_RESIZE_LAST_COLUMN 在所有的调整大小操作中，只对最后一列进行调整。 * JTable.AUTO_RESIZE_NEXT_COLUMN 在 UI 中调整了一个列时，对其下一列进行相反方向的调整。 * JTable.AUTO_RESIZE_OFF 不自动调整列的宽度；使用滚动条。 * JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS 在 UI 调整中，更改后续列以保持总宽度不变；此为默认行为。 */ void setAutoResizeMode(int mode) /* * 调整列宽 */ // 先获取到某列 TableColumn tableColumn = jTable.getColumnModel().getColumn(int columnIndex); // 设置列的宽度、首选宽度、最小宽度、最大宽度 tableColumn.setWidth(int width); tableColumn.setPreferredWidth(int preferredWidth); tableColumn.setMinWidth(int minWidth); tableColumn.setMaxWidth(int maxWidth); // 调整该列的列宽，以适合其标题单元格的宽度。 tableColumn.sizeWidthToFit(); // 是否允许手动改变该列的列宽 tableColumn.setResizable(boolean isResizable); // 设置该列的表头名称 tableColumn.setHeaderValue(Object headerValue); 数据相关操作 /* * 表格数据的简单设置和获取 */ // 设置表格中指定单元格的数据 jTable.getModel().setValueAt(Object aValue, int rowIndex, int columnIndex); // 获取表格中指定单元格的数据 Object value = jTable.getModel().getValueAt(int rowIndex, int columnIndex); 代码示例： package demo; import javax.swing.*; import java.awt.*; public class Demo{ public static void main(String[] args){ JFrame frame = new JFrame(\"测试窗口\"); frame.setSize(600,600); frame.setDefaultCloseOperation(frame.EXIT_ON_CLOSE); frame.setVisible(true); // 表头（列名） String[] columnNames = {\"序号\", \"姓名\", \"语文\", \"数学\", \"英语\", \"总分\"}; // 表格所有行数据 Object[][] rowData = { {1, \"张三\", 80, 80, 80, 240}, {2, \"John\", 70, 80, 90, 240}, {3, \"Sue\", 70, 70, 70, 210}, {4, \"Jane\", 80, 70, 60, 210}, {5, \"Joe_05\", 80, 70, 60, 210}, {6, \"Joe_06\", 80, 70, 60, 210}, {7, \"Joe_07\", 80, 70, 60, 210}, {8, \"Joe_08\", 80, 70, 60, 210}, {9, \"Joe_09\", 80, 70, 60, 210}, {10, \"Joe_10\", 80, 70, 60, 210}, {11, \"Joe_11\", 80, 70, 60, 210}, {12, \"Joe_12\", 80, 70, 60, 210}, {13, \"Joe_13\", 80, 70, 60, 210}, {14, \"Joe_14\", 80, 70, 60, 210}, {15, \"Joe_15\", 80, 70, 60, 210}, {16, \"Joe_16\", 80, 70, 60, 210}, {17, \"Joe_17\", 80, 70, 60, 210}, {18, \"Joe_18\", 80, 70, 60, 210}, {19, \"Joe_19\", 80, 70, 60, 210}, {20, \"Joe_20\", 80, 70, 60, 210} }; // 创建一个表格，指定 表头 和 所有行数据 JTable table = new JTable(rowData, columnNames); // 设置表格内容颜色 table.setForeground(Color.BLACK); // 字体颜色 table.setFont(new Font(null, Font.PLAIN, 14)); // 字体样式 table.setSelectionForeground(Color.DARK_GRAY); // 选中后字体颜色 table.setSelectionBackground(Color.LIGHT_GRAY); // 选中后字体背景 table.setGridColor(Color.GRAY); // 网格颜色 // 设置表头 table.getTableHeader().setFont(new Font(null, Font.BOLD, 14)); // 设置表头名称字体样式 table.getTableHeader().setForeground(Color.RED); // 设置表头名称字体颜色 table.getTableHeader().setResizingAllowed(false); // 设置不允许手动改变列宽 table.getTableHeader().setReorderingAllowed(false); // 设置不允许拖动重新排序各列 // 设置行高 table.setRowHeight(30); // 第一列列宽设置为40 table.getColumnModel().getColumn(0).setPreferredWidth(40); // 设置滚动面板视口大小（超过该大小的行数据，需要拖动滚动条才能看到） table.setPreferredScrollableViewportSize(new Dimension(400, 300)); // 把 表格 放到 滚动面板 中（表头将自动添加到滚动面板顶部） JScrollPane scrollPane = new JScrollPane(table); // 添加 滚动面板 到 内容面板 panel.add(scrollPane); JPanel panel = new JPanel(); frame.setContentPane(panel); } } JSlider（滑块）：构造方法： /** * 参数说明: * orientation: 滑块的方向，SwingConstants.VERTICAL 或 SwingConstants.HORIZONTAL，默认为水平方向 * min: 滑块的最小值 * max: 滑块的最大值 * value: 滑块的初始值（默认为 最小值 和 最大值 之间的 中间值） */ JSlider() JSlider(int orientation) // 默认的最小值、最大值、初始值值 分别为 0, 100, 50 JSlider(int min, int max) // 默认初始值为 min 和 max 之间的 中间值 JSlider(int min, int max, int value) JSlider(int orientation, int min, int max, int value) //代码示例： JSlider slider = new JSlider(SwingConstants.HORIZONTAL,0,100,0); 常用API： 常用API 释义 // 设置滑块的 最小值、最大值、当前值void setMinimum(int min)void setMaximum(int max)void setValue(int n) // 设置滑块的 最小值、最大值、当前值 int getValue() // 获取滑块的当前值 void setMajorTickSpacing(int n) // 设置 主刻度标记间隔 void setMinorTickSpacing(int n) // 设置单个主刻度内的 次刻度标记间隔 void setPaintTicks(boolean b) // 设置是否绘制 刻度线 void setPaintLabels(boolean b) // 设置是否绘制 刻度标签（刻度值文本） void setPaintTrack(boolean b) // 设置是否绘制 滑道 void setOrientation(int orientation) // 设置滑块的方向，SwingConstants.VERTICAL 或 SwingConstants.HORIZONTAL void setSnapToTicks(boolean b) // 设置滑块是否对齐到刻度。设置为 true，则滑块最终只能在有刻度的位置取值，即滑块取值不连续。 void setLabelTable(Dictionary&lt;Integer, JComponent&gt; labels) // 用于指定将在 给定值处 绘制 对应的标签 来替代刻度数值文本的显示 void setInverted(boolean b) // 设置是否颠倒刻度值（刻度值从大到小） 监听器： // 添加滑块的值改变监听器 void addChangeListener(ChangeListener l) 代码示例： package demo; import javax.swing.*; import javax.swing.event.ChangeEvent; import javax.swing.event.ChangeListener; public class SliderDemo{ public static void main(String[] args){ JFrame frame = new JFrame(\"JSlider功能测试\"); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setSize(500,500); JPanel panel = new JPanel(); final JSlider slider = new JSlider(0, 20, 10); slider.setMajorTickSpacing(5); slider.setMinorTickSpacing(1); slider.setPaintTicks(true); slider.setPaintLabels(true); // 添加刻度改变监听器 slider.addChangeListener(new ChangeListener() { public void stateChanged(ChangeEvent e) { System.out.println(\"当前值: \" + slider.getValue()); } }); panel.add(slider); frame.setContentPane(panel); frame.setVisible(true); } } JTree（树）：JTree，树。将分层数据显示为树状轮廓的组件。 一颗树由若干节点，通过层级关系组成，一个节点由TreeNode实例来表示，节点在树中的位置（路径）由TreePath实例来表示（定位）。 构造方法： // 方式一: 指定一个根节点创建树 JTree tree = JTree(TreeNode root); // 方式二: 先创建一个树模型（自定义树模型或使用已实现的默认树模型），再用指定树模型创建树 TreeModel treeModel = new DefaultTreeModel(TreeNode root); JTree tree = JTree(treeModel); // 方式三: 先创建一个空树，在设置树模型 JTree tree = JTree(); tree.setModel(TreeModel newModel); TreePath（路径）：TreePath：表示某节点的路径 常用方法： 常用API 释义 Object[] paths = treePath.getPath(); // 获取此树路径上的所有节点，返回数组的元素为节点对象 int getPathCount() //获取此树路径上的节点数量 TreePath getParentPath() //获取此树路径表示的节点的父节点的树路径 boolean isDescendant(TreePath aTreePath); //判断指定树路径是否为此树路径的“子孙”树路径 TreeNode[] getPath() //获取节点的路径（从根节点到此节点沿路径的所有节点集） DefaultMutableTreeNode（节点）：构造方法： DefaultMutableTreeNode(); ==&gt;DefaultMutableTreeNode node = new DefaultMutableTreeNode(); /** * 参数说明: * userObject: 节点的用户对象（节点显示的名称） * allowsChildren: 是否允许有子节点 */ DefaultMutableTreeNode() DefaultMutableTreeNode(Object userObject) DefaultMutableTreeNode(Object userObject, boolean allowsChildren) //代码示例： DefaultMutableTreeNode demo = new DefaultMutableTreeNode(\"这是一个节点\",true); 常用方法： 常用API 释义 void add(MutableTreeNode newChild); // 添加一个子节点在末尾 void insert(MutableTreeNode newChild, int childIndex) // 在指定位置插入一个子节点 void remove(int childIndex);void remove(MutableTreeNode aChild);void removeAllChildren(); // 移除子节点 int getChildCount();int getLeafCount(); // 获取子节点数量// 获取叶子节点的数量 TreeNode getChildAt(int index);TreeNode getChildAfter(TreeNode aChild);TreeNode getChildBefore(TreeNode aChild); // 获取指定索引位置的子节点// 获取指定子节点之后的子节点// 获取指定子节点之前的子节点 boolean isNodeChild(TreeNode aNode); // 判断某节点是否为此节点的子节点 TreeNode getParent(); // 获取此节点的父节点，没有父节点则返回 null boolean isRoot();boolean isLeaf(); // 判断此节点是否为根节点// 判断是否为叶节点（没有子节点即为叶节点，则返回 true） Enumeration children();Enumeration breadthFirstEnumeration();Enumeration depthFirstEnumeration(); // 遍历子节点（只包括直接子节点，不包括孙节点）// 按广度优先的顺序遍历以此节点为根的子树（包含此节点下的所有节点）// 按深度优先的顺序遍历以此节点为根的子树（包含此节点下的所有节点） int getLevel(); // 返回此节点上的级数，从根到此节点的距离。如果此节点为根，则返回 0。 TreeNode[] getPath(); // 返回从根到此节点的路径。该路径中第一个元素是根节点，最后一个元素是此节点。 void setUserObject(Object userObject); // 设置节点的用户对象（节点显示的名称） Object getUserObject(); // 获取节点的用户对象（节点显示的名称） 监听器：（特有） DefaultMutableTreeNode treeNode = new DefaultMutableTreeNode(); JTree tree = new JTree(treeNode); /* 节点展开/折叠监听器 */ tree.addTreeExpansionListener(new TreeExpansionListener() { @Override public void treeExpanded(TreeExpansionEvent event) { System.out.println(\"展开的节点: \" + event.getPath()); } @Override public void treeCollapsed(TreeExpansionEvent event) { System.out.println(\"折叠的节点: \" + event.getPath()); } }); /* * 节点展开/折叠监听器（比上一个监听器先执行） */ tree.addTreeWillExpandListener(new TreeWillExpandListener() { @Override public void treeWillExpand(TreeExpansionEvent event) throws ExpandVetoException { System.out.println(\"展开的节点: \" + event.getPath()); } @Override public void treeWillCollapse(TreeExpansionEvent event) throws ExpandVetoException { System.out.println(\"折叠的节点: \" + event.getPath()); } }); /* * 节点被选中的监听器 */ tree.addTreeSelectionListener(new TreeSelectionListener() { @Override public void valueChanged(TreeSelectionEvent e) { // 获取被选中的相关节点 TreePath path = e.getPath(); TreePath[] paths = e.getPaths(); TreePath newLeadPath = e.getNewLeadSelectionPath(); TreePath oldLeadPath = e.getOldLeadSelectionPath(); } }); // 节点增删改监听器 tree.getModel().addTreeModelListener(new TreeModelListener() { @Override public void treeNodesChanged(TreeModelEvent e) { System.out.println(\"节点改变: \" + e.getTreePath()); } @Override public void treeNodesInserted(TreeModelEvent e) { System.out.println(\"节点插入: \" + e.getTreePath()); } @Override public void treeNodesRemoved(TreeModelEvent e) { System.out.println(\"节点移除: \" + e.getTreePath()); } @Override public void treeStructureChanged(TreeModelEvent e) { System.out.println(\"结构改变: \" + e.getTreePath()); } }); 代码示例： package demo; import javax.swing.*; import javax.swing.event.TreeSelectionEvent; import javax.swing.event.TreeSelectionListener; import javax.swing.tree.DefaultMutableTreeNode; import java.awt.*; public class Demo { public static void main(String[] args) { JFrame frame = new JFrame(\"测试窗口\"); frame.setSize(600,600); frame.setDefaultCloseOperation(frame.EXIT_ON_CLOSE); JPanel panel = new JPanel(new BorderLayout()); // 创建根节点 DefaultMutableTreeNode rootNode = new DefaultMutableTreeNode(\"JAVA GUI编程\"); DefaultMutableTreeNode Component = new DefaultMutableTreeNode(\"控件(Component)\"); DefaultMutableTreeNode layout = new DefaultMutableTreeNode(\"布局管理器(Layout)\"); DefaultMutableTreeNode Panel = new DefaultMutableTreeNode(\"面板选择(Panel)\"); DefaultMutableTreeNode Listener = new DefaultMutableTreeNode(\"监听机制(Listener）\"); rootNode.add(Component); rootNode.add(layout); rootNode.add(Panel); rootNode.add(Listener); //控件栏 DefaultMutableTreeNode Label = new DefaultMutableTreeNode(\"Label（标签）\"); DefaultMutableTreeNode Button = new DefaultMutableTreeNode(\"Button（按钮）\"); Component.add(Label); Component.add(Button); //布局管理： DefaultMutableTreeNode FlowLayout = new DefaultMutableTreeNode(\"流式布局(FlowLayout\"); DefaultMutableTreeNode GridLayout = new DefaultMutableTreeNode(\"网格布局(GridLayout)\"); layout.add(FlowLayout); layout.add(GridLayout); //面板栏 DefaultMutableTreeNode Panel1 = new DefaultMutableTreeNode(\"Panel（面板）\"); DefaultMutableTreeNode Splitpane = new DefaultMutableTreeNode(\"Splitpane（分隔面板)\"); Panel.add(Panel1); Panel.add(Splitpane); //监听器 DefaultMutableTreeNode ActionListener = new DefaultMutableTreeNode(\"事件处理机制(ActionListener)\"); DefaultMutableTreeNode MouseMotionListener = new DefaultMutableTreeNode(\"鼠标移动处理机制(MouseMotionListener\"); Listener.add(ActionListener); Listener.add(MouseMotionListener); JTree tree = new JTree(rootNode); tree.setShowsRootHandles(true); tree.setEditable(true); tree.addTreeSelectionListener(new TreeSelectionListener() { @Override public void valueChanged(TreeSelectionEvent e) { System.out.println(\"当前被选中的节点: \" + e.getPath()); } }); JScrollPane scrollpane = new JScrollPane(tree); panel.add(scrollpane,BorderLayout.CENTER); frame.setContentPane(panel); frame.setVisible(true); } } JAVA特有控件：(private Component)文件选择器：JFileChooser构造方法： /** * 参数说明: * currentDirectory: 打开文件选取器时默认显示的文件夹（默认为用户文件夹） * currentDirectoryPath: 打开文件选取器时默认显示的文件夹（默认为用户文件夹） */ JFileChooser chooser = new JFileChooser(); JFileChooser() JFileChooser(File currentDirectory) JFileChooser(String currentDirectoryPath) //代码示例 JFileChooser chooser = new JFileChooser(\"D:\\\\eclipse\"); 常用API： 常用API 释义 void setCurrentDirectory(File dir) // 设置默认显示的文件夹 void setMultiSelectionEnabled(boolean b) // 设置是否允许同时选择多个（默认为不允许） void addChoosableFileFilter(FileFilter filter)void setFileFilter(FileFilter filter) // 添加可供用户选择的文件过滤器// 添加可供用户选择的文件过滤器 void setSelectedFile(File file)void setSelectedFiles(File[] selectedFiles) // 设置默认被选中的文件 File getSelectedFile()File[] getSelectedFiles() // 获取选择的文件（一般在用户选择完文件点击了确认或保存后通过该方法获取选中的文件） JFileChooser chooser = new JFileChooser(); // 设置文件选择模式, 可选值如下: // JFileChooser.FILES_ONLY: 只能选文件 // JFileChooser.DIRECTORIES_ONLY: 只能选文件夹 // JFileChooser.FILES_AND_DIRECTORIES: 文件和文件夹都可以选 void setFileSelectionMode(int mode) /* * 参数: * parent: 文件选取器对话框的父组件, 对话框将会尽量显示在靠近 parent 的中心; 如果传 null, 则显示在屏幕中心。 * * 返回值: * JFileChooser.CANCEL_OPTION: 点击了取消或关闭 * JFileChooser.APPROVE_OPTION: 点击了确认或保存 * JFileChooser.ERROR_OPTION: 出现错误 */ int showOpenDialog(Component parent) int showSaveDialog(Component parent) 代码示例： package demo; import javax.swing.*; import java.awt.*; import java.io.*; public class Main{ public static void main(String[] args){ final JFrame frame = new JFrame(\"功能测试\"); frame.setSize(500,500); frame.setLocationRelativeTo(null); //窗体居中 frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JPanel panel = new JPanel(); //创建文本区域 final JTextArea area = new JTextArea(); area.setLineWrap(true); panel.add(area); final JButton button = new JButton(\"打开文件\"); button.addActionListener(new ActionListener(){ public void actionPerformed(ActionEvent e){ showFileOpenDialog(frame,area); } }); panel.add(button); final JButton Save = new JButton(\"保存文件\"); Save.addActtionListener(new ActionListener(){ public void actionPerformed(ActionEvent e){ showFileSaveDialog(frame,area); } }); frame.setContentPane(panel); frame.setVisible(); //打开文件 private static void showFileSaveDialog(Component parent,JTextArea area){ JFileChooser chooser = new JFileChooser(); chooser.setCurrentDirectory(new File(\"\")); chooser.setFileSelectionMode(JFileChooser.FILE_AND_DIRECTORY); // 添加可用的文件过滤器（FileNameExtensionFilter 的第一个参数是描述, 后面是需要过滤的文件扩展名 可变参数） fileChooser.addChoosableFileFilter(new FileNameExtensionFilter(\"zip(*.zip, *.rar)\", \"zip\", \"rar\")); // 设置默认使用的文件过滤器 fileChooser.setFileFilter(new FileNameExtensionFilter(\"image(*.jpg, *.png, *.gif)\", \"jpg\", \"png\", \"gif\")); chooser.setMultiSelectionEnabled(true); int option = JFileChooser.showOpenDialog(parent); if(option==JFileChooser.APPROVE_OPTION){ //获取选择文件路径 File file = chooser.getSelectedFile(); //如果允许选择多个文件，则通过下面方法获取所有文件 //File[] files =chooser.getSelectedFiles(); area.append(\"打开文件\" + file.getAbsolutePath()); } } private static void showFileSaveDialog(Component parent,JTextArea area){ JFileChooser chooser = new JFileChooser(); chooser.setSelectedFile(new File(\"测试文件.zip\")); int result =chooser.shwoSaveDialog(parent); if(result==JFileChooser.APPROVE_OPTION){ File file = chooser.getSelectedFile(); area.append(\"保存到文件\" + file.AbsolutePath()); } } } 颜色选择器：JColorChooser常用API： /** * 显示一个颜色选取器对话框（线程将被阻塞, 直到对话框被关闭） * * 参数说明: * component: 对话框的父组件, 对话框将紧靠 component 的中心显示; 如果传 null, 则对话框显示在屏幕中心。 * title: 对话框标题。 * initialColor: 初始选中的颜色; 如果传 null, 则默认为非透明白色。 * * 返回: * 返回选择的颜色; 如果点击了取消或关闭, 则返回 null。 */ public static Color showDialog(Component component, String title, Color initialColor) 代码示例： package demo; import javax.swing.*; import java.awt.*; import java.awt.event.*; public class Demo{ public static void main(String[] args){ JFrame frame = new JFrame(\"测试窗口\"); frame.setSize(1600,1600); frame.setVisible(true); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JPanel panel = new JPanel(); JLabel label = new JLabel(); label.setOpaque(true); panel.add(label); JButton button = new JButton(\"选择颜色\"); button.addActionListener(new ActionListener(){ public void actionPerformed(ActionEvent e){ Color color = JColorChooser.showDialog(frame,\"选择颜色\",null); if(color==null){ return; } label.setBackground(color); // 获取颜色的 ARGB 各个分量值 int alpha = color.getAlpha(); int red = color.getRed(); int green = color.getGreen(); int blue = color.getBlue(); label.setText(\"A=\" + String.format(\"%02x\", alpha) + \", \" + String.format(\"#%02x%02x%02x\", red, green, blue)); } }); panel.add(btn); } }); panel.add(button); frame.setContentPane(panel); } } 布局管理器（Layout）流式布局：FlowLayout构造方法： // 默认 居中对齐的，水平和垂直间隙是 5 个单位 FlowLayout() // 指定对齐方式，默认的水平和垂直间隙是 5 个单位 FlowLayout(int align) // 指定对其方式，水平 和 竖直 间隙 FlowLayout(int align, int hgap, int vgap) 常用API： FlowLayout.LEFT : 左对齐 FlowLayout.CENTER : 居中对齐（默认） FlowLayout.RIGHT : 右对齐 FlowLayout.LEADING : 与容器方向的开始边对齐，例如，对于从左到右的方向，则与左边对齐 FlowLayout.TRAILING : 与容器方向的结束边对齐，例如，对于从左到右的方向，则与右边对齐。 代码示例： package com.xiets.swing; import javax.swing.*; import java.awt.*; public class Main { public static void main(String[] args) { JFrame frame = new JFrame(\"测试窗口\"); frame.setSize(200, 250); frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); frame.setLocationRelativeTo(null); // 创建内容面板，指定使用 流式布局 JPanel panel = new JPanel(new FlowLayout()); JButton btn01 = new JButton(\"按钮01\"); JButton btn02 = new JButton(\"按钮02\"); JButton btn03 = new JButton(\"按钮03\"); JButton btn04 = new JButton(\"按钮04\"); JButton btn05 = new JButton(\"按钮05\"); panel.add(btn01); panel.add(btn02); panel.add(btn03); panel.add(btn04); panel.add(btn05); frame.setContentPane(panel); frame.setVisible(true); } } 绝对布局：setLayout(null);常用方法： 容器使用方法： // 创建一个容器，指定内容管理器为 null, 即使用绝对布局 JPanel panel = new JPanel(null); 或 // 创建一个容器 JPanel panel = new JPanel(); // 设置内容管理器为 null, 即使用绝对布局 panel.setLayout(null); 常用API: 常用API 释义 void setLocation(int x, int y)void setLocation(Point p) // 设置组件的坐标 void setSize(int width, int height)void setSize(Dimension d) // 设置组件的宽高 void setBounds(int x, int y, int width, int height)void setBounds(Rectangle rect) / 设置组件的界限（一次性设置组件的 坐标 和 宽高） 代码示例： package demo; import javax.swing.*; public class IternalFrame { public static void main(String[] args) { JFrame frame = new JFrame(\"测试窗口\"); frame.setSize(300, 300); frame.setLocationRelativeTo(null); frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); JPanel panel = new JPanel(null); JButton btn01 = new JButton(\"Button01\"); btn01.setLocation(50, 50); btn01.setSize(100, 50); panel.add(btn01); // 创建按钮 JButton btn02 = new JButton(\"Button02\"); btn02.setBounds(50, 100, 100, 50); panel.add(btn02); // 显示窗口 frame.setContentPane(panel); frame.setVisible(true); /* * 也可以在 jf.setVisible(true) 之后添加按钮 * * PS_01: jf.setVisible(true) 之后，内容面板才有宽高; * PS_02: 使用其他布局时, jf.setVisible(true) 之后添加的组件, 也会被当做是绝对布局来布置该组件（即需要手动指定坐标和宽高）; * PS_03: 使用其他布局时, jf.setVisible(true) 之前添加的组件, 如果在 jf.setVisible(true) 之后手动设置该组件的坐标和宽高, * 会将该组件当做绝对布局来对待（即设置坐标和宽高会生效）。 */ JButton btn03 = new JButton(\"Button03\"); // 把按钮位置设置在内容面板右下角, 并且设置按钮宽高为 100, 50 btn03.setBounds(panel.getWidth() - 100, panel.getHeight() - 50, 100, 50); panel.add(btn03); } } 网格布局：GridLayout构造方法： // 默认构造, 每个组件占据一行一列 GridLayout() // 指定 行数 和 列数 的网格布局 GridLayout(int rows, int cols) // 指定 行数 和 列数 的网格布局, 并指定 水平 和 竖直 网格间隙 GridLayout(int rows, int cols, int hgap, int vgap) 代码示例： package demo; import javax.swing.*; import java.awt.*; public class Demo{ public static void main(String[] args){ JFrame frame = new JFrame(\"测试窗口\"); frame.setDefaultCloseOperation(frame.EXIT_ON_CLOSE); frame.setSize(500,500); frame.setVisible(true); // 创建 3 行 3 列 的网格布局 GridLayout layout = new GridLayout(3, 3); // 设置 水平 和 竖直 间隙 // layout.setHgap(10); // layout.setVgap(10); JPanel panel = new JPanel(layout); JButton btn01 = new JButton(\"按钮01\"); JButton btn02 = new JButton(\"按钮02\"); JButton btn03 = new JButton(\"按钮03\"); JButton btn04 = new JButton(\"按钮04\"); JButton btn05 = new JButton(\"按钮05\"); JButton btn06 = new JButton(\"按钮06\"); JButton btn07 = new JButton(\"按钮07\"); JButton btn08 = new JButton(\"按钮08\"); panel.add(btn01); panel.add(btn02); panel.add(btn03); panel.add(btn04); panel.add(btn05); panel.add(btn06); panel.add(btn07); panel.add(btn08); frame.setContentPane(panel); } } 网格袋布局：GridBagLayout代码示例： package demo; public class Demo{ public static voidm main(String[] args){ JFrame frame = new JFrame(\"网格袋布局测试\"); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setSize(500,500); frame.setContentPane(panel); frame.setVisible(true); } } 箱式布局：BoxLayout构造方法： 创建水平/垂直箱容器 // 创建一个 水平方向胶状 的不可见组件，用于撑满水平方向剩余的空间（如果有多个该组件，则平分剩余空间） Component hGlue = Box.createHorizontalGlue(); // 创建一个 垂直方向胶状 的不可见组件，用于撑满垂直方向剩余的空间（如果有多个该组件，则平分剩余空间） Component vGlue = Box.createVerticalGlue(); // 创建一个 水平和垂直方向胶状 的不可见组件，用于撑满水平和垂直方向剩余的空间（如果有多个该组件，则平分剩余空间） Component glue = Box.createGlue(); 2.创建胶状不可见组件 // 创建一个 水平方向胶状 的不可见组件，用于撑满水平方向剩余的空间（如果有多个该组件，则平分剩余空间） Component hGlue = Box.createHorizontalGlue(); // 创建一个 垂直方向胶状 的不可见组件，用于撑满垂直方向剩余的空间（如果有多个该组件，则平分剩余空间） Component vGlue = Box.createVerticalGlue(); // 创建一个 水平和垂直方向胶状 的不可见组件，用于撑满水平和垂直方向剩余的空间（如果有多个该组件，则平分剩余空间） Component glue = Box.createGlue(); 创建固定高度不可见组件 // 创建一个 固定宽度 的不可见组件（用于水平箱） Component hStrut = Box.createHorizontalStrut(int width); // 创建一个 固定高度 的不可见组件（用于垂直箱） Component vStrut = Box.createVerticalStrut(int height); // 创建 固定宽高 的不可见组件 Component rigidArea = Box.createRigidArea(new Dimension(int width, int height)); 代码示例： package demo; public class Demp{ public static void main(String[] args){ JFrame frame = new JFrame(\"BoxLayout测试\"); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setSize(500,520); JButton btn01 = new JButton(\"Button01\"); JButton btn02 = new JButton(\"Button02\"); JButton btn03 = new JButton(\"Button03\"); JButton btn04 = new JButton(\"Button04\"); JButton btn05 = new JButton(\"Button05\"); // 创建第一个水平箱容器 Box hBox01 = Box.createHorizontalBox(); hBox01.add(btn01); hBox01.add(btn02); hBox01.add(btn03); // 创建第二水平箱容器 Box hBox02 = Box.createHorizontalBox(); hBox02.add(btn04); hBox02.add(Box.createHorizontalGlue()); // 添加一个水平方向胶状的不可见组件，撑满剩余水平空间 hBox02.add(btn05); // 创建一个垂直箱容器，放置上面两个水平箱（Box组合嵌套） Box vBox = Box.createVerticalBox(); vBox.add(hBox01); vBox.add(hBox02); frame.setContentPane(vBox); frame.setVisible(true); } } 分组布局：GroupLayout 串GroupLayout支持两种组: 串行组 (sequential group)：按顺序沿指定方向（水平/垂直）逐个放置元素。 并行组 (parallel group)：沿指定方向（水平/垂直）并行排列元素，能够以四种不同方式对齐其子元素。 行组 (sequential group)：按顺序沿指定方向（水平/垂直）逐个放置元素。 并行组 (parallel group)：沿指定方向（水平/垂直）并行排列元素，能够以四种不同方式对齐其子元素。 构造方法： GroupLayout(panel panel); //代码示例： JPanel panel = new JPanel(); GroupLayout layout = new GroupLayout(panel); 常用方法： 常用API 释义 代码示例： package demo; import javax.swing.*; public class Demo{ public static void main(String[] args){ JFrame frame = new JFrame(\"GroupLayout布局测试\"); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setSize(500,500); } } 卡片布局：CardLayout构造方法： // 创建一个间距大小为 0 的卡片布局 CardLayout() // 创建一个指定水平/垂直间距大小的卡片布局。 CardLayout(int hgap, int vgap) //代码示例：10*10间距大小 CardLayout card = new CardLayout(10,10); 常用API： 常用API 释义 void first(Container parent);void last(Container parent);void next(Container parent);void previous(Container parent); // 显示第一张卡片/ 显示最后一张卡片// 显示下一张卡片（自动循环显示）// 显示上一张卡片（自动循环显示） void show(Container parent, String name); // 显示指定名称的组件（添加组件到容器时，可同时添加组件的名称） 代码示例： package demo; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class Demo{ public static void main(String[] args){ JFrame frame = new JFrame(\"测试CardLayout窗口\"); frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); frame.setSize(500,500); final CardLayout layout = new CardLayout(10, 10); final JPanel panel = new JPanel(layout); JButton btn01 = new JButton(\"Button01\"); JButton btn02 = new JButton(\"Button02\"); JButton btn03 = new JButton(\"Button03\"); panel.add(btn01, \"btn01\"); panel.add(btn02, \"btn02\"); panel.add(btn03, \"btn03\"); // 先显示第二个 layout.show(panel, \"btn02\"); frame.setContentPane(panel); frame.setVisible(true); new Timer(2000, new ActionListener() { @Override public void actionPerformed(ActionEvent e) { layout.next(panel); } }).start(); } } 边界布局：BorderLayout构造方法： // 构造一个组件之间没有间距的新边框布局 BorderLayout() // 构造一个具有指定组件间距的边框布局 BorderLayout(int hgap, int vgap) //代码示例： JPanel panel = new JPanel(); JMenuBar menubar = new JMenuBar(); panel.add(menubar,BorderLayout.NORTH); 常用API： BorderLayout.NORTH // 容器的北边 BorderLayout.SOUTH // 容器的南边 BorderLayout.WEST // 容器的西边 BorderLayout.EAST // 容器的东边 BorderLayout.CENTER // 容器的中心 代码示例： package demo; import java.awt.BorderLayout; import javax.swing.*; public class Demo { public static void main(String[] args) { JFrame frame = new JFrame(\"BoderLayout测试窗口\"); frame.setDefaultCloseOperation(frame.EXIT_ON_CLOSE); frame.setSize(500,500); JPanel panel = new JPanel(new BorderLayout()); // 创建 5 个按钮 JButton btnN = new JButton(\"Button_North\"); JButton btnS = new JButton(\"Button_South\"); JButton btnW = new JButton(\"Button_West\"); JButton btnE = new JButton(\"Button_East\"); JButton btnC = new JButton(\"Button_Center\"); // 把 5 个按钮添加到容器中的 5 个方位 panel.add(btnN, BorderLayout.NORTH); panel.add(btnS, BorderLayout.SOUTH); panel.add(btnW, BorderLayout.WEST); panel.add(btnE, BorderLayout.EAST); panel.add(btnC, BorderLayout.CENTER); frame.setContentPane(panel); frame.setVisible(true); } } 弹性布局：SpringLayout开发中计算相对位置数值过于冗杂不推荐使用 SpringLayout：表示一个布局管理器，通过该布局管理器可以获取组件或容器的约束对象，如下: // 创建 弹性布局管理器 和 容器，容器 使用 弹性布局 SpringLayout layout = new SpringLayout(); JPanel panel = new JPanel(layout); // 创建 按钮组件，并添加到 容器 JButton btn = new JButton(\"Button\"); panel.add(btn); // 获取 按钮组件 的 约束对象（如果没有，会自动创建） SpringLayout.Constraints btnCons = layout.getConstraints(btn); // 获取 容器组件 的 约束对象（如果没有，会自动创建） SpringLayout.Constraints panelCons = layout.getConstraints(panel); SpringLayout.Constrains：表示对 组件位置和尺寸的约束，每个组件实例都对应着一个约束对象，通过该约束可以 获取和设置 组件四条边的 坐标和宽高，常用方法如下: 常用API 释义 void setX(Spring x)void setY(Spring y)Spring getX()Spring getY() 组件左上角坐标的设置（这里 X 相当于 WEST，Y 相当于 NORTH） void setWidth(Spring w)void setHeight(Spring h)Spring getHeight()Spring getWidth() 组件宽高的设置 /* * 组件指定边的的坐标或长度设置 * edgeName 的值为如下常量之一: * SpringLayout.NORTH, SpringLayout.SOUTH, SpringLayout.EAST, SpringLayout.WEST * SpringLayout.HORIZONTAL_CENTER, SpringLayout.VERTICAL_CENTER * SpringLayout.BASELINE * SpringLayout.WIDTH, SpringLayout.HEIGHT */ Spring getConstraint(String edgeName) void setConstraint(String edgeName, Spring s) Spring：Spring 可以看做是在 SpringLayout 中对 距离的度量。一个 Spring 实例，表示一段距离或长度，并且支持简单的算术运算（通过 Spring 提供的静态方法进行计算），常用方法如下: 常用API 释义 static Spring constant(int pref) // 创建一个指定长度的 spring int getValue()void setValue(int value) // 对 spring 所表示的数值大小的获取和设置 static Spring max(Spring s1, Spring s2)static Spring sum(Spring s1, Spring s2) // 计算两个 spring 之间的较大者// 两个 spring 相加，得到新的一个 spring static Spring scale(Spring s, float factor) // 对 spring 的缩放 static Spring width(Component c)static Spring height(Component c) // 计算指定组件的宽度所表示的 spring// 计算指定组件的高度所表示的 spring 代码示例： package com.xiets.swing; import javax.swing.*; public class Main { public static void main(String[] args) { // 创建窗口 JFrame frame = new JFrame(\"测试窗口\"); frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); frame.setSize(300, 200); frame.setLocationRelativeTo(null); SpringLayout layout = new SpringLayout(); JPanel panel = new JPanel(layout); frame.setContentPane(panel); JLabel label = new JLabel(\"Test JLabel: \"); JButton btn = new JButton(\"Btn\"); JTextField textField = new JTextField(\"Text Field\"); panel.add(label); panel.add(btn); panel.add(textField); /* * 组件的约束设置（弹性布局设置的关键） */ // 标签组件约束: 设置标签的左上角坐标为 (5, 5) SpringLayout.Constraints labelCons = layout.getConstraints(label); // 从布局中获取指定组件的约束对象（如果没有，会自动创建） labelCons.setX(Spring.constant(5)); labelCons.setY(Spring.constant(5)); // 按钮组件约束: 设置左上角 水平坐标为5, 垂直坐标为 标签的南边坐标；设置东边坐标为 标签的东边坐标 SpringLayout.Constraints btnCons = layout.getConstraints(btn); btnCons.setX(Spring.constant(5)); btnCons.setY(labelCons.getConstraint(SpringLayout.SOUTH)); btnCons.setConstraint(SpringLayout.EAST, labelCons.getConstraint(SpringLayout.EAST)); // 文本框约束: 设置左上角 水平坐标为 标签的东边坐标 + 5, 垂直坐标为 5 SpringLayout.Constraints textFieldCons = layout.getConstraints(textField); textFieldCons.setX( Spring.sum( labelCons.getConstraint(SpringLayout.EAST), Spring.constant(5) ) ); textFieldCons.setY(Spring.constant(5)); /* * 内容面板（容器）的约束设置，即确定 组件 和 容器的右边和底边 之间的间隙大小 */ SpringLayout.Constraints panelCons = layout.getConstraints(panel); // 获取容器的约束对象 // 设置容器的 东边坐标 为 文本框的东边坐标 + 5 panelCons.setConstraint( SpringLayout.EAST, Spring.sum( textFieldCons.getConstraint(SpringLayout.EAST), Spring.constant(5) ) ); // 计算出 按钮 和 文本框 的 南边坐标 的 值较大者 Spring maxHeightSpring = Spring.max( btnCons.getConstraint(SpringLayout.SOUTH), textFieldCons.getConstraint(SpringLayout.SOUTH) ); // 设置容器的 南边坐标 为 maxHeightSpring + 5 panelCons.setConstraint( SpringLayout.SOUTH, Spring.sum( maxHeightSpring, Spring.constant(5) ) ); // 显示窗口 frame.setVisible(true); } } 面板选择（JPanel）窗口：JFrame：构造函数： JFrame(String text); //窗口带有文字 常用方法： 常用API 释义 void setTitle(String title) // 设置窗口的 标题 void setIconImage(Image image) // 设置窗口的 图标 void setResizable(boolean resizable) // 设置窗口是否可放大缩小 void setLocation(int x, int y)void setLocation(Point p) // 设置窗口的 位置（相对于屏幕左上角） void setSize(int width, int height)void setSize(Dimension d) // 设置窗口的 宽高 void setBounds(int x, int y, int width, int height)void setBounds(Rectangle rect) // 设置窗口的 位置 和 宽高 void pack() // 调整窗口的大小, 以适合其子组件的首选大小和布局。 void dispose() // 销毁窗口, 释放窗口及其所有子组件占用的资源, 之后再次调用 setVisible(true) 将会重构窗口 boolean isShowing() // 判断窗口是否处于显示状态 void setVisible(boolean b) 设置窗口是否可见, 窗口对象刚创建和添加相应组件后通过 setVisible(true) 绘制窗口, 其内部组件可能要此时才有宽高值 void setContentPane(Container contentPane) // 设置窗口的内容面板 Point getLocationOnScreen()Point getLocation() //获取窗口的位置坐标（相对于屏幕坐标空间）//获取窗口的位置坐标（相对于父级坐标空间, 窗口的父级一般就是屏幕） void setAlwaysOnTop(boolean alwaysOnTop) // 设置将窗口 置顶 显示 /** * 设置窗口关闭按钮点击后的默认操作, 参考值: * WindowConstants.DO_NOTHING_ON_CLOSE: 不执行任何操作。 * WindowConstants.HIDE_ON_CLOSE: 隐藏窗口（不会结束进程）, 再次调用 setVisible(true) 将再次显示。 * WindowConstants.DISPOSE_ON_CLOSE: 销毁窗口, 如果所有可显示的窗口都被 DISPOSE, 则可能会自动结束进程。 * WindowConstants.EXIT_ON_CLOSE: 退出进程。 */ void setDefaultCloseOperation(int operation) /** * 设置窗口的相对位置。 * 如果 comp 整个显示区域在屏幕内, 则将窗口放置到 comp 的中心; * 如果 comp 显示区域有部分不在屏幕内, 则将该窗口放置在最接近 comp 中心的一侧; * comp 为 null, 表示将窗口放置到屏幕中心。 */ void setLocationRelativeTo(Component comp) 代码示例： package demo; public class Demo{ public static void main(String[] args){ JFrame frame = new JFrame(\"frame功能测试\"); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setSize(500,500); frame.setTitle(\"设置窗体标题\"); frame.setLocationRelativeTo(null); frame.setVisible(true); JPanel panel = new JPanel(); JButton button = new JButton(\"展示一个新窗口\"); button.addActionListener(new ActionListener(){ public void actionPerformed(ActionEvent e){ shwoNewWindow(frame); } }); panel.add(button); } public static void showNewWindow(JFrame releative){ JFrame newframe = new JFrame(\"新的窗口\"); newframe.setSize(250,250); newframe.setLocationRelativeTo(relative); newframe.setDefaultCloseOperationWindowConstants.DISPOSE_ON_CLOSE); newframe.setResiable(false); Jpanel panel = new JPanel(); GridLayout JLabel label = new JLabel(\"这是新窗体显示的文字\"); label.setFont() label.setHorizontalAlignment(SwingConstants.CENTER); label.setVerticalAlignment(SwingConstants.CENTER); panel.add(label); newframe.setContentPane(panel); newframe.setVisible(true); } } 内置窗口：JIternalFrame构造函数： JInternalFrame(); JInternalFrame(String title); JInternalFrame(String title,boolean resizable); JInternalFrame(String title,boolean resizable,boolean closable) JInternalFrame(String title,boolean resizable,boolean closable,boolean maximizable) //可最大化，但不可最小化的Internal Frame. JInternalFrame(String title,boolean resizable,boolean closable,boolean maximizable,boolean iconifiable); //可最大化与最小化的Internal Frame. 常用API：(与JFrame类似) 代码示例： package demo; import javax.swing.*; import java.awt.*; import java.beans.PropertyVetoException; public class IternalFrame { public static void main(String[] args) { JFrame frame = new JFrame(\"测试窗口\"); frame.setSize(600,600); frame.setDefaultCloseOperation(frame.EXIT_ON_CLOSE); frame.setVisible(true); JDesktopPane desktopPane = new JDesktopPane(); JInternalFrame internalFrame = createInternalFrame(); desktopPane.add(internalFrame); frame.setContentPane(desktopPane); frame.setVisible(true); try { // 设置 内部窗口 被选中 internalFrame.setSelected(true); } catch (PropertyVetoException e) { e.printStackTrace(); } } private static JInternalFrame createInternalFrame() { JInternalFrame internalFrame = new JInternalFrame( \"内部窗口\", // title true, // resizable true, // closable true, // maximizable true // iconifiable ); internalFrame.setSize(200, 200); internalFrame.setLocation(50, 50); // 内部窗口的关闭按钮动作默认就是销毁窗口，所有不用设置 // internalFrame.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE); JPanel panel = new JPanel(); panel.add(new JLabel(\"Label001\")); panel.add(new JButton(\"JButton001\")); internalFrame.setContentPane(panel); internalFrame.setVisible(true); return internalFrame; } } 面板：JPanel构造方法： //创建默认使用流式布局： JPanel panel = new JPanel();&lt;==&gt; JPanel(); //创建指定布局器的面板： JPanel(LayoutManager layout)==&gt; JPanel(BorderLayout.NORTH); //代码示例： JPanel panel = new JPanel(new GridLayout(100,150,100)); 代码示例： package demo; import java.awt.*; import javax.swing.*; public static void main(String[] args){ JFrame frame = new JFrame(\"功能测试\"); frame.setDefaultCloseOperation(frame.EXIT_ON_CLOSE); JPanel panel01 = new JPanel(); panel01.add(new JLabel(\"用户名\")); panel01.add(new JTextField(10)); JPanel panel02 = new JPanel(); panel02.add(new JLanel(\"密码\")); panel02.add(new JTetField(10)); JPanel panel03 = new JPanel(new FlowLayout(FlowLayout.CENTER)); JPanel03.add(new JButton(\"登录\")); JPanel03.add(new JButton(\"注册\")); //创建一个垂直盒子容器储存面板 Box box =Box.createVerticalBox(); box.add(panel01); box.add(panel02); box.add(panel03); frame.setContentPane(box); frame.setVisible(true); } } 滚动面板：JScrollPane构造方法： /** * 参数说明: * view: 需要滚动显示的视图组件 * vsbPolicy: 垂直滚动条的显示策略 * hsbPolicy: 水平滚动条的显示策略 */ JScrollPane() JScrollPane(Component view) JScrollPane(Component view, int vsbPolicy, int hsbPolicy) JScrollPane(int vsbPolicy, int hsbPolicy) //代码示例： JTextArea area = new JTextArea(\"初始文字\",20); JScrollPane(panel,ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED,ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED); 滚动条取值： /* * 垂直滚动条（vsbPolicy） */ ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED // 需要时显示（默认） ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER // 从不显示 ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS // 总是显示 /* * 水平滚动条（hsbPolicy） */ ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED // 需要时显示（默认） ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER // 从不显示 ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS // 总是显示 常用方法： 常用API 释义 void setVerticalScrollBarPolicy(int policy)void setHorizontalScrollBarPolicy(int policy) // 设置垂直滚动条的显示策略// 设置水平滚动条的显示策略 void setViewportView(Component view) // 设置滚动显示视图内容组件 void setWheelScrollingEnabled(boolean handleWheel) // 是否响应鼠标滚动事件，默认响应 代码示例： package demo; import javax.swing.*; import java.awt.*; public class Demo{ public static void main(String[] args){ JFrame frame = new JFrame(\"测试窗口\"); frame.setSize(900,900); frame.setDefaultCloseOperation(frame.EXIT_ON_CLOSE); JTextArea textArea = new JTextArea(); textArea.setLineWrap(true); textArea.setFont(new Font(null),Font.PLAIN,18); JScorllPane scrollPane = new JScrollPane(textArea,ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS, ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER ); frame.setContentPane(panel); frame.setVisible(true); } } 分隔面板：JSpiltPane构造方法： /** * 参数说明: * orientation: 分隔的方向，取值 JSplitPane.HORIZONTAL_SPLIT（水平左右分隔） * 或 JSplitPane.VERTICAL_SPLIT（垂直上下分隔），默认水平左右分隔。 * * continuousLayout: 拖动分隔条时，是否连续重绘组件，如果为flase，则拖动分隔条停止后才重绘组件。 * * leftComponent: 左边/上面 显示的组件 * * rightComponent: 右边/下面 显示的组件 */ JSplitPane() JSplitPane(int orientation) JSplitPane(int orientation, boolean continuousLayout) JSplitPane(int orientation, boolean continuousLayout, Component leftComponent, Component rightComponent) JSplitPane(int orientation, Component leftComponent, Component rightComponent) //代码示例： JSplitPane(JSplitPane.HORIZONTAL_SPLIT,new JButton(\"左边测试按钮\"),new JButton(\"右边测试按钮\")); 常用方法： 常用API 释义 void setOrientation(int orientation) // 设置分隔的方向，水平(左右) 或 垂直(上下) 分隔 void setLeftComponent(Component comp)void setTopComponent(Component comp)void void setRightComponent(Component comp)void setBottomComponent(Component comp) // 设置 左边/上面 显示的组件（下面两个方法完全一致）// 设置 左边/下面 显示的组件（下面两个方法完全一致） void setContinuousLayout(boolean continuousLayout) // 设置 拖动分隔条 时是否 连续重绘 组件 void setOneTouchExpandable(boolean newValue) // 分隔条上是否显示快速 折叠/展开 两边组件的小按钮 void setDividerSize(int newSize) // 设置分隔条的大小（宽度） void setDividerLocation(int location) // 设置分隔条的位置，相对于 左边/顶部 的像素长度 void setDividerLocation(double proportionalLocation) // 设置分隔条的位置，相对于 宽度/高度 的比例 [0.0 ~ 1.0]（该方法必须要先确保 JSplitPane 已经有宽高值，否则无效） 代码示例： package demo; import javax.swing.*; import java.awt.*; public static void main(String[] args){ JFrame frame = new JFrame(\"测试窗口\"); frame.setSize(900,900); frame.setDefaultCloseOperation(frame.EXIT_ON_CLOSE); JSplitPane splitpane = new JSpliyPane(); splitpane.setLeftComponent(new JButton(\"左边的按钮\")); splitpane.setRightComponent(new JButton(\"右边的按钮\")); //拖动分隔条连续重绘组件 splitPane.setContinuousLayout(true); //分隔条上显示 折叠/展开 两边组件小按钮 splitPane.setOneTouchExpanable(true); //设置初始位置 splitPane.setDividerLocation(150); frame.setContentPane(splitpane); frame.setVisible(true); } 选项卡面板：JTabbedPane构造方法： /** * 参事说明: * tabPlacement: 选项卡标题的位置, 值为 JTabbedPane.TOP、JTabbedPane.BOTTOM、 * JTabbedPane.LEFT 或 JTabbedPane.RIGHT, 默认为 TOP * * tabLayoutPolicy: 选项卡位置不能放入所有的选项卡时，放置选项卡的策略， * 值为 JTabbedPane.WRAP_TAB_LAYOUT 或 JTabbedPane.SCROLL_TAB_LAYOUT */ JTabbedPane() JTabbedPane(int tabPlacement) JTabbedPane(int tabPlacement, int tabLayoutPolicy) //代码示例： JTabbedPane(JTabbedPane.TOP,JTabbedPane.WRAP_TAB_LAYOUT); 常用方法： //================================创建选项卡相关================================ /** * 参数说明: * title: 选项卡的标题 * icon: 选项卡的图标 * tip: 当鼠标移到该选项卡时，悬浮提示的文本 * component: 选中该选项卡时显示的内容组件 */ table.addTab(\"选项卡1\",icon,panel,\"这是一段提示语\") void addTab(String title, Component component) void addTab(String title, Icon icon, Component component) void addTab(String title, Icon icon, Component component, String tip) /** * 在指定索引位置插入一个选项卡 */ void insertTab(String title, Icon icon, Component component, String tip, int index) //==============================移除选项卡相关=================================== // 移除指定位置的选项（下面两个方法完全一致） void removeTabAt(int index) void remove(int index) // 移除指定内容控件的选项卡 void remove(Component component) // 移除所有选项卡 void removeAll() //=============================选项卡相关操作==================================== // 设置当前选中的选项卡 void setSelectedIndex(int index) // 获取当前选中的选项卡索引 int getSelectedIndex() // 获取当前选中的选项卡对应的内容组件 Component getSelectedComponent() // 设置 index 位置的选项卡的标题 void setTitleAt(int index, String title) // 设置 index 位置的选项卡的图标 void setIconAt(int index, Icon icon) // 设置 index 位置的选项卡是否可用 void setEnabledAt(int index, boolean enabled) // 将 index 位置的内容组件设置为 component void setComponentAt(int index, Component component) // 获取选项卡的数量 int getTabCount() /** * 自定义选项卡标题位置的组件, 这里的 titleComponent 将放到选项卡标题位置。 * 应用场景: 例如, 在选项卡标题位置添加一个关闭按钮, 点击按钮移除选项卡。 */ void setTabComponentAt(int index, Component titleComponent) 相关监听器： //==================状态监听器=================== JTabbledPane table = new JTabbledPane(); table.addChangeListener(new ChangeListener(){ public void stateChanged(ChangeEvent e){ //监听后具体处理操作 } }); 代码示例： package demo; import javax.swing.*; import java.awt.*; public class Demo{ public static void main(String[] args){ JFrame frame = new JFrame(\"测试窗口\"); frame.setSize(600, 600); frame.setDefaultCloseOperation(frame.EXIT_ON_CLOSE); final JTabbedPane table = new JTabbedPane(); //创建选项卡 table.addTab(\"Tab1\", createTextPanel(\"Tab01\")); table.addTab(\"Tab02\", new ImageIcon(\"bb.jpg\"), createTextPanel(\"TAB 02\")); // 创建第 3 个选项卡（选项卡包含 标题、图标 和 tip提示） table.addTab(\"Tab03\", new ImageIcon(\"bb.jpg\"), createTextPanel(\"TAB 03\"), \"This is a tab.\"); table.addChangeListener(new ChangeListener() { @Override public void stateChanged(ChangeEvent e) { System.out.println(\"当前选中的选项卡\" + table.getSelectedIndex()); } }); table.setSelectedIndex(1); frame.setContentPane(table); frame.setVisible(true); } private static Component createTextPanel(String string) { JPanel panel = new JPanel(); JLabel label = new JLabel(); label.setFont(new Font(null,Font.PLAIN,50)); label.setHorizontalTextPosition(SwingConstants.CENTER); panel.add(label); return panel; } } 层级面板：JLayredPane构造方法： // 创建一个层及面部 JLayeredPane() //代码示例 JLayeredPane layout = new JLayeredPane(); 常用API： /*添加组件到指定的层（默认放到层内最底部），参数说明: * comp: 待添加的组件 * layer: 所在的层, 层数是int类型, 由于该方法与另一个 add(Component, int) 方法类似, 直接使用会有冲突, 所以使 * 用该方法传递 layer 参数时, 必须使用 Integer 类型来明确调用的是下面 add(Component, Object) 方法。*/ 常用API 释义 void add(Component comp, Object layer)void add(Component comp, Object layer, int position) // 添加组件到指定的层和层内的位置 void setLayer(Component c, int layer)void setLayer(Component c, int layer, int position) // 设置组件所在层（默认放到层内最底部）// 设置组件所在层，以及在层内的位置 void moveToFront(Component c)void moveToBack(Component c) // 移动组件到其所在层的最顶部位置// 移动组件到其所在层的最底部位置 void setPosition(Component c, int position) // 设置组件在其所在层的位置，其中 position 取值范围为: [-1, n - 1]，n 表示层内组件数量，其中 -1 表示最底，0 表示最顶 代码示例： package demo; public class Demo{ public static void main(String[] args) { JFrame frame = new JFrame(\"测试窗口\"); frame.setSize(600, 600); frame.setVisible(true); frame.setDefaultCloseOperation(frame.EXIT_ON_CLOSE); JLayeredPane layeredPane = new JLayeredPane(); // 层数: 100 JPanel panel_100_1 = createPanel(Color.RED, \"L=100, P=1\", 30, 30, 100, 100); layeredPane.add(panel_100_1, new Integer(100)); // 层数: 200, 层内位置: 0（层内顶部） JPanel panel_200_0 = createPanel(Color.GREEN, \"L=200, P=0\", 70, 70, 100, 100); layeredPane.add(panel_200_0, new Integer(200), 0); // 层数: 200, 层内位置: 1 JPanel panel_200_1 = createPanel(Color.CYAN, \"L=200, P=1\", 110, 110, 100, 100); layeredPane.add(panel_200_1, new Integer(200), 1); // 层数: 300 JPanel panel_300 = createPanel(Color.YELLOW, \"L=300\", 150, 150, 100, 100); layeredPane.add(panel_300, new Integer(300)); frame.setContentPane(layeredPane); frame.setVisible(true); } /** * 创建一个面板容器（容器内包含一个水平方向居中, 垂直方向顶部对其的标签） * * @param bg 容器背景 * @param text 容器内标签显示的文本 * @param x 容器的横轴坐标 * @param y 容器的纵坐标 * @param width 容器的宽度 * @param height 容器的高度 * @return */ private static JPanel createPanel(Color bg, String text, int x, int y, int width, int height) { JPanel panel = new JPanel(new GridLayout(1, 1)); panel.setBounds(x, y, width, height); panel.setOpaque(true); panel.setBackground(bg); JLabel label = new JLabel(text); label.setHorizontalAlignment(SwingConstants.CENTER); label.setVerticalAlignment(SwingConstants.TOP); panel.add(label); return panel; } } 对话框（JOptionPane）父类构造方法： public static 子类名(Component parentComponent,object message,String title,int messageType); 消息对话框：（showMessageDialog)构造方法： (public staitc) showMessageDialog(Component parentComponent,object message,String title,int messageType); parentComponent：用于确定显示消息对话框父窗口。并在父窗口中间显示 message：显示对话框提示信息 title：设置对话框标题栏内容 messageType：指定显示消息类型 代码示例： JOptionPane.showMessageDialog(null,\"您输入了错误的字符\",\"消息对话框\",JOptionPane.ERROR_MESSAGE); 输入对话框：(showInputDialog)构造方法：方法的返回值是用户输入的字符串内容 (public static string)ShowInputDialog(Component parentComponent,object message,String title,int messageType); parentComponent：用于确定显示消息对话框父窗口。并在父窗口中间显示 message：显示对话框提示信息 title：设置对话框标题栏内容 messageType：指定显示消息类型 代码示例： package demo; public class demo{ public static void main(String[] args){ String str = JOptionPane.showInputDialog(this,\"输入数字，用空格分隔\",\"这是标题\",JOptionPane.PLAIN_MESSAGE); } } 确认对话框：(showConfirmDialog)返回一个整数值常量 (public static string)ShowConfirmDialog(Component parentComponent,object message,String title,int messageType); parentComponent：用于确定显示消息对话框父窗口。并在父窗口中间显示 message：显示对话框提示信息 title：设置对话框标题栏内容 messageType：指定显示消息类型 代码示例： package demo; import java.awt.BorderLayout; import javax.swing.*; public class Demo { public static void main(String[] args) { JFrame frame = new JFrame(\"BoderLayout测试窗口\"); frame.setDefaultCloseOperation(frame.EXIT_ON_CLOSE); frame.setSize(500,500); int demo = JOptionPane.showConfirmDialog(null, \"确认是否正确\",\"标题\",JOptionPane.ERROR_MESSAGE); frame.setVisible(true); } } 颜色对话框：(JColorChooser.showDialog)构造方法： public static Color showDialog(Component component, String title,Color initialColor) parentComponent：用于确定显示消息对话框父窗口。并在父窗口中间显示 message：显示对话框提示信息 title：设置对话框标题栏内容 messageType：指定显示消息类型 代码示例： package demo; import java.awt.BorderLayout; import java.awt.Color; import javax.swing.*; public class Demo { public static void main(String[] args) { JFrame frame = new JFrame(\"ColorDialog测试窗口\"); frame.setDefaultCloseOperation(frame.EXIT_ON_CLOSE); frame.setSize(500,500); Color color = JColorChooser.showDialog(null, \"测试标题\", Color.red); frame.setVisible(true); } } 自定义对话框：(JDialog)代码示例： /** * 自定义的对话框 */ public class MyDialog extends JDialog { private JTextField textField; private JButton button; /** * 自定义构造函数必须有JFrame参数，否则窗口没有依托将不会显示 * * @param frame * @param s */ public MyDialog(JFrame frame, String s) { // GUI部分 super(frame, s);// 显式调用父类构造函数 textField = new JTextField(10); button = new JButton(\"按钮\"); add(textField); add(button); setModal(true);// 设置为有模式对话框 setBounds(60, 60, 100, 100); // setVisible(true);对话框事先不设置可视性，不可视。 setDefaultCloseOperation(DISPOSE_ON_CLOSE); } } public class SimpleListener implements ActionListener { public void setMyDialog(MyDialog myDialog) { this.myDialog = myDialog; } private MyDialog myDialog; public void actionPerformed(ActionEvent event) { // 开启这个自定义对话框 myDialog.setVisible(true); } } public class SimpleWindow extends JFrame { private JButton button; private SimpleListener listener; private MyDialog myDialog; public SimpleWindow() { //GUI部分 setLayout(new FlowLayout()); button=new JButton(\"打开自定义窗口\"); add(button); setVisible(true); setBounds(100,100,200,300); setDefaultCloseOperation(DISPOSE_ON_CLOSE); myDialog=new MyDialog(this,\"这是一个自定义对话框\");//实例化这个自定义对话 框，虽然还未显示 //设置监听器 listener=new SimpleListener(); listener.setMyDialog(myDialog); //添加监听器 button.addActionListener(listener); } } public class Main { public static void main(String[] args) { SimpleWindow window = new SimpleWindow(); } } 事件处理机制：（Listener）监听器三种写法/适配器Adapter：JFrame frame = new JFrame(); frame.addWindowListener(new WindowAdapter(){ public void windowOpened(WindowEvent e){ } }); e.getSource(); //所有事件处理通用获取事件源 //监听器写法一：匿名类（最常用） JButton button = new JButton(); button.addActionListener(new ActionListener{ @Override public void actionPerformamed(ActionEvent e){ //your code } }) //监听器写法二：全称 //创建一个自定义监听器 private btnlistener btnl = new btnlistener(); btn.addActionListener(btnl); private class btnlistener implements ActionListener { public void actionPerformed(ActionEvent e) { //Your Code Here } }); //监听器写法三：lamda表达式 button.addActionListener( (e)-&gt;{ //your code }); 动作监听（ActionListener）：如果有多个组件都需要设置动作监听器，可以为它们设置同一个实例，再为组件绑定不同的动作命令（ActionCommand）来区分当前触发事件的组件。 重写actionPerformed方法 public void actionPerformed(ActionEvent e){ final String COMMAND_OK =\"OK\"; final String COMMAND_CANCEL=\"Cancel\"; ActionListener listen = new ActionListener(){ public void actionPerformed(ActionEvent e){ //e.getSource(); 获取事件源，即触发事件按钮 String command =e.getActionCommand(); if(COMMAND_OK.equals(command)){ System.out.println(\"OK按钮被点击\") }else if(COMMAND_CANCEL.equals(command)){ System.out.println(\"Cancel按钮被点击\"); } } }); 焦点监听（FocusListener）：支持组件：所有组件 重写focusGained：（焦点聚焦时） public void focusGained(FoucusEvent e){ 重写focusLost：（失去焦点时） public void focusLost(FocusEvent e){ package demo; import javax.swing.*; import java.awt.*; public class Demo{ public static void main(String[] args){ JFrame frame = new JFrame(\"测试窗口\"); frame.setDefaultCloseOperation(frame.EXIT_ON_CLOSE); frame.setSize(800,800); JButton btn = new JButton(\"OK\"); btn.addFocusListener(new FocusListener() { @Override public void focusGained(FocusEvent e) { System.out.println(\"获得焦点: \" + e.getSource()); } @Override public void focusLost(FocusEvent e) { System.out.println(\"失去焦点: \" + e.getSource()); } }); JTextField textField = new JTextField(10); textField.addFocusListener(new FocusListener() { @Override public void focusGained(FocusEvent e) { System.out.println(\"获得焦点: \" + e.getSource()); } @Override public void focusLost(FocusEvent e) { System.out.println(\"失去焦点: \" + e.getSource()); } }); frame.setContentPane(panel); frame.setVisible(true); 鼠标监听（MouseListener）：监听鼠标的所在位置。 重写方法：mouseEntered public void mouseEntered(MouseEvent e){ 重写方法：mouseExited public void mouseExited(MouseEvent e){ 重写方法：mousePressed public void mousePressed(MouseEvent e){ 重写方法：mouseReleased public void mouseReleased(MouseEvent e){ 重写方法：mouseClicked public void mouseClicked(MouseEvent e){ 代码示例： JPanel panel = new JPanel(); panel.addMouseListener(new MouseListener() { @Override public void mouseEntered(MouseEvent e) { System.out.println(\"鼠标进入组件区域\"); } @Override public void mouseExited(MouseEvent e) { System.out.println(\"鼠标离开组建区域\"); } @Override public void mousePressed(MouseEvent e) { // 获取按下的坐标（相对于组件） e.getPoint(); e.getX(); e.getY(); // 获取按下的坐标（相对于屏幕） e.getLocationOnScreen(); e.getXOnScreen(); e.getYOnScreen(); // 判断按下的是否是鼠标右键 e.isMetaDown(); System.out.println(\"鼠标按下\"); } @Override public void mouseReleased(MouseEvent e) { System.out.println(\"鼠标释放\"); } @Override public void mouseClicked(MouseEvent e) { // 鼠标在组件区域内按下并释放（中间没有移动光标）才识别为被点击 System.out.println(\"鼠标点击\"); } }); 鼠标移动/拖动监听（MouseMotionListener）：监听鼠标移动和拖动 重写方法：mouseDragged： public void mouseDragged(){ 重写方法：mouseMoved： public void mouseMoved(){ 代码示例： JPanel panel = new JPanel(); panel.addMouseMotionListener(new MouseMotionListener() { @Override public void mouseDragged(MouseEvent e) { // 鼠标保持按下状态移动即为拖动 System.out.println(\"鼠标拖动\"); } @Override public void mouseMoved(MouseEvent e) { System.out.println(\"鼠标移动\"); } }); 鼠标滚轮监听（MouseWheelListener）：监听鼠标上下滚轮滑动情况： 重写方法：mouseWheelMoved public void mouseWheelMoved(MouseWheelEvent e){ 代码示例； JPanel panel = new JPanel(); panel.addMouseWheelListener(new MouseWheelListener() { @Override public void mouseWheelMoved(MouseWheelEvent e) { // e.getWheelRotation() 为滚轮滚动多少的度量 System.out.println(\"mouseWheelMoved: \" + e.getWheelRotation()); } }); 键盘监听器（KeyListener）：代码示例： JFrame frame = new JFrame(); frame.addKeyListener(new KeyListener() { @Override public void keyPressed(KeyEvent e) { // 获取键值，和 KeyEvent.VK_XXXX 常量比较确定所按下的按键 int keyCode = e.getKeyCode(); System.out.println(\"按下: \" + e.getKeyCode()); } @Override public void keyTyped(KeyEvent e) { // e.getKeyChar() 获取键入的字符 System.out.println(\"键入: \" + e.getKeyChar()); } @Override public void keyReleased(KeyEvent e) { System.out.println(\"释放: \" + e.getKeyCode()); } }); 窗口监听（WindowListener）：支持组件：窗体类（JFrame、JDialog） 重写方法：windowOpened（窗体打开时） public void windowOpened(WindowEvent e) 重写方法；windowClosing（窗体） public void windowClosing(WindowEvente= e) 重写方法：windowClosed（窗体关闭时） public void windowClosed(windowEvent e) 重写方法：windowIconified（窗体最小化==》正常状态） public void windowIconified(WindowEvent e) 重写方法：windowActivated（窗体被激活时） public void windowActivated(windowEvent e) 重写方法：windowDeactivated（窗体不再是活动状态时） public void windowDeactivated(windowEvent e) 代码示例： JFrame frame = new JFrame(); frame.addWindowListener(new WindowListener() { @Override public void windowOpened(WindowEvent e) { System.out.println(\"windowOpened: 窗口首次变为可见时调用\"); } @Override public void windowClosing(WindowEvent e) { System.out.println(\"windowClosing: 用户试图从窗口的系统菜单中关闭窗口时调用\"); } @Override public void windowClosed(WindowEvent e) { System.out.println(\"windowClosed: 窗口调用 dispose 而将其关闭时调用\"); } @Override public void windowIconified(WindowEvent e) { System.out.println(\"windowIconified: 窗口从正常状态变为最小化状态时调用\"); } @Override public void windowDeiconified(WindowEvent e) { System.out.println(\"windowDeiconified: 窗口从最小化状态变为正常状态时调用\"); } @Override public void windowActivated(WindowEvent e) { System.out.println(\"windowActivated: 窗口变为活动状态时调用\"); } @Override public void windowDeactivated(WindowEvent e) { System.out.println(\"windowDeactivated: 窗口变为不再是活动状态时调用\"); } }); // 窗口焦点监听器 frame.addWindowFocusListener(new WindowFocusListener() { @Override public void windowGainedFocus(WindowEvent e) { System.out.println(\"windowGainedFocus: 窗口得到焦点\"); } @Override public void windowLostFocus(WindowEvent e) { System.out.println(\"windowLostFocus: 窗口失去焦点\"); } }); // 窗口状态监听器 frame.addWindowStateListener(new WindowStateListener() { @Override public void windowStateChanged(WindowEvent e) { System.out.println(\"windowStateChanged: \" + e.getNewState()); } }); 拖拽监听（DropTargetListener）：代码示例： package demo; import javax.swing.*; import java.awt.event.*; import java.io.*; public class Demo{ public static void main(String[] args){ JFrame frame = new JFrame(\"测试窗口\"); frame.setSize(600,600); final JPanel panel = new JPanel(); final JTextArea textArea = new JTextArea(); textArea.setLineWrap(true); panel.add(new JScrollPane(textArea)); DropTargetListener listener = new DropTargetListenerDemo(textArea); //创建拖拽目标监听器 DropTargetListener listener = new DropTargetListener(textArea,ACTION_COPY_OR_MOVE,listener,true); frame.SetContentPane(panel); fream.setVisible(true); frame.setDefaultCloseOperation(frame.EXIT_ON_CLOSE); } private static class DropTargetListenerDemo implements DropTargetListener{ private JTextArea textArea; public DropTargetListenerDemo(JTextArea textArea){ this.textArea = textArea; } //自动生成的方法 public void dragEnter(DropTargetDragEvent dtde) { System.out.println(\"dragEnter: 拖拽目标进入组件区域\"); } @Override public void dragOver(DropTargetDragEvent dtde) { System.out.println(\"dragOver: 拖拽目标在组件区域内移动\"); } @Override public void dragExit(DropTargetEvent dte) { System.out.println(\"dragExit: 拖拽目标离开组件区域\"); } @Override public void dropActionChanged(DropTargetDragEvent dtde) { System.out.println(\"dropActionChanged: 当前 drop 操作被修改\"); } @Override public void drop(DropTargetDropEvent dtde) { // 一般情况下只需要关心此方法的回调 System.out.println(\"drop: 拖拽目标在组件区域内释放\"); } try { /* * 1. 文件: 判断拖拽目标是否支持文件列表数据（即拖拽的是否是文件或文件夹, 支持同时拖拽多个） */ if (dtde.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) { // 接收拖拽目标数据 dtde.acceptDrop(DnDConstants.ACTION_COPY_OR_MOVE); isAccept = true; // 以文件集合的形式获取数据 List&lt;File&gt; files = (List&lt;File&gt;) dtde.getTransferable().getTransferData(DataFlavor.javaFileListFlavor); // 把文件路径输出到文本区域 if (files != null &amp;&amp; files.size() &gt; 0) { StringBuilder filePaths = new StringBuilder(); for (File file : files) { filePaths.append(\"文件: \" + file.getAbsolutePath() + \"\\n\"); } textArea.append(filePaths.toString()); } } /* * 2. 文本: 判断拖拽目标是否支持文本数据（即拖拽的是否是文本内容, 或者是否支持以文本的形式获取） */ if (dtde.isDataFlavorSupported(DataFlavor.stringFlavor)) { // 接收拖拽目标数据 dtde.acceptDrop(DnDConstants.ACTION_COPY_OR_MOVE); isAccept = true; String text = dtde.getTransferable().getTransferData(DataFlavor.stringFlavor).toString(); textArea.append(\"文本: \" + text + \"\\n\"); } /* * 3. 图片: 判断拖拽目标是否支持图片数据。注意: 拖拽图片不是指以文件的形式拖拽图片文件, * 而是指拖拽一个正在屏幕上显示的并且支持拖拽的图片（例如网页上显示的图片）。 */ if (dtde.isDataFlavorSupported(DataFlavor.imageFlavor)) { // 接收拖拽目标数据 dtde.acceptDrop(DnDConstants.ACTION_COPY_OR_MOVE); isAccept = true; // 以图片的形式获取数据 Image image = (Image) dtde.getTransferable().getTransferData(DataFlavor.imageFlavor); // 获取到 image 对象后, 可以对该图片进行相应的操作（例如: 用组件显示、图形变换、保存到本地等）, // 这里只把图片的宽高输出到文本区域 textArea.append(\"图片: \" + image.getWidth(null) + \" * \" + image.getHeight(null) + \"\\n\"); } } catch (Exception e) { e.printStackTrace(); } // 如果此次拖拽的数据是被接受的, 则必须设置拖拽完成（否则可能会看到拖拽目标返回原位置, 造成视觉上以为是不支持拖拽的错误效果） if (isAccept) { dtde.dropComplete(true); } } } } 特殊类：操作桌面应用：Desktop类：常用API： 常用API 释义 static boolean isDesktopSupported() // 判断当前平台是否支持此类 static Desktop getDesktop() // 获取与当前平台关联的 Desktop 实例 void browse(URI uri)void open(File file)void edit(File file)void print(File file) // 启动默认浏览器来显示 URI// 启动关联应用程序来打开文件// 启动关联编辑器应用程序并打开用于编辑的文件// 使用关联应用程序的打印命令, 用本机桌面打印设备来打印文件 /* * 判断当前平台是否支持某一操作, 参数为以下值之一: * Desktop.Action.OPEN: 打开动作 * Desktop.Action.EDIT: 编辑动作 * Desktop.Action.PRINT: 打印动作 * Desktop.Action.MAIL: 邮件动作 * Desktop.Action.BROWSE: 浏览器动作 */ boolean isSupported(Desktop.Action action) 代码示例： package demo; import javax.swing.*; import java.awt.*; public class Demo{ public static void main(String[] args){ if(Desktop.isDesktopSupport){ Desktop desktop = new Desktop(); desktop.browse(URI.create(\"url地址\")); desktop.open(new File(\"\")); //打开文件地址 }else{ System.out.println(\"当前平台不支持Desktop类\"); } } } 机器人：Robot类：构造方法： //创建实例，如果平台不支持Robot，将抛出异常 Robot(); //给屏幕设备创建一个Robot（关于同时使用多个显示设备情况） Robot(GraphicsDevice screen); //代码示例 Robot robot = new Robot(); 常用方法： 常用API 释义 void keyPress(int keycode)void keyRelease(int keycode) 按下/释放键盘按键, 参数说明: keycode: 键盘键值常量, 定义在 KeyEvent.VK_XXX 中 Color getPixelColor(int x, int y) // 获取指定屏幕坐标处的像素颜色 BufferedImage createScreenCapture(Rectangle screenRect) // 截屏, 截取指定的矩形区域 void mouseMove(int x, int y) // 将鼠标指针移动到指定屏幕坐标 void mouseWheel(int wheelAmt) // 在配有滚轮的鼠标上旋转滚轮 /** * 按下/释放一个或多个鼠标按钮, 参数说明: * buttons: 鼠标按钮掩码, 一个或多个以下标志的组合: * InputEvent.BUTTON1_MASK 鼠标左键 * InputEvent.BUTTON2_MASK 鼠标中键 * InputEvent.BUTTON3_MASK 鼠标右键 */ void mousePress(int buttons) void mouseRelease(int buttons) 代码示例： package demo; import java.awt.*; import java.awt.event.*; public class Demo{ public static void main(String[] args){ Robot robot = new Robot(); robot.setAutoWaitForIdle(true); //移动鼠标到指定屏幕坐标 robot.mouseMove(100,100); //按下鼠标左键 robot.mousePress(InputEvent.Button1_MASK); //释放鼠标左键 robot.mouseReleased(InputEvent.BUTTON1_MASK) } } 系统托盘：SystemTray：常用方法： 常用API 释义 SystemTray.isSupported(); // 判断当前平台是否支持系统托盘 SystemTray.getSystemTray(); // 获取到当前平台的系统托盘 TrayIcon(Image image, String tooltip, PopupMenu popup); // 创建一个托盘图标（这个图标就表示最小化后的应用），其中 popup 是点击托盘图标时弹出的菜单列表 trayIcon.setImageAutoSize(true); // 设置自动调整图标大小以适应当前平台的托盘图标显示 tray.add(trayIcon); // 添加托盘图标到系统托盘（一个应用程序可添加多个托盘图标） // tray.remove(trayIcon); 从系统托盘移除图标 监听器： // 添加托盘图标的动作监听器（鼠标右键的点击监听） trayIcon.addActionListener(ActionListener listener); // 添加托盘图标的鼠标监听器（包括鼠标所有按键的监听） trayIcon.addMouseListener(MouseListener listener); 代码示例： package demo; import java.awt.*; import java.awt.event.*; import javax.swing.*; public class Demo{ private MenuItem openitem,exitItem; private PopupMenu popupMenu; public static void main(String[] args){ SwingUtilities.invokeLater(new Runnable() { @Override public void run() { createGUI(); } }); } } public static void createGUUI(){ JFrame frame = new JFrame(); frame.setSize(900.900); frame.setDefaultCloseOperation(frame.EXIT_ON_CLOSE); if(SystemTray.isSupported){ //获取当前平台托盘 SystemTray tray = new SystemTray.getSystemTray(); popupMenu = new PopupMenu(); openItem = new MenuItem(); exitItem = new MenuItem(); //创建托盘图标 Image image = Toolkit().getDefaultToolkit().getImage(\"\"); TrayIcon trayicon = new TrayIcon(image,\"默认显示文字\"); trayicon.setImageAutoSize(true); trayicon.addActionListener(new ActionListener(){ public void actionPerformed(ActionEvent e){ System.out.println(\"托盘图标被点击\") } }); trayicon.addMouseListenr(new MouseListener(){ public void mouseClicked(MoueseEvent e){ switch(e.getSource()){ //如不懂见上文事件处理机制 case MouseEvent.BUTTON1:{ System.out.println(\"托盘图标被右击\"); break; } case MouseEvent.BUTTON2:{ System.out.println(\"托盘图标被中击\"); break; } case MouseEvent.BUTTON3{ System.out.println(\"托盘图标被左击\"); } default:{ break } } } }); try{ tray.add(trayicon); }catch(Exception e){ e.printStackTrace(); } }else{ System.out.println(\"当前系统不支持系统托盘\"); } frame.setVisible(true); } 截屏：(CaptureScreen)package com.xiets.capturedemo; import javax.imageio.ImageIO; import java.awt.*; import java.awt.image.BufferedImage; import java.io.File; public class Main { public static void main(String[] args) throws Exception { // 获取屏幕尺寸 Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize(); // 创建需要截取的矩形区域 Rectangle rect = new Rectangle(0, 0, screenSize.width, screenSize.height); // 截屏操作 BufferedImage bufImage = new Robot().createScreenCapture(rect); // 保存截取的图片 ImageIO.write(bufImage, \"PNG\", new File(\"capture.png\")); } } 剪切板（ClipBoard)代码示例： package demo; import java.awt.Toolkit; import java.awt.datatransfer.Clipboard; import java.awt.datatransfer.DataFlavor; import java.awt.datatransfer.StringSelection; import java.awt.datatransfer.Transferable; public class Main { public static void main(String[] args) throws InterruptedException { setClipboardString(\"Hello System Clipboard!\"); String text = getClipboardString(); System.out.println(\"text: \" + text); } /** * 把文本设置到剪贴板（复制） */ public static void setClipboardString(String text) { Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard(); Transferable trans = new StringSelection(text); clipboard.setContents(trans, null); } /** * 从剪贴板中获取文本（粘贴） */ public static String getClipboardString() { // 获取系统剪贴板 Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard(); // 获取剪贴板中的内容 Transferable trans = clipboard.getContents(null); if (trans != null) { // 判断剪贴板中的内容是否支持文本 if (trans.isDataFlavorSupported(DataFlavor.stringFlavor)) { try { // 获取剪贴板中的文本内容 String text = (String) trans.getTransferData(DataFlavor.stringFlavor); return text; } catch (Exception e) { e.printStackTrace(); } } } return null; } } 制作软件技巧与经验：背景图片添加：package demo; import javax.swing.*; import java.awt.*; public class createImage{ public static JPanel createBgImgJpanel(int x,int y, int width,int height,String src){ JPanel panel = new JPanel(null); panel.setBounds(x,y,width,height)l panel.setOpaque(true); ImageIcon imageicon = new ImageIcon(imgsrc); JLabel label = new JLabel(imageicon); label.setSize(width,height); panel.add(label,-1); return panel; } } //使用方法： JPanel panel =createBgImgpanel(100,50,500,500,\"这是一段文字\"); 作者的话： 完成Swing的图形化界面学习不过两个月，但是完成这份笔记和知识的输出则耗费长达一个月时间。暑假期间不定期更新博客。 创作之初还是考虑只写关键改动部分代码来节约读者阅读时间。考虑到大部分读者像我当初刚入门的模样，还是方便读者学习代码使用把代码贴上去。 熟能生巧固无错，但是整个逻辑结构要牢固。像编程一样敲码之初就应该有思路想法。 Swing已经属于被淘汰的技术，为什么要学，一口吃不成胖子。在学习其他语言GUI界面或者接触框架时仍能从Swing的学习中获取灵感与相似点。 更新博客内容后续会引入公告栏后续的内容添加方便读者阅读 引用材料： Java Swing 图形界面开发（目录）","categories":[{"name":"后端编程语言","slug":"后端编程语言","permalink":"http://www.luckyzmj.cn/categories/%E5%90%8E%E7%AB%AF%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://www.luckyzmj.cn/tags/JAVA/"},{"name":"图形化界面","slug":"图形化界面","permalink":"http://www.luckyzmj.cn/tags/%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/"}]},{"title":"关于站长","slug":"关于站长","date":"2022-03-28T12:01:09.000Z","updated":"2022-07-01T04:18:52.388Z","comments":true,"path":"posts/d7480a9.html","link":"","permalink":"http://www.luckyzmj.cn/posts/d7480a9.html","excerpt":"","text":"网站简介：网站定位： 技术型博客：将晦涩知识转变为通俗易懂的知识，同时分享工作中复用性高的代码。提高工作效率 实用性博客：制作软件、信息采集、制作个性化智能家居，让读者能切身感受编程带来便利。 成长型博客：阶梯式的教程，助力萌新程序员快速融入圈子。 站长个人技能树：专业性学科：计算机导论、linux操作系统、计算机图形学、数据结构与算法、设计模式 编程语言： 前端语言：HTML、CSS、JavaScript、JSP、JQuery 后端语言：JAVA、C#、lua、Arduino、STM32、Python 引擎： mysql、中间件 SSM（Spring + SpringMVC + Mybatis）、Springboot、 Unity（Animation、ShaderLab、Mesh） 辅助性工具： 图像工具：PS、Live2D 视频工具：PR 项目进展：JAVA： java批量添加水印： 捕鱼达人游戏： C#：Unity： 2048： 关于站长：前置要求：在做到尊重他人、不情绪化表达条件下，先阅读《提问的智慧》 提问的智慧 - LUG @ USTC 技术问题：项目Issue： Github提issue或添加新功能的需求 将问题整理后确认现有搜索引擎无法解决你的问题发送到QQ邮箱 禁区红线：","categories":[],"tags":[{"name":"站长个人简介","slug":"站长个人简介","permalink":"http://www.luckyzmj.cn/tags/%E7%AB%99%E9%95%BF%E4%B8%AA%E4%BA%BA%E7%AE%80%E4%BB%8B/"}]},{"title":"HTML知识体系","slug":"前端编程语言/HTML知识体系","date":"2022-03-27T11:42:30.000Z","updated":"2022-07-01T04:18:52.399Z","comments":true,"path":"posts/b110a111.html","link":"","permalink":"http://www.luckyzmj.cn/posts/b110a111.html","excerpt":"","text":"HTML知识体系：基本形式： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;这是元素标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--网页主题内容--&gt; &lt;/body&gt; &lt;/html&gt; Font：字体（完成）常用API： color：文字显示颜色 size：文字显示大小 基于物理样式的文本元素： 加粗文字： bold 加粗 放大元素： 缩小元素： 斜体元素： italics 下标元素： 上标元素： 等框元素： 删除字：&lt; del&gt; 基于内容样式的文本元素： 强调元素：&lt; em&gt; 文字加粗：&lt; strong&gt; 提取元素：&lt; samp&gt; 首字母缩写符：&lt; acronym&gt; 变量显示元素：&lt; var&gt; 文献参考元素：&lt; cite&gt; &lt;!--复制这一段代码到编译器或者txt文本上试一试效果吧!--&gt; &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset =\"utf-8\"&gt; &lt;title&gt; 这是网页显示标题&lt;/title&gt; &lt;body&gt; &lt;b&gt;这是一段加粗文字&lt;/b&gt; &lt;br&gt;&lt;strong&gt;这同样也是一段加粗文字哦！&lt;/strong&gt;&lt;/br&gt; &lt;br&gt;&lt;i&gt;这是一段斜体文字哦！&lt;/i&gt;&lt;/br&gt; &lt;br&gt;&lt;big&gt;这是一段被加粗的文字&lt;/big&gt;&lt;/br&gt; &lt;br&gt;&lt;sub&gt;这是上标元素&lt;/sub&gt;&lt;/br&gt; &lt;br&gt;&lt;sup&gt;这是下标元素&lt;/sup&gt;&lt;/br&gt; &lt;br&gt;&lt;tt&gt;这是等框元素&lt;/tt&gt; &lt;/body&gt; &lt;/head&gt; &lt;/html&gt; Image：图片（完成）图像元素&lt; img&gt;： border：边框 align：对齐方式 src ：文件地址 alt：图片未加载替换文本 style：浮动图像位置（可用css替换） style = “float:left” / style = “float:right” usemap：定义图像名称 href 图像链接 &lt;html&gt; &lt;head&gt; &lt;body&gt; &lt;p&gt;这是一段文字&lt;/p&gt; &lt;a href =\"这里填url图片地址\"&gt; &lt;/a&gt; &lt;img src = \"文件url地址\" width = \"330px\" height = \"110\" alt =\"测试\"&gt; &lt;/body&gt; &lt;/head&gt; &lt;/html&gt; 图像地图：&lt; map&gt;&lt;img src=\"planets.gif\" width=\"145\" height=\"126\" alt=\"Planets\" usemap=\"#planetmap\"&gt; &lt;map name=\"planetmap\"&gt; &lt;area shape=\"rect\" coords=\"0,0,82,126\" alt=\"Sun\" href=\"sun.htm\"&gt; &lt;area shape=\"circle\" coords=\"90,58,3\" alt=\"Mercury\" href=\"mercur.htm\"&gt; &lt;area shape=\"circle\" coords=\"124,58,8\" alt=\"Venus\" href=\"venus.htm\"&gt; &lt;/map&gt; 可点击图像&lt; area&gt;：特殊属性： coords：规定区域坐标 shape：规定区域的形状 &lt;img src=\"planets.gif\" width=\"145\" height=\"126\" alt=\"Planets\" usemap=\"#planetmap\"&gt; &lt;map name=\"planetmap\"&gt; &lt;area shape=\"rect\" coords=\"0,0,82,126\" alt=\"Sun\" href=\"sun.htm\"&gt; &lt;area shape=\"circle\" coords=\"90,58,3\" alt=\"Mercury\" href=\"mercur.htm\"&gt; &lt;area shape=\"circle\" coords=\"124,58,8\" alt=\"Venus\" href=\"venus.htm\"&gt; &lt;/map&gt; href：链接（完成）&lt; a&gt; 标签定义超链接，用于从一个页面链接到另一个页面。 &lt; a&gt; 元素最重要的属性是 href 属性，它指定链接的目标。 在所有浏览器中，链接的默认外观如下： 未被访问的链接带有下划线而且是蓝色的 已被访问的链接带有下划线而且是紫色的 活动链接带有下划线而且是红色的 父类属性： href 规定链接目标url download：指定下载链接 &lt;a href = \"图像url\" download = \"图像url\"&gt; &lt;a href = \"网址url\"&gt; video：音频（完成）视频元素：&lt; video&gt; src： 文件地址 controls：提供添加播放、暂停音量插件。 &lt;video controls&gt; &lt;source src = \"movie.mp4\" type = \"video/mp4\"&gt; &lt;source src = \"movie.ogg\" type = \"video/ogg\"&gt; &lt;/video&gt; 音频元素：&lt; audio&gt; autoplay：音乐就绪后马上播放 loop：循环播放 controls：显示音频控件 src 文件url &lt;audio controls&gt; &lt;source src = \"horse.ogg\" type = \"audio/ogg\"&gt; &lt;source src = “horse.mp3\" type = \"audio.mpeg\"&gt; &lt;/audio&gt; 音频元素：&lt; object&gt; &lt; embed&gt; data：元素url位置 &lt;object data =\"intro.swf\"&gt; &lt;/object&gt; &lt;embed src =\"intro.swf\"&gt; &lt; embed&gt; list：列表：（完成）有序列表：&lt; ol&gt;常用API： start：指定列表编号起始值 type：规定列表的类型，不赞成使用。请样式替代 &lt;body&gt; &lt;ol start =\"50\"&gt; &lt;li&gt;1. 测试元素&lt;/li&gt; &lt;li&gt;2. 测试元素2&lt;/li&gt; &lt;li&gt;3. 测试元素3&lt;/li&gt; &lt;/ol&gt; &lt;li&gt; &lt;li&gt;测试元素1&lt;/li&gt; &lt;li&gt;测试元素2&lt;/li&gt; &lt;li&gt;测试元素3&lt;/li&gt; &lt;/li&gt; &lt;/body&gt; 无序列表：&lt; ul&gt;列表项：&lt; li&gt;常用API： compact：规定列表呈现效果比正常情况更小巧 type：规定列表的项目符号的类型 disc：默认值，实心圆 circle：空心圆 square：实心方块 代码示例： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;列表测试功能&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li type = circle&gt;测试元素1&lt;/li&gt; &lt;li&gt;测试元素2&lt;/li&gt; &lt;li&gt;测试元素3&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; marquee：滚动字幕常用API： direction： 代码示例： GUI：表单/表格：（完成）Form：表单父类属性： type：规定显示&lt;input&gt; 元素控件 name：用在JavaScript中引用元素，或者在表单提交后引用表单数据， 注意：只有设置name属性表单元素才能提交表单时传递他们的值 &lt;!--标记name是前端好习惯之一--&gt; &lt;input type=\"button\" value =\"按钮显示文本\"&gt;&lt;/input&gt;&lt;br&gt; action：数据发送给指定服务器 &lt;form action = \"服务器名称\"&gt; value：初始显示文字 width、height：控件长宽 size：长度 文本类：&lt; text&gt;文本框 &lt; textarea&gt;：特殊属性： cols：文本区域长 rows：文本区域宽 disabled：被禁用文本区域既不可用，文本也不可选择，可以设置复选框。 wrap：换行 soft/hard &lt;textarea disabled cols = \"10\" rows = \"20\"&gt; 文本栏显示文字 &lt;/textarea&gt; 文本条 &lt; text&gt;：常规属性： size / width：文本条长度 &lt;form action = \"\"&gt; Fist Name:&lt;input type = \"text\"name = \"fistName\" width = \"10\" height = \"20\"&gt; Last Name:&lt;input type = \"text\" name = \"LastName\" width = \"10\" height =\"20\"&gt; &lt;/form&gt; 文本域 &lt; textField &gt;：&lt;form&gt; 这是一段默认显示文字&lt;input type=\"textField\" width=\"20\" height =\"20\"&gt; &lt;/form&gt; 密码字段：&lt; password&gt;常规属性： size：密码框长度 &lt;form&gt; Password:&lt;input type = \"password\" name= \"Password\"&gt; &lt;/form&gt; 按钮类：&lt; button&gt;按钮： &lt; button&gt;：&lt; form action = \"\"&gt; &lt;input type = \"button\" value = \"按钮上的文字\"&gt; &lt;/form&gt; 单选按钮： &lt; radio&gt;：属性： 继承常规属性 &lt;form action = \"\"&gt; &lt;input type = \"radio\"&gt; &lt;/form&gt; 复选框：&lt; checkbox&gt;：常规属性： &lt;form&gt; &lt;input type=\"checkbox\" name=\"vehicle\" value=\"Bike\"&gt;我喜欢自行车&lt;br&gt; &lt;input type=\"checkbox\" name=\"vehicle\" value=\"Car\"&gt;我喜欢小汽车 &lt;/form&gt; 标签元素：&lt; Label&gt;特殊属性： for：规定label与哪个表单元素绑定 form：规定label字段所属一个或多个表单 &lt;label for=\"male\"&gt;Male&lt;/label&gt; &lt;input type=\"radio\" name=\"sex\" id=\"male\" value=\"male\"&gt;&lt;br&gt; &lt;label for=\"female\"&gt;Female&lt;/label&gt; &lt;input type=\"radio\" name=\"sex\" id=\"female\" value=\"female\"&gt;&lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt; 下拉列表：&lt; select&gt;嵌套 &lt; option&gt;特殊属性：&lt; select name/multiple &gt; name：下拉列表的名称 multiple：多选 &lt; select name = “cars” size= “3”&gt; size：下拉列表中可见选项数目 autofocus：自动聚焦 &lt;select name = \"cars\" multiple size =\"3\"&gt; &lt;option value = \"第一个元素\"&gt; 首个元素&lt;/option&gt; &lt;option value = \"第二个元素\"&gt; 次号元素&lt;/option&gt; &lt;/select&gt; HTML特有控件：提交按钮： &lt; submit&gt;常规属性： &lt;form&gt; Fist Name:&lt;input type = \"submit\" value &lt;/form&gt; 表单边框：&lt; fieldset&gt;常规属性： &lt;fieldset disabled&gt; &lt;legend&gt; 表单外围文字&lt;/legend&gt; &lt;!--legend 标题--&gt; Name:&lt;input type = \"text\" size =\"30\"&gt;&lt;br&gt; E-mail:&lt;input type = \"text\" size = \"30\"&gt;&lt;br&gt; &lt;/fieldset&gt; 公共控件：&lt; input&gt; Table：表格（完成）表格：&lt; table&gt; bordercolor：颜色边框 border：边框属性 cols：列属性 cellspacing：单元格空白 cellpadding：单元格间距 align：对齐方式 bgcolor 背景颜色 表格常用元素 &lt; th&gt;：表格表头 tabel head &lt; tr&gt;：表格行 table row &lt; td&gt; 单元格 table data colspan：单元格可横跨行数 rowspan：单元格可纵跨行数 align：对齐方式 width/ height：宽度 cellspacing：单元格空白 cellpadding：单元格间距 代码示例： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;table测试功能&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table border =\"2\" bordercolor =\"yellow\" bgcolor =\"red\"&gt; &lt;tr&gt; &lt;th&gt; 这是表头&lt;/th&gt; &lt;th&gt;这是表头元素2&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;这是单元格第一行&lt;/td&gt; &lt;td&gt;这是单元格第二行&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 其他表格属性： &lt; thead&gt; 页眉thead {color:green} &lt; tfoot&gt; 页脚 tfoot { color:red} &lt; tbody&gt; 主体 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt; 网站功能Demo&lt;/title&gt; &lt;style type=\"text/css\"&gt; thead {color:green;} tbody {color:blue;} tfoot {color:red;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;table border=\"1\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Month&lt;/th&gt; &lt;th&gt;Savings&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt;Sum&lt;/td&gt; &lt;td&gt;$180&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;January&lt;/td&gt; &lt;td&gt;$100&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;February&lt;/td&gt; &lt;td&gt;$80&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; Frames：内联框架框架：&lt; frame&gt;常用API： frameborder：框架周围是否显示边框 0/1：frameborder =”1” marginheight：框架上方和下方的比啊努努 marginwidth：框架左侧和右侧边距 name：规定框架名称 noresize：规定无法调整框架大小 scrolling：框架中是否显示滚动滚动条 yes/no/auto： src：规定框架中显示的文档的url 代码示例： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;frame框架功能测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;frameset rows=\"20%,*\" scrolling =\"yes\"&gt; &lt;frame src=\"top.html\" /&gt; &lt;!-- &lt;frame src=\"01.html\" /&gt; --&gt; &lt;frameset cols=\"20%,*\"&gt; &lt;!--此部分内容替换了上面frame的位置内容--&gt; &lt;frame src=\"left.html\" /&gt; &lt;frame src=\"right.html\" /&gt; &lt;/frameset&gt; &lt;/frameset&gt; &lt;/body&gt; &lt;/html&gt; 不支持框架显示文本&lt; noframe&gt; onclick script 当鼠标被单击时执行脚本 ondblclick script 当鼠标被双击时执行脚本 onmousedown script 当鼠标按钮被按下时执行脚本 onmousemove script 当鼠标指针移动时执行脚本 onmouseout script 当鼠标指针移出某元素时执行脚本 onmouseover script 当鼠标指针悬停于某元素之上时执行脚本 onmouseup script 当鼠标按钮被松开时执行脚本 onkeydown script 当键盘被按下时执行脚本 onkeypress script 当键盘被按下后又松开时执行脚本 onkeyup script 当键盘被松开时执行脚本 代码示例： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;框架显示文本&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;frameset&gt; &lt;frame src =\"xxx.htm\"&gt;&lt;/frame&gt; &lt;frame src =\"xxx2.htm\"&gt;&lt;/frame&gt; &lt;/frameset&gt; &lt;noframe&gt;该浏览器不支持框架显示&lt;/noframe&gt; &lt;/body&gt; &lt;/html&gt; 框架集：&lt; frameset&gt;常用API： cols：规定框架集中的列的数目和尺寸 rows：规定框架集中行的数目和尺寸 共有： pixels（像素点） 100px 可用控件：5%， *可用控件的剩余部分会分配给该列 代码示例： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;frameset测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;frameset cols=\"25%,*,25%\"&gt; &lt;frame src=\"frame_a.htm\"&gt; &lt;frame src=\"frame_b.htm\"&gt; &lt;frame src=\"frame_c.htm\"&gt; &lt;/frameset&gt; &lt;/body&gt; &lt;/html&gt; 内联标签：&lt; iframe&gt; 限制大小：width height 对齐方式：align 边框大小； frameborder = “0” 下拉列表长宽：marginheight = “50” \\ marginwidth = “50” 显示文档src： src = “url” &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Frame内联框架测试功能&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt;","categories":[{"name":"前端编程语言","slug":"前端编程语言","permalink":"http://www.luckyzmj.cn/categories/%E5%89%8D%E7%AB%AF%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://www.luckyzmj.cn/tags/HTML/"},{"name":"前端三件套","slug":"前端三件套","permalink":"http://www.luckyzmj.cn/tags/%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97/"}]},{"title":"反叛公司经验","slug":"项目实操经验/反叛公司经验总结","date":"2022-03-23T05:09:05.000Z","updated":"2022-07-01T06:38:00.226Z","comments":true,"path":"posts/b9f82a38.html","link":"","permalink":"http://www.luckyzmj.cn/posts/b9f82a38.html","excerpt":"","text":"阅读目录 游戏元素 民生面板 政府面板 军事面板 叛军面板以及战术选择 游戏元素 支持度 全局支持度：（绿条）整个地区的支持度水平，无地区也会绿化就是因为全局支持度高。与公关水平有关 当地支持度：当项目落实到该地区会增加当地支持度，并逐步转向支持者。 支持度会在行动界面以绿色的数值显示来给玩家作为参考，支持度的主要作用以分区的当地支持度为准 维和行动中将中立者转化为支持者的速度，在游戏中用绿色数值表示。数值越高，中立者转化为支持者的速度越快。 敌对者会减慢支持者转化的速度，并且支持度对敌对者作用不大。（得投资对敌对者项目） 腐败 腐败风险:投资项目时可预览所滋生风险，投资高校采购可减少项目滋生腐败风险，并减少当前腐败风险，但后续投资项目价格+1。（除去蓝色计划项目和部分绿色计划项目）如普遍正义 腐败水平:腐败水平会跟随腐败风险逐渐上升。腐败水平按照百分比扣除当下支持度并缓慢扣除声望，腐败水平60%以上声望每月1点以上扣除 通货膨胀 影响计划项目价格的最主要因素之一，会随着玩家购买计划项目而增加，尤其是同一面板下的项目。民生、政府、军事（叛军）各个面板独立影响通货膨胀 一段时间内购买的越多，增加的通货膨胀水平也会越高。 会导致绿色的计划项目涨价，最好将通货膨胀控制在较低的水平 敌意 支持者《=》中立者《=》敌对者 敌对者显著影响着维稳难度，敌对者少意味维稳难度低。支持度对敌对者没什么作用，需投资针对敌对者的项目 叛军占领红区、正在攻击分区、附近分区敌意上涨敌对者增加， 敌意过高会导致原本绿区稳定进程倒退并扣除稳定声望 地图基础属性（年收入属性） 颜色越深代表人口越多道路交通越好 红色为推荐开局地： 考虑因素有：绿化难度以及周围绿化难度、情报收集度、当地交通 黄色为堡垒推荐设置地：（难度越高，堡垒内置cd越长，堡垒选址尤为重要） 考虑因素有：绿化难度、叛军营地位置最大限制、围剿叛军时位置 军事恐吓： 理由：在黄色区域没有碉堡的情况下，把联合军当碉堡使，吓唬对手营地放在你想让它出现的位置。 昏黄平原（-20%) 人口比例 地区交通 推荐开局点 中间城市：有初始支持者（63），方便支援，是整个地图中最关键的地方，叛军占领此地可向两路分兵进攻。 最大城市，可守住左下角城市群避免叛军活动直接影响声望，且有初始支持者，维稳难度较高。 主干农村：维稳难度较低，且方便支援，是较为理想的开局地。 推荐堡垒点 为图中所示 险要山隘 (+0%)：所有图中叛军发难最晚的 人口比例 道路交通 推荐开局点： 中间位置1： 理由：开局点出二级眼后叛军到来前可获取所有地区的情报，在爆出第一波叛军就能通过肉眼察觉出叛军营地位置配合无人机空袭炸毁。而且绿化难度低，敌对人口占3%。推荐开局修高速 最大城市： 理由：有初始支持者，且右边地区同样为易绿化地区，防止对面不讲武德偷袭 堡垒推荐点： 理由：可最大程度限制叛军营地位置，当然也牺牲了通过堡垒民事支持来降低维稳的难度，得从长远考虑。 南部沙漠（-10%) 人口比例 地区交通 推荐开局地 （1）理由：绿化难度低及周围绿化难度低，开局修主干道路便于支援。 推荐堡垒地： （1）四个堡垒可完全检测叛军营地位置，尤其是山上的堡垒限制对手叛军在点出远端部署攻击两座城市后或者到偏远地区流窜。 浅绿森林：（+13%) 人口比例： 地区交通 推荐开局地： （1）直接最大城市开局，人口比例22%以上，意味着即使1实力叛军骚扰都能直接影响声望。同时有初始支持者，推荐开局修主干。 推荐堡垒地： 理由：山上堡垒直接限制叛军打游击战的可能，总部附近两座堡垒可防止对手偷袭总部。 边远草原(+8%) 人口比例 地区交通 推荐开局地：（推荐开局修高速路） 主干道路城市：绿化难度低且能保护大城市（约21%人口比例) 高速道路城市：绿化难度低，且能限制叛军左下角部署 推荐堡垒地 三座堡垒再加上总部可以最大限度限制叛军营地位置，主干道路堡垒所在地维稳难度不是很高。 黑暗洞穴： 人口比例:(+4%) 地区交通： 推荐开局地： 中间农村：开局点出二级眼可获取全地图情报（除了左上角城市和山区)绿化难度也不是很高、推荐开局修高速路。 最大城市：防止叛军偷袭的基础上有初始支持者，且不容易被叛军控制分区附近周围敌意敌对者上涨属性影响。 堡垒推荐地 左下角堡垒可保障下边，如果生成叛军，建议往左下角城市赶，具体怎么赶，通过初始通勤度判断叛军溃逃位置。（控制得好再加上部署民兵完全可以玩成单机，对手全程不能操作叛军），这也是叛军营地高发点，如果点了远端部署可同时进攻三座城市使极其重要战略位置。 城市堡垒：可检测附近营地生成保障总部周围不生成叛军 蔚蓝堤坝（+10%) 人口比例： 地区交通 推荐开局地 蔚蓝堤坝绿化难度低，尤其体现在左下角，标红的为测试中维稳难度最低的区域。 靠近大城市有利于防止偷袭，或者放置在堡垒位置充当堡垒作用。 修高速可快速回防下半路，修主干可快速回防上半路。 此外，如果叛军在上下半路交界位置放置地雷需要尽快拆除，不然加上极其恶劣的交通得绕非常远的距离，上半路可以说失守，叛军可以打得非常猖狂！ 推荐堡垒地 最大程度检测叛军位置，而且最上方堡垒位置点敌对人口相当的少，容易绿化。 鸦片小道（+5%) 人口比例 地区交通 推荐开局地： 右下角城市、敌对人口少、绿化难度低且拥有初始支持者，能检测周围一格叛军生成是最理想的开局地 最大城市：（保险）全地图最差交通，总部离城市较远，如果叛军进攻大城市再携带地雷将直接影响声望。但周围分区绿化难度普遍较高，后期可以插个碉堡。 民生面板 稳定度 分区的稳定度受到支持者和敌对者的影响，敌对者越多，稳定分区需要的人数越多 民生方面计划项目不是立刻生效，而是需要时间在各个分区建设落实（地图上用锤子表示） 政府面板外展机构可以提高同时建设项目的线程和速度，即分区同时落实项目。 稳定度缺乏：玩家在一段时间内未有新地区进入稳定状态而扣除声望，扣除声望累加，直到新分区进入稳定后重置。 需求关切 特定分区民众会昌盛特定民生项目的强烈需求，在该分区的情报完全获取后其关切逐渐显现 该分区的区域关切如果迟迟未被建设和回应便会按比例扣除当地支持度 现版本的民生项目会优先实施该区域关切条目，解决关切只需要购买相对应的项目即可 已稳定分区仍然会产生关切，只不过无影响。 已经在分区落实该类的项目，之后该分区再次产生同类的诉求概率下降。 服务业 父类特点：建设速度快且便宜，增加支持度较少，削减敌对者效率显著。 子类：教育线：实施速度快、落实进度快，通货膨胀和腐败涨幅低，但支持度较少。扫盲运动不产生通货膨胀 子类：水务线：产生通货膨胀低，但代价是产生腐败高 子类：医疗线：产生腐败风险低，但代码是通货膨胀高。 基础设施建设 父类特点：功能性辅助，如通勤率，情报收集速度和建设速度等，也能增加当支持度。但代价是腐败、通货膨胀涨幅较高 子类：道路修建：增加当地路况通勤率增加士兵移动速度并提高士兵在当地的战斗力。增加当地项目建设速度和加快 子类：电力供应：加快项目在当地的建设速度 子类：通讯项目：在每个分袂落实项目后额外向周围分区提供支持度 就业 特点：增加支持度较多，但代价是建设速度慢、项目滋生腐败高、通货膨胀涨幅大。且具 部分就业计划项目的支持度增加有明显的分区偏向性（对城市/农村/偏远地区增加更多）。 建设速度比较慢，且对敌对者的作用不大。 民生具体数据 政府面板 声望 是整个游戏基础，声望归零时游戏失败。 声望可以通过稳定区域、谈判、部分事件、普遍正义、民主选举获得 声望影响年度预算低声望下预算下降。 影响的主要因素有： 稳定度缺乏：长期没有新的稳定区域，两年后开始出现稳定度缺乏，若没有稳定一定分区，新的分区进入稳定后重置稳定度缺乏时间为八个月。 腐败：（腐败水平过高） 叛军活动（所有与叛军活跃战士有关的活动），无叛军的红区不扣声望 政府行为：指一切事件决策，除联合军部署 联合军部署：联合军驻扎期到期时选择延期 交战中军队突然撤退 谈判（属于政府行为的范畴，主要是谈判中的表现，但最终签字扣除的声望属于叛军活动范畴） 情报 分区若没有情报，建设项目就不能执行（除了民兵和疫苗只会建设速度下降),部分事件的选项也不能选择，已经执行的项目不受影响 让玩家充分了解当地情况以便于解决当地诉求 影响部队作战，情报低于大约五分之一的情况无法开展，部队在情报没有搜集完全的区域战斗时战力大降。 军事项目的“译员向导”和“人类地形系统”可以在有士兵驻扎的情况下加快情报搜集 安全度 主要分为民兵、警员招募和警队扩编 所有安保项目可以降低叛军攻击速度，叛军需要将地区安全度降为零才能完全占领该地区。而安保项目被摧毁时杀死一活跃战士。 滋生的腐败相对较高，而且警员招募部署速度约为每小时五公里 民兵项目会扣除当地支持度，但是建设速度很快，不需要情报。如果不想买，可以通过普遍正义解锁警员招募 公关水平 组建宣传机构可以大幅度增加计划条目带来的支持度提升，并阻止叛军活动降低我方支持度。因此此项为必点项目。然而前期太贵而且必须要点出情报才能点，关键效果也不是很好。还不如省下这笔费用打叛军 政府活动项目 普遍正义 可以获得3声望+不少支持度，6~7刀 能跳过民兵招募，直接解锁警员招募 点出普遍正义后，某些突发事件的选项可能会因司法伪善而招致民愤牛皮先吹出去再说 民主过渡： 可以获得2点声望+ 少量支持度，8刀左右 购买此项后会弹出筹备民主选举，一年之内举办为18刀，三年之内为9刀。推迟则会扣除2点声望。推迟后还会弹出是否民主选举。筹备选举后不需要支付额外费用 弹出民主选举举行，视叛军占领情况决定被破坏的概率。 外务机构(对抗模式下无) 主要用于应对境外敌国暗地支持，随着时间推移效果会增强。省得每次反击浪费8刀。 好家伙，对抗模式某敌国明面上支持 外展机构 解锁全部政府活动项目 主要用于增加项目在特定分区的建设线程，可以增加分区同步实施项目数量以及部署速度。（城市2=&gt;4,乡村、偏远1=&gt;2) 国际援助： 购买此项后会得到国际慈善机构的额外资源，可以免费实施一些民生项目（通货腐败爆炸）我TM谢谢啊，带善人或增加年度预算(+3)，耗费7刀 7刀项目而且好几年才能回本，而且弹窗可能要很久才能弹出，对抗不建议点 军事面板0.己方军队 正常情况下，己方军队无敌（跟叛军苦战多久都不会被叛军歼灭）。 他们会跟地区内的叛军交战。如果占上风，叛军会被驱逐。反之，叛军该干啥干啥。开战需要一定量的情报，而没有完全搜集情报地区的友军效率大幅度降低。 如果部队目前不处于战斗状态，他们会优先协助附近分区与叛军交战友军。如果周围没有战斗但民事支援项目已被资助，部队会帮助当地人员部署计划并加支持度。 后勤耗费决定了单位移动到地区所需要的回合数 - 难度越高，这个数值越大。道路基建、堡垒、物流专家只影响稳定区，和国民军后勤机动可以削减这个数字。 一块分区里只能有一支玩家军队。 战斗最短时间为5回合，可以围剿时可以让部队先开战控制叛军，等其他部队到达。 1. 国民军相关 国民军：（解锁要塞项目） 情报搜集速度比联合军快，且引起民愤几率低 作为常备军，国民军不会撤军。 训练一支国民军需要很多时间估计要23个月训练 - 如果地图上有联合军，则训练时间减少大概7个月，而且开始训练时腐败风险会大幅度上涨。 对抗模式节奏飞快，显然等腐败回落再一支一支训练国民军不适合版本发展，建议只开一支国民军用于解锁要塞。 每个分区内只能有一个堡垒。 堡垒建设事件会随机刷在不存在堡垒的，叛军占领区或有叛军活动的周边区域（我方战斗点优先） 堡垒升级可以强化增援效果和分区支持度，并可以降低叛军攻占地区速度。但对抗模式下堡垒十分滴珍贵，用于稳定分区太奢侈了应该往后期考虑放在中心位置用于探营地。 叛军不能直接在堡垒的位置生成，也可建造在大城市用于防止偷袭。 要塞： 堡垒可以为部队提供增援并切断敌军逃跑路线也可以帮助部队拆营 堡垒升级可以强化增援效果和分区支持度，并可以降低叛军攻占地区速度。 堡垒可以探测到自己区域内的叛军营地，安保升级可以让它检测到周围一格距离的叛军营地（前提是有100%情报）。对抗可以用来限制对手营地安放位置，营地建造在周围马上显示并用空袭炸毁。叛军无法生成就能持续吃支持度加成。 每个分区内只能有一个堡垒。 堡垒建设事件会随机刷在不存在堡垒的，叛军占领区或有叛军活动的周边区域（我方战斗点优先） 堡垒升级可以强化增援效果和分区支持度，并可以降低叛军攻占地区速度。但对抗模式下堡垒十分滴珍贵，用于稳定分区太奢侈了应该往后期考虑放在中心位置用于探营地。 叛军不能直接在堡垒的位置生成，也可建造在大城市用于防止偷袭。 总部： 游戏一开始既可建造的建筑，全游戏只能有一个。 和堡垒一样也可以为部队提供增援并增加分区支持度和安保力量。 从困难开始，训练完成的军队需要从总部行进到目标区域，而非直接空降到目标区域。 实施民生计划一般以总部为中心向外放射式实施。根据这一点和上一点，请务必在开局认真考虑总部位置。 当它所在的分区沦陷时，叛军会试图摧毁该建筑 - 如果它被摧毁，玩家立即失败。 与堡垒不同，叛军在面对总部时即使遭到压制也会继续试图摧毁总部，因此通常试图拯救总部不太可能成功 2. 联合军相关 联合军：战斗力完爆国民军，但如果没有向导或者民事援助类项目容易引起民愤从而敌对者上升。 购买后支持度会下降 临时驻扎两年，到期后需要扣声望留下。送回家增加玩家支持度和叛军实力。你真会挑时候走正需要的时候思乡 如果联合军长期陷入苦战，将其缩短驻扎时间。 如果联合军一支在行军路上则不消耗驻扎期，所以可以用校长微操，让联合军保持一直在场状态直到所有分区稳定，干脆住这里得了。 空袭：对抗模式下手动控制 空袭有概率杀死地区内活动的叛军 轰炸时有概率触发误伤平民事件别问，问就掩饰。还挺真实的 优先为地面正在苦战的部队提供强效支援，其次为可见的叛军营地 叛军营地必须要在地图上被显示出来才能被攻击，而一旦该分区被炸到，这个营地会立刻倒下。当某一分区内的叛军营地被摧毁且该分区内无军队驻扎，则该分区将会被叛军突袭。（对抗模式则不会爆1实力叛军） 多次轰炸的支援效果可叠加到战斗结束为止 升级可以削弱冷却时间，增加攻击力和平民伤亡概率以及精确度降低误伤概率，稍稍增加冷却时间，掩饰失败后当地会爆发少部分叛军。 联合军随时间推移所在分区支持度会持续下降，尽量别让联合军驻扎过久。 叛军面板叛军属性 叛军生成：叛军会固定从叛军营地所在分区和该分区周围出现，为一格距离，只要营地没有被摧毁，叛军就可以不断出现（直到达到叛军可维持上限）， 叛军营地： 提供活跃战士战力加成，并且能在周围一格的地区部署叛军，一次部署活跃战士上限为4。 在情报探明的分区，叛军营地以问号的形式逐渐显示。 叛军溃逃：叛军不会跨越边缘地区和河流。且不往士兵和堡垒分区跑 优先往叛军营地或者有叛军活动方向跑（解释了为什么叛军在两个城市之间反复跑不往山里跑的原因） 其次往通勤度低分区跑，高速路&gt;主干路&gt;分支路（解释了叛军为什么往山里跑) 叛军进攻：（敌对者多的区域安全度掉得快），增加区域内的敌对者数量，叛军占领后可降低我方全局支持度。 叛军活动：活跃战士活动的分区人口比例越高，扣除声望越多。如大城市一回合扣一点。红区无叛军活动则不扣除声望守住大城市，避免对手不讲武德用伏击偷袭 叛军占领红区属性： 叛军接管+1：当叛军再次控制该区域时，能更多扣除声望。扣除声望能叠加，所以不要反复丢失区域尤其是城市。 叛军进攻：如果叛军战斗中占上风（士兵战斗进程40%左右）分区的安全度会缓慢下降。 叛军红区属性 使分区内支持者数量减少，并慢慢转换为敌对者。我搞建设大半天才几点支持度，一占领就-10多点，真叛军得人心，其附近地区敌意也上升，增加后续维稳难度 会不定时摧毁占领分区内的建筑，一旦占领，正在建设中的项目便会停滞。 情报丢失：叛军控制分区会逐渐丧失情报，进而隐藏叛军营地等设施。 战力加成：一个地方的叛军如果周围有一个红区，战力2，有两个3，以此类推 叛军实力：主要有以下获得方式 叛军占地多且连接的情况下叛军实力逐渐增长（自力更生） 购买叛军资助项目叛军实力直接强化，且减营地冷却时间。附近红区为战斗中活跃战士提供战力加成。 叛军实力决定了他们可维持战士的数量，维持一名战士需要大概3%的实力。所以削弱叛军实力的宗教领袖显得尤为重要 叛军击杀：叛军溃逃途中有一定几率能杀死活跃叛乱分子！ 小技巧：保证路况足够好的情况下，在叛军即将到达分区时，士兵恰好到达，则会杀死1叛乱分子。并重新选择溃逃分区，叛军下限为1.利用此技巧可以快速杀死多名叛乱分子，最后1实力交给当地民兵解决。 叛军设施 叛军资助：上限为6，直接增强叛军实力的同时显著缩短叛军营地冷却时间 叛军资助1：解锁地雷和苏式地堡 叛军资助2：解锁远端部署 （1）苏式地堡：同地区特性苏式地堡，能耐受数次空袭。能换取前期的优势。但叛军面板解锁后正是出资训兵时，通货膨胀显著上升不建议前期点。 （2）远端部署：允许叛军在营地附近两格位置部署。将叛军放置在山区附近能让对手短时间内无法判断营地具体位置。 叛军指令：（能在未稳定分区使用) 迅速占领：解锁堡垒破袭和伏击 加快当前叛军占领分区的速度，闪电战推荐技能点 堡垒破袭：摧毁指定分区内存在的堡垒 稳定度缺乏打击：当对手正在吃稳定度缺乏时，高稳定度分区建造带有民事支援的堡垒需要尽快炸毁，让对手持续吃稳定度缺乏 围剿突围：如果对手堡垒处没有士兵而是利用堡垒进行合围可以炸毁堡垒炸出一个缺口使对手不能完成围剿。 伏击： 在未稳定分区指定生成部分叛军，活跃战士取决于叛军实力。主要用于开辟第二战场是对手无法两头兼顾作战，或者是搭配叛军建筑来达到偷袭或者逃跑作用。 叛军建筑：（需要叛军所在处才能使用） 洞穴：藏匿两实力叛军，如对手不能及时清理则会再次出来继续叛乱。 主要用于拖延对手一支部队无法短时间内移动，从而逼迫开出洞穴战术，或者是卡对手支援位无法及时支援。 隧道：允许叛军在隧道两头进行无后勤传送 主要用于拖延使对手无法短时间内歼灭叛军从而吃支持度加成，亦或者搭配伏击进攻重大城市！ 地雷：固定增加16行军数，并改变部队前进方向。如部队在地雷所在分区的途中则不受地雷的影响。 对抗模式下战术选择 规则解读：（首先得先了解清楚具体规则才能展开具体战术的用法） 胜利： 先于对手全稳定分区 摧毁对方总部 对方声望归零 支持加成：消灭我方区域全部叛乱分子并阻止叛军回溯，即可使我方区域支持度随时间推移显著增加（高难度下决定速歼战术） 骚扰战术：适用范围：适用于高难度打低难度，或者对方重军事的对手： 主要思路：使对手持续在军事上投资无法忙于民生项目发展和政府反腐投资，或者是牵制联合军使其持续战斗从而早早回国。 搭配组合：地雷+伏击+隧道+洞穴 主要思路：地雷用于防守或阻碍对手围剿时间，亦或者发动围剿时就发起进攻扰乱对手的围剿路线，用伏击开辟第二战场后将围剿叛军传送并放置洞穴用于拖住一支部队。 偷袭战术：适用范围：适用于对手忙于前线作战而后方重大城市防守空缺： 搭配组合：伏击+地雷+隧道 伏击开路使该区域存在叛军后使用地雷防止对手快速回防，后放置隧道以便于后续叛军重新夺回区域造成重大声望损失，同时也逼迫对手守该分区隧道。同时还可以用于进攻对手高稳定进度分区，从而让对手持续吃稳定度缺乏！ 稳定输出：适用于对手稳扎稳打只防守不进攻： 搭配组合：伏击+隧道 主要思路：在所控制分区事先放置一条隧道后，用伏击开辟第二战场，将大部分活跃战士通过隧道传送到目的地快速破防。留下的少部分叛军用于牵制对手踩红区造成叛军实力下降，或者是对手踩了红区光速进攻夺回造成声望损失，牵制对手无法及时回防。 拆家战术： 搭配组合：地雷+其余叛军牵制 主要思路：得看对手总部位置（如萌新总部建山上），利用其余叛军牵制主对手能控制的部队，集中力量进攻对手总部放置地雷拖延部队回防时间 我方战术：明确一点高难度下无法通过正常途径维稳来赢，那么速歼叛军，并维稳便是唯一的手法。 反叛军突围：可能叛军即将叛逃时秒起堡垒从而使对手无法及时炸堡垒突围。 如果对手不断在红区发起进攻导致无法合围，那么建议踩红区后在有盾的分区叛军无法短时间行动中围剿歼灭，对手如果分多个方向那么民兵就显得尤为重要 歼灭细节： 关于围剿： 一次清剿就要耗费大量的资源和驻军期，能一次剿灭就不拖到下一次。 行军数：联合军在附近区域一格一格走避免跨大分区时出现紧急情况而又无法取消，熟悉地图的通勤度便能掌握到相邻分区大概需要多少回合，已到达围剿地点的联合军可撤往其他位置但不能落地（减少驻军期消耗），带围剿的联合军到达后，其他围剿位置联合军全部取消。从而缩短驻军期消耗 关于民生： 民生面板：依次点医疗、教育、供水一项（防诉求）就业点职业培训（防诉求），后修一级路（具体得看地图）和通讯（绿化加成多）。 政府面板：开局点出民兵，因为开局就要歼灭对手叛军防止高难度叛军实力大从而导致局势失控。之后中期反腐（估计这个时候也没什么钱了），之后就是看情况开情报一级（用于开喇叭）和喇叭！ 军事面板：一蓝一绿：（开出三大件：堡垒、空袭、无人机），联合军派出用于军事恐吓对手限制营地的放置，爆发叛军后便立刻前往且短时间击退，确定营地位置后开出空袭无人机及时炸毁防止叛军前期开花。蓝军建议部署四支，搭配上堡垒能短时间内速剿叛军，且每个重要分区伏击都落地一直联合军便让这支联合军一直在路上不消耗驻军期！ 参考资料： [萌娘百科](反叛公司 - 萌娘百科 万物皆可萌的百科全书 (moegirl.org.cn)) [反叛公司民生数据贴]([图片]反叛数据贴（最全）[反叛公司吧]_百度贴吧 (baidu.com))","categories":[{"name":"项目实操经验","slug":"项目实操经验","permalink":"http://www.luckyzmj.cn/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%93%8D%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"反叛公司","slug":"反叛公司","permalink":"http://www.luckyzmj.cn/tags/%E5%8F%8D%E5%8F%9B%E5%85%AC%E5%8F%B8/"}]}],"categories":[{"name":"后端编程语言","slug":"后端编程语言","permalink":"http://www.luckyzmj.cn/categories/%E5%90%8E%E7%AB%AF%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"前端编程语言","slug":"前端编程语言","permalink":"http://www.luckyzmj.cn/categories/%E5%89%8D%E7%AB%AF%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"引擎框架","slug":"引擎框架","permalink":"http://www.luckyzmj.cn/categories/%E5%BC%95%E6%93%8E%E6%A1%86%E6%9E%B6/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.luckyzmj.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"计算机原理","slug":"计算机原理","permalink":"http://www.luckyzmj.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"},{"name":"项目实操经验","slug":"项目实操经验","permalink":"http://www.luckyzmj.cn/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%93%8D%E7%BB%8F%E9%AA%8C/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://www.luckyzmj.cn/tags/C/"},{"name":"网络编程","slug":"网络编程","permalink":"http://www.luckyzmj.cn/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"多线程","slug":"多线程","permalink":"http://www.luckyzmj.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"前端三件套","slug":"前端三件套","permalink":"http://www.luckyzmj.cn/tags/%E5%89%8D%E7%AB%AF%E4%B8%89%E4%BB%B6%E5%A5%97/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.luckyzmj.cn/tags/JavaScript/"},{"name":"图形化界面","slug":"图形化界面","permalink":"http://www.luckyzmj.cn/tags/%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2/"},{"name":"Css","slug":"Css","permalink":"http://www.luckyzmj.cn/tags/Css/"},{"name":"Unity引擎","slug":"Unity引擎","permalink":"http://www.luckyzmj.cn/tags/Unity%E5%BC%95%E6%93%8E/"},{"name":"Animation","slug":"Animation","permalink":"http://www.luckyzmj.cn/tags/Animation/"},{"name":"ShaderLab","slug":"ShaderLab","permalink":"http://www.luckyzmj.cn/tags/ShaderLab/"},{"name":"Mesh","slug":"Mesh","permalink":"http://www.luckyzmj.cn/tags/Mesh/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://www.luckyzmj.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"计算机原理","slug":"计算机原理","permalink":"http://www.luckyzmj.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"},{"name":"排序算法","slug":"排序算法","permalink":"http://www.luckyzmj.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"JAVA","slug":"JAVA","permalink":"http://www.luckyzmj.cn/tags/JAVA/"},{"name":"SpringBoot框架","slug":"SpringBoot框架","permalink":"http://www.luckyzmj.cn/tags/SpringBoot%E6%A1%86%E6%9E%B6/"},{"name":"动态规划","slug":"动态规划","permalink":"http://www.luckyzmj.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"常用API","slug":"常用API","permalink":"http://www.luckyzmj.cn/tags/%E5%B8%B8%E7%94%A8API/"},{"name":"Mysql","slug":"Mysql","permalink":"http://www.luckyzmj.cn/tags/Mysql/"},{"name":"集合与泛型","slug":"集合与泛型","permalink":"http://www.luckyzmj.cn/tags/%E9%9B%86%E5%90%88%E4%B8%8E%E6%B3%9B%E5%9E%8B/"},{"name":"IO流文件操作","slug":"IO流文件操作","permalink":"http://www.luckyzmj.cn/tags/IO%E6%B5%81%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"name":"站长个人简介","slug":"站长个人简介","permalink":"http://www.luckyzmj.cn/tags/%E7%AB%99%E9%95%BF%E4%B8%AA%E4%BA%BA%E7%AE%80%E4%BB%8B/"},{"name":"HTML","slug":"HTML","permalink":"http://www.luckyzmj.cn/tags/HTML/"},{"name":"反叛公司","slug":"反叛公司","permalink":"http://www.luckyzmj.cn/tags/%E5%8F%8D%E5%8F%9B%E5%85%AC%E5%8F%B8/"}]}